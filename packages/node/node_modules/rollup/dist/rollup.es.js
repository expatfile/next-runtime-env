/*
  @license
	Rollup.js v1.12.4
	Mon, 27 May 2019 05:38:54 GMT - commit d4ce5065adbd0381ac81856197394198993c5775


	https://github.com/rollup/rollup

	Released under the MIT License.
*/
import util$2 from 'util';
import path, { relative, extname, basename, dirname, resolve as resolve$1, sep } from 'path';
import * as acorn__default from 'acorn';
import { tokTypes, Parser as Parser$1 } from 'acorn';
import fs__default, { writeFile as writeFile$1, readdirSync, mkdirSync, readFileSync, lstatSync, realpathSync, statSync, watch as watch$1 } from 'fs';
import { EventEmitter } from 'events';
import tty from 'tty';
import net from 'net';
import url from 'url';
import module$1 from 'module';

var version = "1.12.4";

var minimalisticAssert = assert;
function assert(val, msg) {
    if (!val)
        throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
        throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    }
    else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () { };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        };
    }
});

var inherits = createCommonjsModule(function (module) {
    try {
        var util = util$2;
        if (typeof util.inherits !== 'function')
            throw '';
        module.exports = util.inherits;
    }
    catch (e) {
        module.exports = inherits_browser;
    }
});

var inherits_1 = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
        return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
        return false;
    }
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg))
        return msg.slice();
    if (!msg)
        return [];
    var res = [];
    if (typeof msg === 'string') {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
                var c = msg.charCodeAt(i);
                if (c < 128) {
                    res[p++] = c;
                }
                else if (c < 2048) {
                    res[p++] = (c >> 6) | 192;
                    res[p++] = (c & 63) | 128;
                }
                else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = (c >> 18) | 240;
                    res[p++] = ((c >> 12) & 63) | 128;
                    res[p++] = ((c >> 6) & 63) | 128;
                    res[p++] = (c & 63) | 128;
                }
                else {
                    res[p++] = (c >> 12) | 224;
                    res[p++] = ((c >> 6) & 63) | 128;
                    res[p++] = (c & 63) | 128;
                }
            }
        }
        else if (enc === 'hex') {
            msg = msg.replace(/[^a-z0-9]+/ig, '');
            if (msg.length % 2 !== 0)
                msg = '0' + msg;
            for (i = 0; i < msg.length; i += 2)
                res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    }
    else {
        for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
    }
    return res;
}
var toArray_1 = toArray;
function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
    return res;
}
var toHex_1 = toHex;
function htonl(w) {
    var res = (w >>> 24) |
        ((w >>> 8) & 0xff00) |
        ((w << 8) & 0xff0000) |
        ((w & 0xff) << 24);
    return res >>> 0;
}
var htonl_1 = htonl;
function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === 'little')
            w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
var toHex32_1 = toHex32;
function zero2(word) {
    if (word.length === 1)
        return '0' + word;
    else
        return word;
}
var zero2_1 = zero2;
function zero8(word) {
    if (word.length === 7)
        return '0' + word;
    else if (word.length === 6)
        return '00' + word;
    else if (word.length === 5)
        return '000' + word;
    else if (word.length === 4)
        return '0000' + word;
    else if (word.length === 3)
        return '00000' + word;
    else if (word.length === 2)
        return '000000' + word;
    else if (word.length === 1)
        return '0000000' + word;
    else
        return word;
}
var zero8_1 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    minimalisticAssert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === 'big')
            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
        else
            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
var join32_1 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === 'big') {
            res[k] = m >>> 24;
            res[k + 1] = (m >>> 16) & 0xff;
            res[k + 2] = (m >>> 8) & 0xff;
            res[k + 3] = m & 0xff;
        }
        else {
            res[k + 3] = m >>> 24;
            res[k + 2] = (m >>> 16) & 0xff;
            res[k + 1] = (m >>> 8) & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
var split32_1 = split32;
function rotr32(w, b) {
    return (w >>> b) | (w << (32 - b));
}
var rotr32_1 = rotr32;
function rotl32(w, b) {
    return (w << b) | (w >>> (32 - b));
}
var rotl32_1 = rotl32;
function sum32(a, b) {
    return (a + b) >>> 0;
}
var sum32_1 = sum32;
function sum32_3(a, b, c) {
    return (a + b + c) >>> 0;
}
var sum32_3_1 = sum32_3;
function sum32_4(a, b, c, d) {
    return (a + b + c + d) >>> 0;
}
var sum32_4_1 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
}
var sum32_5_1 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
var sum64_1 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
var sum64_hi_1 = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
var sum64_lo_1 = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
var sum64_4_hi_1 = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
var sum64_4_lo_1 = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
var sum64_5_hi_1 = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
var sum64_5_lo_1 = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
}
var rotr64_hi_1 = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
}
var rotr64_lo_1 = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
var shr64_hi_1 = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
}
var shr64_lo_1 = shr64_lo;
var utils = {
    inherits: inherits_1,
    toArray: toArray_1,
    toHex: toHex_1,
    htonl: htonl_1,
    toHex32: toHex32_1,
    zero2: zero2_1,
    zero8: zero8_1,
    join32: join32_1,
    split32: split32_1,
    rotr32: rotr32_1,
    rotl32: rotl32_1,
    sum32: sum32_1,
    sum32_3: sum32_3_1,
    sum32_4: sum32_4_1,
    sum32_5: sum32_5_1,
    sum64: sum64_1,
    sum64_hi: sum64_hi_1,
    sum64_lo: sum64_lo_1,
    sum64_4_hi: sum64_4_hi_1,
    sum64_4_lo: sum64_4_lo_1,
    sum64_5_hi: sum64_5_hi_1,
    sum64_5_lo: sum64_5_lo_1,
    rotr64_hi: rotr64_hi_1,
    rotr64_lo: rotr64_lo_1,
    shr64_hi: shr64_hi_1,
    shr64_lo: shr64_lo_1
};

function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
var BlockHash_1 = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending)
        this.pending = msg;
    else
        this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
            this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    minimalisticAssert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
        res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === 'big') {
        for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = (len >>> 24) & 0xff;
        res[i++] = (len >>> 16) & 0xff;
        res[i++] = (len >>> 8) & 0xff;
        res[i++] = len & 0xff;
    }
    else {
        res[i++] = len & 0xff;
        res[i++] = (len >>> 8) & 0xff;
        res[i++] = (len >>> 16) & 0xff;
        res[i++] = (len >>> 24) & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
    }
    return res;
};
var common = {
    BlockHash: BlockHash_1
};

var rotr32$1 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0)
        return ch32(x, y, z);
    if (s === 1 || s === 3)
        return p32(x, y, z);
    if (s === 2)
        return maj32(x, y, z);
}
var ft_1_1 = ft_1;
function ch32(x, y, z) {
    return (x & y) ^ ((~x) & z);
}
var ch32_1 = ch32;
function maj32(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
}
var maj32_1 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
var p32_1 = p32;
function s0_256(x) {
    return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);
}
var s0_256_1 = s0_256;
function s1_256(x) {
    return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);
}
var s1_256_1 = s1_256;
function g0_256(x) {
    return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);
}
var g0_256_1 = g0_256;
function g1_256(x) {
    return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);
}
var g1_256_1 = g1_256;
var common$1 = {
    ft_1: ft_1_1,
    ch32: ch32_1,
    maj32: maj32_1,
    p32: p32_1,
    s0_256: s0_256_1,
    s1_256: s1_256_1,
    g0_256: g0_256_1,
    g1_256: g1_256_1
};

var sum32$1 = utils.sum32;
var sum32_4$1 = utils.sum32_4;
var sum32_5$1 = utils.sum32_5;
var ch32$1 = common$1.ch32;
var maj32$1 = common$1.maj32;
var s0_256$1 = common$1.s0_256;
var s1_256$1 = common$1.s1_256;
var g0_256$1 = common$1.g0_256;
var g1_256$1 = common$1.g1_256;
var BlockHash$1 = common.BlockHash;
var sha256_K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256))
        return new SHA256();
    BlockHash$1.call(this);
    this.h = [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash$1);
var _256 = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
    for (; i < W.length; i++)
        W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    minimalisticAssert(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
        var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);
        var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32$1(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32$1(T1, T2);
    }
    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f);
    this.h[6] = sum32$1(this.h[6], g);
    this.h[7] = sum32$1(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex')
        return utils.toHex32(this.h, 'big');
    else
        return utils.split32(this.h, 'big');
};

var charToInteger = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars.length; i++) {
    charToInteger[chars.charCodeAt(i)] = i;
}
function decode(mappings) {
    var generatedCodeColumn = 0; // first field
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var decoded = [];
    var line = [];
    var segment = [];
    for (var i = 0, j = 0, shift = 0, value = 0, len = mappings.length; i < len; i++) {
        var c = mappings.charCodeAt(i);
        if (c === 44) { // ","
            if (segment.length)
                line.push(new Int32Array(segment));
            segment = [];
            j = 0;
        }
        else if (c === 59) { // ";"
            if (segment.length)
                line.push(new Int32Array(segment));
            segment = [];
            j = 0;
            decoded.push(line);
            line = [];
            generatedCodeColumn = 0;
        }
        else {
            var integer = charToInteger[c];
            if (integer === undefined) {
                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value += integer << shift;
            if (hasContinuationBit) {
                shift += 5;
            }
            else {
                var shouldNegate = value & 1;
                value >>= 1;
                var num = shouldNegate ? -value : value;
                if (j == 0) {
                    generatedCodeColumn += num;
                    segment.push(generatedCodeColumn);
                }
                else if (j === 1) {
                    sourceFileIndex += num;
                    segment.push(sourceFileIndex);
                }
                else if (j === 2) {
                    sourceCodeLine += num;
                    segment.push(sourceCodeLine);
                }
                else if (j === 3) {
                    sourceCodeColumn += num;
                    segment.push(sourceCodeColumn);
                }
                else if (j === 4) {
                    nameIndex += num;
                    segment.push(nameIndex);
                }
                j++;
                value = shift = 0; // reset
            }
        }
    }
    if (segment.length)
        line.push(new Int32Array(segment));
    decoded.push(line);
    return decoded;
}
function encode(decoded) {
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var mappings = '';
    for (var i = 0; i < decoded.length; i++) {
        var line = decoded[i];
        if (i > 0)
            mappings += ';';
        if (line.length === 0)
            continue;
        var generatedCodeColumn = 0; // first field
        var lineMappings = [];
        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
                segmentMappings +=
                    encodeInteger(segment[1] - sourceFileIndex) +
                        encodeInteger(segment[2] - sourceCodeLine) +
                        encodeInteger(segment[3] - sourceCodeColumn);
                sourceFileIndex = segment[1];
                sourceCodeLine = segment[2];
                sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
                segmentMappings += encodeInteger(segment[4] - nameIndex);
                nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(',');
    }
    return mappings;
}
function encodeInteger(num) {
    var result = '';
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do {
        var clamped = num & 31;
        num >>= 5;
        if (num > 0) {
            clamped |= 32;
        }
        result += chars[clamped];
    } while (num > 0);
    return result;
}

var Chunk = function Chunk(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = '';
    this.outro = '';
    this.content = content;
    this.storeName = false;
    this.edited = false;
    // we make these non-enumerable, for sanity while debugging
    Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
    });
};
Chunk.prototype.appendLeft = function appendLeft(content) {
    this.outro += content;
};
Chunk.prototype.appendRight = function appendRight(content) {
    this.intro = this.intro + content;
};
Chunk.prototype.clone = function clone() {
    var chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
};
Chunk.prototype.contains = function contains(index) {
    return this.start < index && index < this.end;
};
Chunk.prototype.eachNext = function eachNext(fn) {
    var chunk = this;
    while (chunk) {
        fn(chunk);
        chunk = chunk.next;
    }
};
Chunk.prototype.eachPrevious = function eachPrevious(fn) {
    var chunk = this;
    while (chunk) {
        fn(chunk);
        chunk = chunk.previous;
    }
};
Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
        this.intro = '';
        this.outro = '';
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
};
Chunk.prototype.prependLeft = function prependLeft(content) {
    this.outro = content + this.outro;
};
Chunk.prototype.prependRight = function prependRight(content) {
    this.intro = content + this.intro;
};
Chunk.prototype.split = function split(index) {
    var sliceIndex = index - this.start;
    var originalBefore = this.original.slice(0, sliceIndex);
    var originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    var newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = '';
    this.end = index;
    if (this.edited) {
        // TODO is this block necessary?...
        newChunk.edit('', false);
        this.content = '';
    }
    else {
        this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) {
        newChunk.next.previous = newChunk;
    }
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
};
Chunk.prototype.toString = function toString() {
    return this.intro + this.content + this.outro;
};
Chunk.prototype.trimEnd = function trimEnd(rx) {
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) {
        return true;
    }
    var trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
        if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit('', undefined, true);
        }
        return true;
    }
    else {
        this.edit('', undefined, true);
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) {
            return true;
        }
    }
};
Chunk.prototype.trimStart = function trimStart(rx) {
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) {
        return true;
    }
    var trimmed = this.content.replace(rx, '');
    if (trimmed.length) {
        if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit('', undefined, true);
        }
        return true;
    }
    else {
        this.edit('', undefined, true);
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) {
            return true;
        }
    }
};
var btoa = function () {
    throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
    btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
}
else if (typeof Buffer === 'function') {
    btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}
var SourceMap = function SourceMap(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
};
SourceMap.prototype.toString = function toString() {
    return JSON.stringify(this);
};
SourceMap.prototype.toUrl = function toUrl() {
    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};
function guessIndent(code) {
    var lines = code.split('\n');
    var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
    var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    var min = spaced.reduce(function (previous, current) {
        var numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
    var fromParts = from.split(/[/\\]/);
    var toParts = to.split(/[/\\]/);
    fromParts.pop(); // get dirname
    while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
    }
    if (fromParts.length) {
        var i = fromParts.length;
        while (i--) {
            fromParts[i] = '..';
        }
    }
    return fromParts.concat(toParts).join('/');
}
var toString = Object.prototype.toString;
function isObject(thing) {
    return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
    var originalLines = source.split('\n');
    var lineOffsets = [];
    for (var i = 0, pos = 0; i < originalLines.length; i++) {
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
    }
    return function locate(index) {
        var i = 0;
        var j = lineOffsets.length;
        while (i < j) {
            var m = (i + j) >> 1;
            if (index < lineOffsets[m]) {
                j = m;
            }
            else {
                i = m + 1;
            }
        }
        var line = i - 1;
        var column = index - lineOffsets[line];
        return { line: line, column: column };
    };
}
var Mappings = function Mappings(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
};
Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
            segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
    }
    else if (this.pending) {
        this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
};
Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    var originalCharIndex = chunk.start;
    var first = true;
    while (originalCharIndex < chunk.end) {
        if (this.hires || first || sourcemapLocations[originalCharIndex]) {
            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === '\n') {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
        }
        else {
            loc.column += 1;
            this.generatedCodeColumn += 1;
        }
        originalCharIndex += 1;
        first = false;
    }
    this.pending = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
};
Mappings.prototype.advance = function advance(str) {
    if (!str) {
        return;
    }
    var lines = str.split('\n');
    if (lines.length > 1) {
        for (var i = 0; i < lines.length - 1; i++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
};
var n = '\n';
var warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
};
var MagicString = function MagicString(string, options) {
    if (options === void 0)
        options = {};
    var chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
        original: { writable: true, value: string },
        outro: { writable: true, value: '' },
        intro: { writable: true, value: '' },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options.filename },
        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: {} },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent(string) }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
};
MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
    this.sourcemapLocations[char] = true;
};
MagicString.prototype.append = function append(content) {
    if (typeof content !== 'string') {
        throw new TypeError('outro content must be a string');
    }
    this.outro += content;
    return this;
};
MagicString.prototype.appendLeft = function appendLeft(index, content) {
    if (typeof content !== 'string') {
        throw new TypeError('inserted content must be a string');
    }
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk) {
        chunk.appendLeft(content);
    }
    else {
        this.intro += content;
    }
    return this;
};
MagicString.prototype.appendRight = function appendRight(index, content) {
    if (typeof content !== 'string') {
        throw new TypeError('inserted content must be a string');
    }
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk) {
        chunk.appendRight(content);
    }
    else {
        this.outro += content;
    }
    return this;
};
MagicString.prototype.clone = function clone() {
    var cloned = new MagicString(this.original, { filename: this.filename });
    var originalChunk = this.firstChunk;
    var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());
    while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    Object.keys(this.sourcemapLocations).forEach(function (loc) {
        cloned.sourcemapLocations[loc] = true;
    });
    return cloned;
};
MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
    var this$1 = this;
    options = options || {};
    var sourceIndex = 0;
    var names = Object.keys(this.storedNames);
    var mappings = new Mappings(options.hires);
    var locate = getLocator(this.original);
    if (this.intro) {
        mappings.advance(this.intro);
    }
    this.firstChunk.eachNext(function (chunk) {
        var loc = locate(chunk.start);
        if (chunk.intro.length) {
            mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
        }
        else {
            mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
            mappings.advance(chunk.outro);
        }
    });
    return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
        sourcesContent: options.includeContent ? [this.original] : [null],
        names: names,
        mappings: mappings.raw
    };
};
MagicString.prototype.generateMap = function generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
};
MagicString.prototype.getIndentString = function getIndentString() {
    return this.indentStr === null ? '\t' : this.indentStr;
};
MagicString.prototype.indent = function indent(indentStr, options) {
    var pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
        options = indentStr;
        indentStr = undefined;
    }
    indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';
    if (indentStr === '') {
        return this;
    } // noop
    options = options || {};
    // Process exclusion ranges
    var isExcluded = {};
    if (options.exclude) {
        var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
        exclusions.forEach(function (exclusion) {
            for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
                isExcluded[i] = true;
            }
        });
    }
    var shouldIndentNextCharacter = options.indentStart !== false;
    var replacer = function (match) {
        if (shouldIndentNextCharacter) {
            return ("" + indentStr + match);
        }
        shouldIndentNextCharacter = true;
        return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    var charIndex = 0;
    var chunk = this.firstChunk;
    while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
            if (!isExcluded[charIndex]) {
                chunk.content = chunk.content.replace(pattern, replacer);
                if (chunk.content.length) {
                    shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
                }
            }
        }
        else {
            charIndex = chunk.start;
            while (charIndex < end) {
                if (!isExcluded[charIndex]) {
                    var char = this.original[charIndex];
                    if (char === '\n') {
                        shouldIndentNextCharacter = true;
                    }
                    else if (char !== '\r' && shouldIndentNextCharacter) {
                        shouldIndentNextCharacter = false;
                        if (charIndex === chunk.start) {
                            chunk.prependRight(indentStr);
                        }
                        else {
                            this._splitChunk(chunk, charIndex);
                            chunk = chunk.next;
                            chunk.prependRight(indentStr);
                        }
                    }
                }
                charIndex += 1;
            }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
};
MagicString.prototype.insert = function insert() {
    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};
MagicString.prototype.insertLeft = function insertLeft(index, content) {
    if (!warned.insertLeft) {
        console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
        warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
};
MagicString.prototype.insertRight = function insertRight(index, content) {
    if (!warned.insertRight) {
        console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
        warned.insertRight = true;
    }
    return this.prependRight(index, content);
};
MagicString.prototype.move = function move(start, end, index) {
    if (index >= start && index <= end) {
        throw new Error('Cannot move a selection inside itself');
    }
    this._split(start);
    this._split(end);
    this._split(index);
    var first = this.byStart[start];
    var last = this.byEnd[end];
    var oldLeft = first.previous;
    var oldRight = last.next;
    var newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) {
        return this;
    }
    var newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) {
        oldLeft.next = oldRight;
    }
    if (oldRight) {
        oldRight.previous = oldLeft;
    }
    if (newLeft) {
        newLeft.next = first;
    }
    if (newRight) {
        newRight.previous = last;
    }
    if (!first.previous) {
        this.firstChunk = last.next;
    }
    if (!last.next) {
        this.lastChunk = first.previous;
        this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) {
        this.firstChunk = first;
    }
    if (!newRight) {
        this.lastChunk = last;
    }
    return this;
};
MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
    if (typeof content !== 'string') {
        throw new TypeError('replacement content must be a string');
    }
    while (start < 0) {
        start += this.original.length;
    }
    while (end < 0) {
        end += this.original.length;
    }
    if (end > this.original.length) {
        throw new Error('end is out of bounds');
    }
    if (start === end) {
        throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
    }
    this._split(start);
    this._split(end);
    if (options === true) {
        if (!warned.storeName) {
            console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
            warned.storeName = true;
        }
        options = { storeName: true };
    }
    var storeName = options !== undefined ? options.storeName : false;
    var contentOnly = options !== undefined ? options.contentOnly : false;
    if (storeName) {
        var original = this.original.slice(start, end);
        this.storedNames[original] = true;
    }
    var first = this.byStart[start];
    var last = this.byEnd[end];
    if (first) {
        if (end > first.end && first.next !== this.byStart[first.end]) {
            throw new Error('Cannot overwrite across a split point');
        }
        first.edit(content, storeName, contentOnly);
        if (first !== last) {
            var chunk = first.next;
            while (chunk !== last) {
                chunk.edit('', false);
                chunk = chunk.next;
            }
            chunk.edit('', false);
        }
    }
    else {
        // must be inserting at the end
        var newChunk = new Chunk(start, end, '').edit(content, storeName);
        // TODO last chunk in the array may not be the last chunk, if it's moved...
        last.next = newChunk;
        newChunk.previous = last;
    }
    return this;
};
MagicString.prototype.prepend = function prepend(content) {
    if (typeof content !== 'string') {
        throw new TypeError('outro content must be a string');
    }
    this.intro = content + this.intro;
    return this;
};
MagicString.prototype.prependLeft = function prependLeft(index, content) {
    if (typeof content !== 'string') {
        throw new TypeError('inserted content must be a string');
    }
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk) {
        chunk.prependLeft(content);
    }
    else {
        this.intro = content + this.intro;
    }
    return this;
};
MagicString.prototype.prependRight = function prependRight(index, content) {
    if (typeof content !== 'string') {
        throw new TypeError('inserted content must be a string');
    }
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk) {
        chunk.prependRight(content);
    }
    else {
        this.outro = content + this.outro;
    }
    return this;
};
MagicString.prototype.remove = function remove(start, end) {
    while (start < 0) {
        start += this.original.length;
    }
    while (end < 0) {
        end += this.original.length;
    }
    if (start === end) {
        return this;
    }
    if (start < 0 || end > this.original.length) {
        throw new Error('Character is out of bounds');
    }
    if (start > end) {
        throw new Error('end must be greater than start');
    }
    this._split(start);
    this._split(end);
    var chunk = this.byStart[start];
    while (chunk) {
        chunk.intro = '';
        chunk.outro = '';
        chunk.edit('');
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
};
MagicString.prototype.lastChar = function lastChar() {
    if (this.outro.length) {
        return this.outro[this.outro.length - 1];
    }
    var chunk = this.lastChunk;
    do {
        if (chunk.outro.length) {
            return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
            return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
            return chunk.intro[chunk.intro.length - 1];
        }
    } while (chunk = chunk.previous);
    if (this.intro.length) {
        return this.intro[this.intro.length - 1];
    }
    return '';
};
MagicString.prototype.lastLine = function lastLine() {
    var lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
    }
    var lineStr = this.outro;
    var chunk = this.lastChunk;
    do {
        if (chunk.outro.length > 0) {
            lineIndex = chunk.outro.lastIndexOf(n);
            if (lineIndex !== -1) {
                return chunk.outro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
            lineIndex = chunk.content.lastIndexOf(n);
            if (lineIndex !== -1) {
                return chunk.content.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
            lineIndex = chunk.intro.lastIndexOf(n);
            if (lineIndex !== -1) {
                return chunk.intro.substr(lineIndex + 1) + lineStr;
            }
            lineStr = chunk.intro + lineStr;
        }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
    }
    return this.intro + lineStr;
};
MagicString.prototype.slice = function slice(start, end) {
    if (start === void 0)
        start = 0;
    if (end === void 0)
        end = this.original.length;
    while (start < 0) {
        start += this.original.length;
    }
    while (end < 0) {
        end += this.original.length;
    }
    var result = '';
    // find start chunk
    var chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
        // found end chunk before start
        if (chunk.start < end && chunk.end >= end) {
            return result;
        }
        chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error(("Cannot use replaced character " + start + " as slice start anchor."));
    }
    var startChunk = chunk;
    while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
            throw new Error(("Cannot use replaced character " + end + " as slice end anchor."));
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result += chunk.outro;
        }
        if (containsEnd) {
            break;
        }
        chunk = chunk.next;
    }
    return result;
};
// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip(start, end) {
    var clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
};
MagicString.prototype._split = function _split(index) {
    if (this.byStart[index] || this.byEnd[index]) {
        return;
    }
    var chunk = this.lastSearchedChunk;
    var searchForward = index > chunk.end;
    while (chunk) {
        if (chunk.contains(index)) {
            return this._splitChunk(chunk, index);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
};
MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
        // zero-length edited chunks are a special case (overlapping replacements)
        var loc = getLocator(this.original)(index);
        throw new Error(("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")"));
    }
    var newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
    }
    this.lastSearchedChunk = chunk;
    return true;
};
MagicString.prototype.toString = function toString() {
    var str = this.intro;
    var chunk = this.firstChunk;
    while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
    }
    return str + this.outro;
};
MagicString.prototype.isEmpty = function isEmpty() {
    var chunk = this.firstChunk;
    do {
        if (chunk.intro.length && chunk.intro.trim() ||
            chunk.content.length && chunk.content.trim() ||
            chunk.outro.length && chunk.outro.trim()) {
            return false;
        }
    } while (chunk = chunk.next);
    return true;
};
MagicString.prototype.length = function length() {
    var chunk = this.firstChunk;
    var length = 0;
    do {
        length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
};
MagicString.prototype.trimLines = function trimLines() {
    return this.trim('[\\r\\n]');
};
MagicString.prototype.trim = function trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
};
MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
    var rx = new RegExp((charType || '\\s') + '+$');
    this.outro = this.outro.replace(rx, '');
    if (this.outro.length) {
        return true;
    }
    var chunk = this.lastChunk;
    do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        // if chunk was trimmed, we have a new lastChunk
        if (chunk.end !== end) {
            if (this.lastChunk === chunk) {
                this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
            return true;
        }
        chunk = chunk.previous;
    } while (chunk);
    return false;
};
MagicString.prototype.trimEnd = function trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
    var rx = new RegExp('^' + (charType || '\\s') + '+');
    this.intro = this.intro.replace(rx, '');
    if (this.intro.length) {
        return true;
    }
    var chunk = this.firstChunk;
    do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
            // special case...
            if (chunk === this.lastChunk) {
                this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
            return true;
        }
        chunk = chunk.next;
    } while (chunk);
    return false;
};
MagicString.prototype.trimStart = function trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
};
var hasOwnProp = Object.prototype.hasOwnProperty;
var Bundle = function Bundle(options) {
    if (options === void 0)
        options = {};
    this.intro = options.intro || '';
    this.separator = options.separator !== undefined ? options.separator : '\n';
    this.sources = [];
    this.uniqueSources = [];
    this.uniqueSourceIndexByFilename = {};
};
Bundle.prototype.addSource = function addSource(source) {
    if (source instanceof MagicString) {
        return this.addSource({
            content: source,
            filename: source.filename,
            separator: this.separator
        });
    }
    if (!isObject(source) || !source.content) {
        throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
    }
    ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
        if (!hasOwnProp.call(source, option)) {
            source[option] = source.content[option];
        }
    });
    if (source.separator === undefined) {
        // TODO there's a bunch of this sort of thing, needs cleaning up
        source.separator = this.separator;
    }
    if (source.filename) {
        if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
            this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
            this.uniqueSources.push({ filename: source.filename, content: source.content.original });
        }
        else {
            var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
            if (source.content.original !== uniqueSource.content) {
                throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
            }
        }
    }
    this.sources.push(source);
    return this;
};
Bundle.prototype.append = function append(str, options) {
    this.addSource({
        content: new MagicString(str),
        separator: (options && options.separator) || ''
    });
    return this;
};
Bundle.prototype.clone = function clone() {
    var bundle = new Bundle({
        intro: this.intro,
        separator: this.separator
    });
    this.sources.forEach(function (source) {
        bundle.addSource({
            filename: source.filename,
            content: source.content.clone(),
            separator: source.separator
        });
    });
    return bundle;
};
Bundle.prototype.generateDecodedMap = function generateDecodedMap(options) {
    var this$1 = this;
    if (options === void 0)
        options = {};
    var names = [];
    this.sources.forEach(function (source) {
        Object.keys(source.content.storedNames).forEach(function (name) {
            if (!~names.indexOf(name)) {
                names.push(name);
            }
        });
    });
    var mappings = new Mappings(options.hires);
    if (this.intro) {
        mappings.advance(this.intro);
    }
    this.sources.forEach(function (source, i) {
        if (i > 0) {
            mappings.advance(this$1.separator);
        }
        var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;
        var magicString = source.content;
        var locate = getLocator(magicString.original);
        if (magicString.intro) {
            mappings.advance(magicString.intro);
        }
        magicString.firstChunk.eachNext(function (chunk) {
            var loc = locate(chunk.start);
            if (chunk.intro.length) {
                mappings.advance(chunk.intro);
            }
            if (source.filename) {
                if (chunk.edited) {
                    mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
                }
                else {
                    mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
                }
            }
            else {
                mappings.advance(chunk.content);
            }
            if (chunk.outro.length) {
                mappings.advance(chunk.outro);
            }
        });
        if (magicString.outro) {
            mappings.advance(magicString.outro);
        }
    });
    return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: this.uniqueSources.map(function (source) {
            return options.file ? getRelativePath(options.file, source.filename) : source.filename;
        }),
        sourcesContent: this.uniqueSources.map(function (source) {
            return options.includeContent ? source.content : null;
        }),
        names: names,
        mappings: mappings.raw
    };
};
Bundle.prototype.generateMap = function generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
};
Bundle.prototype.getIndentString = function getIndentString() {
    var indentStringCounts = {};
    this.sources.forEach(function (source) {
        var indentStr = source.content.indentStr;
        if (indentStr === null) {
            return;
        }
        if (!indentStringCounts[indentStr]) {
            indentStringCounts[indentStr] = 0;
        }
        indentStringCounts[indentStr] += 1;
    });
    return (Object.keys(indentStringCounts).sort(function (a, b) {
        return indentStringCounts[a] - indentStringCounts[b];
    })[0] || '\t');
};
Bundle.prototype.indent = function indent(indentStr) {
    var this$1 = this;
    if (!arguments.length) {
        indentStr = this.getIndentString();
    }
    if (indentStr === '') {
        return this;
    } // noop
    var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
    this.sources.forEach(function (source, i) {
        var separator = source.separator !== undefined ? source.separator : this$1.separator;
        var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));
        source.content.indent(indentStr, {
            exclude: source.indentExclusionRanges,
            indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
        });
        trailingNewline = source.content.lastChar() === '\n';
    });
    if (this.intro) {
        this.intro =
            indentStr +
                this.intro.replace(/^[^\n]/gm, function (match, index) {
                    return index > 0 ? indentStr + match : match;
                });
    }
    return this;
};
Bundle.prototype.prepend = function prepend(str) {
    this.intro = str + this.intro;
    return this;
};
Bundle.prototype.toString = function toString() {
    var this$1 = this;
    var body = this.sources
        .map(function (source, i) {
        var separator = source.separator !== undefined ? source.separator : this$1.separator;
        var str = (i > 0 ? separator : '') + source.content.toString();
        return str;
    })
        .join('');
    return this.intro + body;
};
Bundle.prototype.isEmpty = function isEmpty() {
    if (this.intro.length && this.intro.trim()) {
        return false;
    }
    if (this.sources.some(function (source) { return !source.content.isEmpty(); })) {
        return false;
    }
    return true;
};
Bundle.prototype.length = function length() {
    return this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);
};
Bundle.prototype.trimLines = function trimLines() {
    return this.trim('[\\r\\n]');
};
Bundle.prototype.trim = function trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
};
Bundle.prototype.trimStart = function trimStart(charType) {
    var rx = new RegExp('^' + (charType || '\\s') + '+');
    this.intro = this.intro.replace(rx, '');
    if (!this.intro) {
        var source;
        var i = 0;
        do {
            source = this.sources[i++];
            if (!source) {
                break;
            }
        } while (!source.content.trimStartAborted(charType));
    }
    return this;
};
Bundle.prototype.trimEnd = function trimEnd(charType) {
    var rx = new RegExp((charType || '\\s') + '+$');
    var source;
    var i = this.sources.length - 1;
    do {
        source = this.sources[i--];
        if (!source) {
            this.intro = this.intro.replace(rx, '');
            break;
        }
    } while (!source.content.trimEndAborted(charType));
    return this;
};

const BLANK = Object.create(null);

const BlockStatement = 'BlockStatement';
const CallExpression = 'CallExpression';
const ExportAllDeclaration = 'ExportAllDeclaration';
const ExpressionStatement = 'ExpressionStatement';
const FunctionExpression = 'FunctionExpression';
const Identifier = 'Identifier';
const ImportDefaultSpecifier = 'ImportDefaultSpecifier';
const ImportNamespaceSpecifier = 'ImportNamespaceSpecifier';
const Program = 'Program';
const Property = 'Property';
const ReturnStatement = 'ReturnStatement';
const VariableDeclaration = 'VariableDeclaration';

function treeshakeNode(node, code, start, end) {
    code.remove(start, end);
    if (node.annotations) {
        for (const annotation of node.annotations) {
            if (annotation.start < start) {
                code.remove(annotation.start, annotation.end);
            }
            else {
                return;
            }
        }
    }
}
function removeAnnotations(node, code) {
    if (!node.annotations && node.parent.type === ExpressionStatement) {
        node = node.parent;
    }
    if (node.annotations) {
        for (const annotation of node.annotations) {
            code.remove(annotation.start, annotation.end);
        }
    }
}

const NO_SEMICOLON = { isNoStatement: true };
function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
    let searchPos, charCodeAfterSlash;
    searchPos = code.indexOf(searchString, start);
    while (true) {
        start = code.indexOf('/', start);
        if (start === -1 || start > searchPos)
            return searchPos;
        charCodeAfterSlash = code.charCodeAt(++start);
        ++start;
        if (charCodeAfterSlash === 47 /*"/"*/) {
            start = code.indexOf('\n', start) + 1;
            if (start === 0)
                return -1;
            if (start > searchPos) {
                searchPos = code.indexOf(searchString, start);
            }
        }
        else if (charCodeAfterSlash === 42 /*"*"*/) {
            start = code.indexOf('*/', start) + 2;
            if (start > searchPos) {
                searchPos = code.indexOf(searchString, start);
            }
        }
    }
}
function findFirstLineBreakOutsideComment(code, start = 0) {
    let lineBreakPos, charCodeAfterSlash;
    lineBreakPos = code.indexOf('\n', start);
    while (true) {
        start = code.indexOf('/', start);
        if (start === -1 || start > lineBreakPos)
            return lineBreakPos;
        charCodeAfterSlash = code.charCodeAt(++start);
        if (charCodeAfterSlash === 47 /*"/"*/)
            return lineBreakPos;
        ++start;
        if (charCodeAfterSlash === 42 /*"*"*/) {
            start = code.indexOf('*/', start) + 2;
            if (start > lineBreakPos) {
                lineBreakPos = code.indexOf('\n', start);
            }
        }
    }
}
function renderStatementList(statements, code, start, end, options) {
    if (statements.length === 0)
        return;
    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
    let nextNode = statements[0];
    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
    if (nextNodeNeedsBoundaries) {
        nextNodeStart =
            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start)) + 1;
    }
    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
        currentNode = nextNode;
        currentNodeStart = nextNodeStart;
        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
        nextNode = statements[nextIndex];
        nextNodeNeedsBoundaries =
            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
            nextNodeStart =
                currentNode.end +
                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start)) +
                    1;
            if (currentNode.included) {
                currentNodeNeedsBoundaries
                    ? currentNode.render(code, options, {
                        end: nextNodeStart,
                        start: currentNodeStart
                    })
                    : currentNode.render(code, options);
            }
            else {
                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
            }
        }
        else {
            currentNode.render(code, options);
        }
    }
}
// This assumes that the first character is not part of the first node
function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
    const splitUpNodes = [];
    let node, nextNode, nextNodeStart, contentEnd, char;
    let separator = start - 1;
    for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {
        nextNode = nodes[nextIndex];
        if (node !== undefined) {
            separator =
                node.end +
                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
        }
        nextNodeStart = contentEnd =
            separator +
                2 +
                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start));
        while (((char = code.original.charCodeAt(nextNodeStart)),
            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
            nextNodeStart++;
        if (node !== undefined) {
            splitUpNodes.push({
                contentEnd,
                end: nextNodeStart,
                node,
                separator,
                start
            });
        }
        node = nextNode;
        start = nextNodeStart;
    }
    splitUpNodes.push({
        contentEnd: end,
        end,
        node: node,
        separator: null,
        start
    });
    return splitUpNodes;
}

const chars$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
const base = 64;
function toBase64(num) {
    let outStr = '';
    do {
        const curDigit = num % base;
        num = Math.floor(num / base);
        outStr = chars$1[curDigit] + outStr;
    } while (num !== 0);
    return outStr;
}

function getSafeName(baseName, usedNames) {
    let safeName = baseName;
    let count = 1;
    while (usedNames[safeName]) {
        safeName = `${baseName}$${toBase64(count++)}`;
    }
    usedNames[safeName] = true;
    return safeName;
}

class CallOptions {
    static create(callOptions) {
        return new this(callOptions);
    }
    constructor({ withNew = false, args = [], callIdentifier = undefined } = {}) {
        this.withNew = withNew;
        this.args = args;
        this.callIdentifier = callIdentifier;
    }
    equals(callOptions) {
        return callOptions && this.callIdentifier === callOptions.callIdentifier;
    }
}

const UNKNOWN_KEY = { UNKNOWN_KEY: true };
const EMPTY_PATH = [];
const UNKNOWN_PATH = [UNKNOWN_KEY];
function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
    return Object.create(inheritedDescriptions, memberDescriptions);
}
const UNKNOWN_VALUE = { UNKNOWN_VALUE: true };
const UNKNOWN_EXPRESSION = {
    deoptimizePath: () => { },
    getLiteralValueAtPath: () => UNKNOWN_VALUE,
    getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,
    hasEffectsWhenAccessedAtPath: path => path.length > 0,
    hasEffectsWhenAssignedAtPath: path => path.length > 0,
    hasEffectsWhenCalledAtPath: () => true,
    include: () => { },
    included: true,
    toString: () => '[[UNKNOWN]]'
};
const UNDEFINED_EXPRESSION = {
    deoptimizePath: () => { },
    getLiteralValueAtPath: () => undefined,
    getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,
    hasEffectsWhenAccessedAtPath: path => path.length > 0,
    hasEffectsWhenAssignedAtPath: path => path.length > 0,
    hasEffectsWhenCalledAtPath: () => true,
    include: () => { },
    included: true,
    toString: () => 'undefined'
};
const returnsUnknown = {
    value: {
        callsArgs: null,
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
    }
};
const mutatesSelfReturnsUnknown = {
    value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: null, mutatesSelf: true }
};
const callsArgReturnsUnknown = {
    value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: [0], mutatesSelf: false }
};
class UnknownArrayExpression {
    constructor() {
        this.included = false;
    }
    deoptimizePath() { }
    getLiteralValueAtPath() {
        return UNKNOWN_VALUE;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length === 1) {
            return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);
        }
        return UNKNOWN_EXPRESSION;
    }
    hasEffectsWhenAccessedAtPath(path) {
        return path.length > 1;
    }
    hasEffectsWhenAssignedAtPath(path) {
        return path.length > 1;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length === 1) {
            return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, options);
        }
        return true;
    }
    include() {
        this.included = true;
    }
    toString() {
        return '[[UNKNOWN ARRAY]]';
    }
}
const returnsArray = {
    value: {
        callsArgs: null,
        mutatesSelf: false,
        returns: UnknownArrayExpression,
        returnsPrimitive: null
    }
};
const mutatesSelfReturnsArray = {
    value: {
        callsArgs: null,
        mutatesSelf: true,
        returns: UnknownArrayExpression,
        returnsPrimitive: null
    }
};
const callsArgReturnsArray = {
    value: {
        callsArgs: [0],
        mutatesSelf: false,
        returns: UnknownArrayExpression,
        returnsPrimitive: null
    }
};
const callsArgMutatesSelfReturnsArray = {
    value: {
        callsArgs: [0],
        mutatesSelf: true,
        returns: UnknownArrayExpression,
        returnsPrimitive: null
    }
};
const UNKNOWN_LITERAL_BOOLEAN = {
    deoptimizePath: () => { },
    getLiteralValueAtPath: () => UNKNOWN_VALUE,
    getReturnExpressionWhenCalledAtPath: path => {
        if (path.length === 1) {
            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);
        }
        return UNKNOWN_EXPRESSION;
    },
    hasEffectsWhenAccessedAtPath: path => path.length > 1,
    hasEffectsWhenAssignedAtPath: path => path.length > 0,
    hasEffectsWhenCalledAtPath: path => {
        if (path.length === 1) {
            const subPath = path[0];
            return typeof subPath !== 'string' || !literalBooleanMembers[subPath];
        }
        return true;
    },
    include: () => { },
    included: true,
    toString: () => '[[UNKNOWN BOOLEAN]]'
};
const returnsBoolean = {
    value: {
        callsArgs: null,
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
    }
};
const callsArgReturnsBoolean = {
    value: {
        callsArgs: [0],
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
    }
};
const UNKNOWN_LITERAL_NUMBER = {
    deoptimizePath: () => { },
    getLiteralValueAtPath: () => UNKNOWN_VALUE,
    getReturnExpressionWhenCalledAtPath: path => {
        if (path.length === 1) {
            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);
        }
        return UNKNOWN_EXPRESSION;
    },
    hasEffectsWhenAccessedAtPath: path => path.length > 1,
    hasEffectsWhenAssignedAtPath: path => path.length > 0,
    hasEffectsWhenCalledAtPath: path => {
        if (path.length === 1) {
            const subPath = path[0];
            return typeof subPath !== 'string' || !literalNumberMembers[subPath];
        }
        return true;
    },
    include: () => { },
    included: true,
    toString: () => '[[UNKNOWN NUMBER]]'
};
const returnsNumber = {
    value: {
        callsArgs: null,
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
    }
};
const mutatesSelfReturnsNumber = {
    value: {
        callsArgs: null,
        mutatesSelf: true,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
    }
};
const callsArgReturnsNumber = {
    value: {
        callsArgs: [0],
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
    }
};
const UNKNOWN_LITERAL_STRING = {
    deoptimizePath: () => { },
    getLiteralValueAtPath: () => UNKNOWN_VALUE,
    getReturnExpressionWhenCalledAtPath: path => {
        if (path.length === 1) {
            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
        }
        return UNKNOWN_EXPRESSION;
    },
    hasEffectsWhenAccessedAtPath: path => path.length > 1,
    hasEffectsWhenAssignedAtPath: path => path.length > 0,
    hasEffectsWhenCalledAtPath: (path, callOptions, options) => {
        if (path.length === 1) {
            return hasMemberEffectWhenCalled(literalStringMembers, path[0], true, callOptions, options);
        }
        return true;
    },
    include: () => { },
    included: true,
    toString: () => '[[UNKNOWN STRING]]'
};
const returnsString = {
    value: {
        callsArgs: null,
        mutatesSelf: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_STRING
    }
};
class UnknownObjectExpression {
    constructor() {
        this.included = false;
    }
    deoptimizePath() { }
    getLiteralValueAtPath() {
        return UNKNOWN_VALUE;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length === 1) {
            return getMemberReturnExpressionWhenCalled(objectMembers, path[0]);
        }
        return UNKNOWN_EXPRESSION;
    }
    hasEffectsWhenAccessedAtPath(path) {
        return path.length > 1;
    }
    hasEffectsWhenAssignedAtPath(path) {
        return path.length > 1;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length === 1) {
            return hasMemberEffectWhenCalled(objectMembers, path[0], this.included, callOptions, options);
        }
        return true;
    }
    include() {
        this.included = true;
    }
    toString() {
        return '[[UNKNOWN OBJECT]]';
    }
}
const objectMembers = assembleMemberDescriptions({
    hasOwnProperty: returnsBoolean,
    isPrototypeOf: returnsBoolean,
    propertyIsEnumerable: returnsBoolean,
    toLocaleString: returnsString,
    toString: returnsString,
    valueOf: returnsUnknown
});
const arrayMembers = assembleMemberDescriptions({
    concat: returnsArray,
    copyWithin: mutatesSelfReturnsArray,
    every: callsArgReturnsBoolean,
    fill: mutatesSelfReturnsArray,
    filter: callsArgReturnsArray,
    find: callsArgReturnsUnknown,
    findIndex: callsArgReturnsNumber,
    forEach: callsArgReturnsUnknown,
    includes: returnsBoolean,
    indexOf: returnsNumber,
    join: returnsString,
    lastIndexOf: returnsNumber,
    map: callsArgReturnsArray,
    pop: mutatesSelfReturnsUnknown,
    push: mutatesSelfReturnsNumber,
    reduce: callsArgReturnsUnknown,
    reduceRight: callsArgReturnsUnknown,
    reverse: mutatesSelfReturnsArray,
    shift: mutatesSelfReturnsUnknown,
    slice: returnsArray,
    some: callsArgReturnsBoolean,
    sort: callsArgMutatesSelfReturnsArray,
    splice: mutatesSelfReturnsArray,
    unshift: mutatesSelfReturnsNumber
}, objectMembers);
const literalBooleanMembers = assembleMemberDescriptions({
    valueOf: returnsBoolean
}, objectMembers);
const literalNumberMembers = assembleMemberDescriptions({
    toExponential: returnsString,
    toFixed: returnsString,
    toLocaleString: returnsString,
    toPrecision: returnsString,
    valueOf: returnsNumber
}, objectMembers);
const literalStringMembers = assembleMemberDescriptions({
    charAt: returnsString,
    charCodeAt: returnsNumber,
    codePointAt: returnsNumber,
    concat: returnsString,
    endsWith: returnsBoolean,
    includes: returnsBoolean,
    indexOf: returnsNumber,
    lastIndexOf: returnsNumber,
    localeCompare: returnsNumber,
    match: returnsBoolean,
    normalize: returnsString,
    padEnd: returnsString,
    padStart: returnsString,
    repeat: returnsString,
    replace: {
        value: {
            callsArgs: [1],
            mutatesSelf: false,
            returns: null,
            returnsPrimitive: UNKNOWN_LITERAL_STRING
        }
    },
    search: returnsNumber,
    slice: returnsString,
    split: returnsArray,
    startsWith: returnsBoolean,
    substr: returnsString,
    substring: returnsString,
    toLocaleLowerCase: returnsString,
    toLocaleUpperCase: returnsString,
    toLowerCase: returnsString,
    toUpperCase: returnsString,
    trim: returnsString,
    valueOf: returnsString
}, objectMembers);
function getLiteralMembersForValue(value) {
    switch (typeof value) {
        case 'boolean':
            return literalBooleanMembers;
        case 'number':
            return literalNumberMembers;
        case 'string':
            return literalStringMembers;
        default:
            return Object.create(null);
    }
}
function hasMemberEffectWhenCalled(members, memberName, parentIncluded, callOptions, options) {
    if (typeof memberName !== 'string' || !members[memberName])
        return true;
    if (members[memberName].mutatesSelf && parentIncluded)
        return true;
    if (!members[memberName].callsArgs)
        return false;
    for (const argIndex of members[memberName].callsArgs) {
        if (callOptions.args[argIndex] &&
            callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, CallOptions.create({
                args: [],
                callIdentifier: {},
                withNew: false
            }), options.getHasEffectsWhenCalledOptions()))
            return true;
    }
    return false;
}
function getMemberReturnExpressionWhenCalled(members, memberName) {
    if (typeof memberName !== 'string' || !members[memberName])
        return UNKNOWN_EXPRESSION;
    return members[memberName].returnsPrimitive !== null
        ? members[memberName].returnsPrimitive
        : new members[memberName].returns();
}

class Variable {
    constructor(name) {
        this.exportName = null;
        this.included = false;
        this.isId = false;
        this.isReassigned = false;
        this.reexported = false;
        this.renderBaseName = null;
        this.renderName = null;
        this.safeExportName = null;
        this.name = name;
    }
    /**
     * Binds identifiers that reference this variable to this variable.
     * Necessary to be able to change variable names.
     */
    addReference(_identifier) { }
    deoptimizePath(_path) { }
    getBaseVariableName() {
        return this.renderBaseName || this.renderName || this.name;
    }
    getLiteralValueAtPath(_path, _recursionTracker, _origin) {
        return UNKNOWN_VALUE;
    }
    getName() {
        const name = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}.${name}` : name;
    }
    getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {
        return UNKNOWN_EXPRESSION;
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 0;
    }
    hasEffectsWhenAssignedAtPath(_path, _options) {
        return true;
    }
    hasEffectsWhenCalledAtPath(_path, _callOptions, _options) {
        return true;
    }
    /**
     * Marks this variable as being part of the bundle, which is usually the case when one of
     * its identifiers becomes part of the bundle. Returns true if it has not been included
     * previously.
     * Once a variable is included, it should take care all its declarations are included.
     */
    include() {
        this.included = true;
    }
    setRenderNames(baseName, name) {
        this.renderBaseName = baseName;
        this.renderName = name;
    }
    setSafeName(name) {
        this.renderName = name;
    }
    toString() {
        return this.name;
    }
}

class ExternalVariable extends Variable {
    constructor(module, name) {
        super(name);
        this.module = module;
        this.isNamespace = name === '*';
        this.referenced = false;
    }
    addReference(identifier) {
        this.referenced = true;
        if (this.name === 'default' || this.name === '*') {
            this.module.suggestName(identifier.name);
        }
    }
    include() {
        if (!this.included) {
            this.included = true;
            this.module.used = true;
        }
    }
}
ExternalVariable.prototype.isExternal = true;

const reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');
const builtins = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');
const blacklisted = Object.create(null);
reservedWords.concat(builtins).forEach(word => (blacklisted[word] = true));
const illegalCharacters = /[^$_a-zA-Z0-9]/g;
const startsWithDigit = (str) => /\d/.test(str[0]);
function isLegal(str) {
    if (startsWithDigit(str) || blacklisted[str]) {
        return false;
    }
    return !illegalCharacters.test(str);
}
function makeLegal(str) {
    str = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');
    if (startsWithDigit(str) || blacklisted[str])
        str = `_${str}`;
    return str;
}

const absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
const relativePath = /^\.?\.\//;
function isAbsolute(path) {
    return absolutePath.test(path);
}
function isRelative(path) {
    return relativePath.test(path);
}
function normalize(path) {
    if (path.indexOf('\\') == -1)
        return path;
    return path.replace(/\\/g, '/');
}

class ExternalModule {
    constructor(graph, id, moduleSideEffects) {
        this.exportsNames = false;
        this.exportsNamespace = false;
        this.isExternal = true;
        this.mostCommonSuggestion = 0;
        this.reexported = false;
        this.renderPath = undefined;
        this.renormalizeRenderPath = false;
        this.used = false;
        this.graph = graph;
        this.id = id;
        this.execIndex = Infinity;
        this.moduleSideEffects = moduleSideEffects;
        const parts = id.split(/[\\/]/);
        this.variableName = makeLegal(parts.pop());
        this.nameSuggestions = Object.create(null);
        this.declarations = Object.create(null);
        this.exportedVariables = new Map();
    }
    getVariableForExportName(name, _isExportAllSearch) {
        if (name !== 'default' && name !== '*')
            this.exportsNames = true;
        if (name === '*')
            this.exportsNamespace = true;
        let declaration = this.declarations[name];
        if (declaration)
            return declaration;
        this.declarations[name] = declaration = new ExternalVariable(this, name);
        this.exportedVariables.set(declaration, name);
        return declaration;
    }
    setRenderPath(options, inputBase) {
        this.renderPath = '';
        if (options.paths) {
            this.renderPath =
                typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];
        }
        if (!this.renderPath) {
            if (!isAbsolute(this.id)) {
                this.renderPath = this.id;
            }
            else {
                this.renderPath = normalize(relative(inputBase, this.id));
                this.renormalizeRenderPath = true;
            }
        }
        return this.renderPath;
    }
    suggestName(name) {
        if (!this.nameSuggestions[name])
            this.nameSuggestions[name] = 0;
        this.nameSuggestions[name] += 1;
        if (this.nameSuggestions[name] > this.mostCommonSuggestion) {
            this.mostCommonSuggestion = this.nameSuggestions[name];
            this.variableName = name;
        }
    }
    warnUnusedImports() {
        const unused = Object.keys(this.declarations).filter(name => {
            if (name === '*')
                return false;
            const declaration = this.declarations[name];
            return !declaration.included && !this.reexported && !declaration.referenced;
        });
        if (unused.length === 0)
            return;
        const names = unused.length === 1
            ? `'${unused[0]}' is`
            : `${unused
                .slice(0, -1)
                .map(name => `'${name}'`)
                .join(', ')} and '${unused.slice(-1)}' are`;
        this.graph.warn({
            code: 'UNUSED_EXTERNAL_IMPORT',
            message: `${names} imported from external module '${this.id}' but never used`,
            names: unused,
            source: this.id
        });
    }
}

function markModuleAndImpureDependenciesAsExecuted(baseModule) {
    baseModule.isExecuted = true;
    const modules = [baseModule];
    const visitedModules = {};
    for (const module of modules) {
        for (const dependency of module.dependencies) {
            if (!(dependency instanceof ExternalModule) &&
                !dependency.isExecuted &&
                dependency.moduleSideEffects &&
                !visitedModules[dependency.id]) {
                dependency.isExecuted = true;
                visitedModules[dependency.id] = true;
                modules.push(dependency);
            }
        }
    }
}

// To avoid infinite recursions
const MAX_PATH_DEPTH = 7;
class LocalVariable extends Variable {
    constructor(name, declarator, init, context) {
        super(name);
        this.additionalInitializers = null;
        this.expressionsToBeDeoptimized = [];
        this.declarations = declarator ? [declarator] : [];
        this.init = init;
        this.deoptimizationTracker = context.deoptimizationTracker;
        this.module = context.module;
    }
    addDeclaration(identifier, init) {
        this.declarations.push(identifier);
        if (this.additionalInitializers === null) {
            this.additionalInitializers = this.init === null ? [] : [this.init];
            this.init = UNKNOWN_EXPRESSION;
            this.isReassigned = true;
        }
        if (init !== null) {
            this.additionalInitializers.push(init);
        }
    }
    consolidateInitializers() {
        if (this.additionalInitializers !== null) {
            for (const initializer of this.additionalInitializers) {
                initializer.deoptimizePath(UNKNOWN_PATH);
            }
            this.additionalInitializers = null;
        }
    }
    deoptimizePath(path) {
        if (path.length > MAX_PATH_DEPTH)
            return;
        if (!(this.isReassigned || this.deoptimizationTracker.track(this, path))) {
            if (path.length === 0) {
                if (!this.isReassigned) {
                    this.isReassigned = true;
                    for (const expression of this.expressionsToBeDeoptimized) {
                        expression.deoptimizeCache();
                    }
                    if (this.init) {
                        this.init.deoptimizePath(UNKNOWN_PATH);
                    }
                }
            }
            else if (this.init) {
                this.init.deoptimizePath(path);
            }
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.isReassigned ||
            !this.init ||
            path.length > MAX_PATH_DEPTH ||
            recursionTracker.isTracked(this.init, path)) {
            return UNKNOWN_VALUE;
        }
        this.expressionsToBeDeoptimized.push(origin);
        return this.init.getLiteralValueAtPath(path, recursionTracker.track(this.init, path), origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (this.isReassigned ||
            !this.init ||
            path.length > MAX_PATH_DEPTH ||
            recursionTracker.isTracked(this.init, path)) {
            return UNKNOWN_EXPRESSION;
        }
        this.expressionsToBeDeoptimized.push(origin);
        return this.init.getReturnExpressionWhenCalledAtPath(path, recursionTracker.track(this.init, path), origin);
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (path.length === 0)
            return false;
        return (this.isReassigned ||
            path.length > MAX_PATH_DEPTH ||
            (this.init &&
                !options.hasNodeBeenAccessedAtPath(path, this.init) &&
                this.init.hasEffectsWhenAccessedAtPath(path, options.addAccessedNodeAtPath(path, this.init))));
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (this.included || path.length > MAX_PATH_DEPTH)
            return true;
        if (path.length === 0)
            return false;
        return (this.isReassigned ||
            (this.init &&
                !options.hasNodeBeenAssignedAtPath(path, this.init) &&
                this.init.hasEffectsWhenAssignedAtPath(path, options.addAssignedNodeAtPath(path, this.init))));
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length > MAX_PATH_DEPTH)
            return true;
        return (this.isReassigned ||
            (this.init &&
                !options.hasNodeBeenCalledAtPathWithOptions(path, this.init, callOptions) &&
                this.init.hasEffectsWhenCalledAtPath(path, callOptions, options.addCalledNodeAtPathWithOptions(path, this.init, callOptions))));
    }
    include() {
        if (!this.included) {
            this.included = true;
            if (!this.module.isExecuted) {
                markModuleAndImpureDependenciesAsExecuted(this.module);
            }
            for (const declaration of this.declarations) {
                // If node is a default export, it can save a tree-shaking run to include the full declaration now
                if (!declaration.included)
                    declaration.include(false);
                let node = declaration.parent;
                while (!node.included) {
                    // We do not want to properly include parents in case they are part of a dead branch
                    // in which case .include() might pull in more dead code
                    node.included = true;
                    if (node.type === Program)
                        break;
                    node = node.parent;
                }
            }
        }
    }
}
LocalVariable.prototype.isLocal = true;

class Scope {
    constructor() {
        this.children = [];
        this.variables = Object.create(null);
    }
    addDeclaration(identifier, context, init = null, _isHoisted) {
        const name = identifier.name;
        if (this.variables[name]) {
            this.variables[name].addDeclaration(identifier, init);
        }
        else {
            this.variables[name] = new LocalVariable(identifier.name, identifier, init || UNDEFINED_EXPRESSION, context);
        }
        return this.variables[name];
    }
    contains(name) {
        return name in this.variables;
    }
    findVariable(_name) {
        throw new Error('Internal Error: findVariable needs to be implemented by a subclass');
    }
}

class ChildScope extends Scope {
    constructor(parent) {
        super();
        this.accessedOutsideVariables = Object.create(null);
        this.parent = parent;
        parent.children.push(this);
    }
    addNamespaceMemberAccess(name, variable) {
        this.accessedOutsideVariables[name] = variable;
        if (this.parent instanceof ChildScope) {
            this.parent.addNamespaceMemberAccess(name, variable);
        }
    }
    addReturnExpression(expression) {
        this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);
    }
    contains(name) {
        return name in this.variables || this.parent.contains(name);
    }
    deconflict(forbiddenNames) {
        const usedNames = Object.assign(Object.create(null), forbiddenNames);
        for (const name of Object.keys(this.accessedOutsideVariables)) {
            const variable = this.accessedOutsideVariables[name];
            if (variable.included) {
                usedNames[variable.getBaseVariableName()] = true;
            }
        }
        for (const name of Object.keys(this.variables)) {
            const variable = this.variables[name];
            if (variable.included) {
                variable.setSafeName(getSafeName(name, usedNames));
            }
        }
        for (const scope of this.children) {
            scope.deconflict(forbiddenNames);
        }
    }
    findLexicalBoundary() {
        return this.parent instanceof ChildScope ? this.parent.findLexicalBoundary() : this;
    }
    findVariable(name) {
        const knownVariable = this.variables[name] || this.accessedOutsideVariables[name];
        if (knownVariable) {
            return knownVariable;
        }
        return (this.accessedOutsideVariables[name] = this.parent.findVariable(name));
    }
}

function getLocator$1(source, options) {
    if (options === void 0) {
        options = {};
    }
    var offsetLine = options.offsetLine || 0;
    var offsetColumn = options.offsetColumn || 0;
    var originalLines = source.split('\n');
    var start = 0;
    var lineRanges = originalLines.map(function (line, i) {
        var end = start + line.length + 1;
        var range = { start: start, end: end, line: i };
        start = end;
        return range;
    });
    var i = 0;
    function rangeContains(range, index) {
        return range.start <= index && index < range.end;
    }
    function getLocation(range, index) {
        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
    }
    function locate(search, startIndex) {
        if (typeof search === 'string') {
            search = source.indexOf(search, startIndex || 0);
        }
        var range = lineRanges[i];
        var d = search >= range.end ? 1 : -1;
        while (range) {
            if (rangeContains(range, search))
                return getLocation(range, search);
            i += d;
            range = lineRanges[i];
        }
    }
    return locate;
}
function locate(source, search, options) {
    if (typeof options === 'number') {
        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
    }
    return getLocator$1(source, options)(search, options && options.startIndex);
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Used for setting prototype methods that IE8 chokes on.
var DELETE = 'delete';
// Constants describing the size of trie nodes.
var SHIFT = 5; // Resulted in best performance after ______?
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
// A consistent shared value representing "not set" which equals nothing other
// than itself, and nothing that could be provided externally.
var NOT_SET = {};
// Boolean references, Rough equivalent of `bool &`.
function MakeRef() {
    return { value: false };
}
function SetRef(ref) {
    if (ref) {
        ref.value = true;
    }
}
// A function which returns a value representing an "owner" for transient writes
// to tries. The return value will only ever equal itself, and will not equal
// the return of any subsequent call of this function.
function OwnerID() { }
function ensureSize(iter) {
    if (iter.size === undefined) {
        iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
}
function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
        if ('' + uint32Index !== index || uint32Index === 4294967295) {
            return NaN;
        }
        index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
    return true;
}
function wholeSlice(begin, end, size) {
    return (((begin === 0 && !isNeg(begin)) ||
        (size !== undefined && begin <= -size)) &&
        (end === undefined || (size !== undefined && end >= size)));
}
function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
    // Sanitize indices using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    return index === undefined
        ? defaultIndex
        : isNeg(index)
            ? size === Infinity
                ? size
                : Math.max(0, size + index) | 0
            : size === undefined || size === index
                ? index
                : Math.min(size, index) | 0;
}
function isNeg(value) {
    // Account for -0 which is negative, but not less than 0.
    return value < 0 || (value === 0 && 1 / value === -Infinity);
}
// Note: value is unchanged to not break immutable-devtools.
var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';
function isCollection(maybeCollection) {
    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';
function isKeyed(maybeKeyed) {
    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';
function isIndexed(maybeIndexed) {
    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var Collection = function Collection(value) {
    return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = /*@__PURE__*/ (function (Collection) {
    function KeyedCollection(value) {
        return isKeyed(value) ? value : KeyedSeq(value);
    }
    if (Collection)
        KeyedCollection.__proto__ = Collection;
    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
    KeyedCollection.prototype.constructor = KeyedCollection;
    return KeyedCollection;
}(Collection));
var IndexedCollection = /*@__PURE__*/ (function (Collection) {
    function IndexedCollection(value) {
        return isIndexed(value) ? value : IndexedSeq(value);
    }
    if (Collection)
        IndexedCollection.__proto__ = Collection;
    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
    IndexedCollection.prototype.constructor = IndexedCollection;
    return IndexedCollection;
}(Collection));
var SetCollection = /*@__PURE__*/ (function (Collection) {
    function SetCollection(value) {
        return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
    }
    if (Collection)
        SetCollection.__proto__ = Collection;
    SetCollection.prototype = Object.create(Collection && Collection.prototype);
    SetCollection.prototype.constructor = SetCollection;
    return SetCollection;
}(Collection));
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';
function isSeq(maybeSeq) {
    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';
function isRecord(maybeRecord) {
    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
    return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';
function isOrdered(maybeOrdered) {
    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator(next) {
    this.next = next;
};
Iterator.prototype.toString = function toString() {
    return '[Iterator]';
};
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
    return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
};
function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult
        ? (iteratorResult.value = value)
        : (iteratorResult = {
            value: value,
            done: false,
        });
    return iteratorResult;
}
function iteratorDone() {
    return { value: undefined, done: true };
}
function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
}
function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
    var iteratorFn = iterable &&
        ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
            iterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
        return iteratorFn;
    }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
    if (Array.isArray(value) || typeof value === 'string') {
        return true;
    }
    return (value &&
        typeof value === 'object' &&
        Number.isInteger(value.length) &&
        value.length >= 0 &&
        (value.length === 0
            ? // Only {length: 0} is considered Array-like.
                Object.keys(value).length === 1
            : // An object is only Array-like if it has a property where the last value
                // in the array-like may be found (which could be undefined).
                value.hasOwnProperty(value.length - 1)));
}
var Seq = /*@__PURE__*/ (function (Collection$$1) {
    function Seq(value) {
        return value === null || value === undefined
            ? emptySequence()
            : isImmutable(value)
                ? value.toSeq()
                : seqFromValue(value);
    }
    if (Collection$$1)
        Seq.__proto__ = Collection$$1;
    Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
    Seq.prototype.constructor = Seq;
    Seq.prototype.toSeq = function toSeq() {
        return this;
    };
    Seq.prototype.toString = function toString() {
        return this.__toString('Seq {', '}');
    };
    Seq.prototype.cacheResult = function cacheResult() {
        if (!this._cache && this.__iterateUncached) {
            this._cache = this.entrySeq().toArray();
            this.size = this._cache.length;
        }
        return this;
    };
    // abstract __iterateUncached(fn, reverse)
    Seq.prototype.__iterate = function __iterate(fn, reverse) {
        var cache = this._cache;
        if (cache) {
            var size = cache.length;
            var i = 0;
            while (i !== size) {
                var entry = cache[reverse ? size - ++i : i++];
                if (fn(entry[1], entry[0], this) === false) {
                    break;
                }
            }
            return i;
        }
        return this.__iterateUncached(fn, reverse);
    };
    // abstract __iteratorUncached(type, reverse)
    Seq.prototype.__iterator = function __iterator(type, reverse) {
        var cache = this._cache;
        if (cache) {
            var size = cache.length;
            var i = 0;
            return new Iterator(function () {
                if (i === size) {
                    return iteratorDone();
                }
                var entry = cache[reverse ? size - ++i : i++];
                return iteratorValue(type, entry[0], entry[1]);
            });
        }
        return this.__iteratorUncached(type, reverse);
    };
    return Seq;
}(Collection));
var KeyedSeq = /*@__PURE__*/ (function (Seq) {
    function KeyedSeq(value) {
        return value === null || value === undefined
            ? emptySequence().toKeyedSeq()
            : isCollection(value)
                ? isKeyed(value)
                    ? value.toSeq()
                    : value.fromEntrySeq()
                : isRecord(value)
                    ? value.toSeq()
                    : keyedSeqFromValue(value);
    }
    if (Seq)
        KeyedSeq.__proto__ = Seq;
    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
    KeyedSeq.prototype.constructor = KeyedSeq;
    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
        return this;
    };
    return KeyedSeq;
}(Seq));
var IndexedSeq = /*@__PURE__*/ (function (Seq) {
    function IndexedSeq(value) {
        return value === null || value === undefined
            ? emptySequence()
            : isCollection(value)
                ? isKeyed(value)
                    ? value.entrySeq()
                    : value.toIndexedSeq()
                : isRecord(value)
                    ? value.toSeq().entrySeq()
                    : indexedSeqFromValue(value);
    }
    if (Seq)
        IndexedSeq.__proto__ = Seq;
    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
    IndexedSeq.prototype.constructor = IndexedSeq;
    IndexedSeq.of = function of( /*...values*/) {
        return IndexedSeq(arguments);
    };
    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
        return this;
    };
    IndexedSeq.prototype.toString = function toString() {
        return this.__toString('Seq [', ']');
    };
    return IndexedSeq;
}(Seq));
var SetSeq = /*@__PURE__*/ (function (Seq) {
    function SetSeq(value) {
        return (isCollection(value) && !isAssociative(value)
            ? value
            : IndexedSeq(value)).toSetSeq();
    }
    if (Seq)
        SetSeq.__proto__ = Seq;
    SetSeq.prototype = Object.create(Seq && Seq.prototype);
    SetSeq.prototype.constructor = SetSeq;
    SetSeq.of = function of( /*...values*/) {
        return SetSeq(arguments);
    };
    SetSeq.prototype.toSetSeq = function toSetSeq() {
        return this;
    };
    return SetSeq;
}(Seq));
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
// #pragma Root Sequences
var ArraySeq = /*@__PURE__*/ (function (IndexedSeq) {
    function ArraySeq(array) {
        this._array = array;
        this.size = array.length;
    }
    if (IndexedSeq)
        ArraySeq.__proto__ = IndexedSeq;
    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
    ArraySeq.prototype.constructor = ArraySeq;
    ArraySeq.prototype.get = function get(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };
    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        while (i !== size) {
            var ii = reverse ? size - ++i : i++;
            if (fn(array[ii], ii, this) === false) {
                break;
            }
        }
        return i;
    };
    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        return new Iterator(function () {
            if (i === size) {
                return iteratorDone();
            }
            var ii = reverse ? size - ++i : i++;
            return iteratorValue(type, ii, array[ii]);
        });
    };
    return ArraySeq;
}(IndexedSeq));
var ObjectSeq = /*@__PURE__*/ (function (KeyedSeq) {
    function ObjectSeq(object) {
        var keys = Object.keys(object);
        this._object = object;
        this._keys = keys;
        this.size = keys.length;
    }
    if (KeyedSeq)
        ObjectSeq.__proto__ = KeyedSeq;
    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
    ObjectSeq.prototype.constructor = ObjectSeq;
    ObjectSeq.prototype.get = function get(key, notSetValue) {
        if (notSetValue !== undefined && !this.has(key)) {
            return notSetValue;
        }
        return this._object[key];
    };
    ObjectSeq.prototype.has = function has(key) {
        return hasOwnProperty.call(this._object, key);
    };
    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
        var object = this._object;
        var keys = this._keys;
        var size = keys.length;
        var i = 0;
        while (i !== size) {
            var key = keys[reverse ? size - ++i : i++];
            if (fn(object[key], key, this) === false) {
                break;
            }
        }
        return i;
    };
    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
        var object = this._object;
        var keys = this._keys;
        var size = keys.length;
        var i = 0;
        return new Iterator(function () {
            if (i === size) {
                return iteratorDone();
            }
            var key = keys[reverse ? size - ++i : i++];
            return iteratorValue(type, key, object[key]);
        });
    };
    return ObjectSeq;
}(KeyedSeq));
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = /*@__PURE__*/ (function (IndexedSeq) {
    function CollectionSeq(collection) {
        this._collection = collection;
        this.size = collection.length || collection.size;
    }
    if (IndexedSeq)
        CollectionSeq.__proto__ = IndexedSeq;
    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
    CollectionSeq.prototype.constructor = CollectionSeq;
    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
        if (reverse) {
            return this.cacheResult().__iterate(fn, reverse);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        var iterations = 0;
        if (isIterator(iterator)) {
            var step;
            while (!(step = iterator.next()).done) {
                if (fn(step.value, iterations++, this) === false) {
                    break;
                }
            }
        }
        return iterations;
    };
    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
        if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        if (!isIterator(iterator)) {
            return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function () {
            var step = iterator.next();
            return step.done ? step : iteratorValue(type, iterations++, step.value);
        });
    };
    return CollectionSeq;
}(IndexedSeq));
// # pragma Helper functions
var EMPTY_SEQ;
function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
    var seq = Array.isArray(value)
        ? new ArraySeq(value)
        : hasIterator(value)
            ? new CollectionSeq(value)
            : undefined;
    if (seq) {
        return seq.fromEntrySeq();
    }
    if (typeof value === 'object') {
        return new ObjectSeq(value);
    }
    throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' +
        value);
}
function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
        return seq;
    }
    throw new TypeError('Expected Array or collection object of values: ' + value);
}
function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
        return seq;
    }
    if (typeof value === 'object') {
        return new ObjectSeq(value);
    }
    throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
}
function maybeIndexedSeqFromValue(value) {
    return isArrayLike(value)
        ? new ArraySeq(value)
        : hasIterator(value)
            ? new CollectionSeq(value)
            : undefined;
}
var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';
function isMap(maybeMap) {
    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
    return Boolean(maybeValue &&
        typeof maybeValue.equals === 'function' &&
        typeof maybeValue.hashCode === 'function');
}
/**
 * An extension of the "same-value" algorithm as [described for use by ES6 Map
 * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
 *
 * NaN is considered the same as NaN, however -0 and 0 are considered the same
 * value, which is different from the algorithm described by
 * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
 *
 * This is extended further to allow Objects to describe the values they
 * represent, by way of `valueOf` or `equals` (and `hashCode`).
 *
 * Note: because of this extension, the key equality of Immutable.Map and the
 * value equality of Immutable.Set will differ from ES6 Map and Set.
 *
 * ### Defining custom values
 *
 * The easiest way to describe the value an object represents is by implementing
 * `valueOf`. For example, `Date` represents a value by returning a unix
 * timestamp for `valueOf`:
 *
 *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
 *     var date2 = new Date(1234567890000);
 *     date1.valueOf(); // 1234567890000
 *     assert( date1 !== date2 );
 *     assert( Immutable.is( date1, date2 ) );
 *
 * Note: overriding `valueOf` may have other implications if you use this object
 * where JavaScript expects a primitive, such as implicit string coercion.
 *
 * For more complex types, especially collections, implementing `valueOf` may
 * not be performant. An alternative is to implement `equals` and `hashCode`.
 *
 * `equals` takes another object, presumably of similar type, and returns true
 * if it is equal. Equality is symmetrical, so the same result should be
 * returned if this and the argument are flipped.
 *
 *     assert( a.equals(b) === b.equals(a) );
 *
 * `hashCode` returns a 32bit integer number representing the object which will
 * be used to determine how to store the value object in a Map or Set. You must
 * provide both or neither methods, one must not exist without the other.
 *
 * Also, an important relationship between these methods must be upheld: if two
 * values are equal, they *must* return the same hashCode. If the values are not
 * equal, they might have the same hashCode; this is called a hash collision,
 * and while undesirable for performance reasons, it is acceptable.
 *
 *     if (a.equals(b)) {
 *       assert( a.hashCode() === b.hashCode() );
 *     }
 *
 * All Immutable collections are Value Objects: they implement `equals()`
 * and `hashCode()`.
 */
function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
    }
    if (!valueA || !valueB) {
        return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
            return true;
        }
        if (!valueA || !valueB) {
            return false;
        }
    }
    return !!(isValueObject(valueA) &&
        isValueObject(valueB) &&
        valueA.equals(valueB));
}
var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2
    ? Math.imul
    : function imul(a, b) {
        a |= 0; // int
        b |= 0; // int
        var c = a & 0xffff;
        var d = b & 0xffff;
        // Shift by 0 fixes the sign on the high part.
        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int
    };
// v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit.
function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
    switch (typeof o) {
        case 'boolean':
            // The hash values for built-in constants are a 1 value for each 5-byte
            // shift region expect for the first, which encodes the value. This
            // reduces the odds of a hash collision for these common values.
            return o ? 0x42108421 : 0x42108420;
        case 'number':
            return hashNumber(o);
        case 'string':
            return o.length > STRING_HASH_CACHE_MIN_STRLEN
                ? cachedHashString(o)
                : hashString(o);
        case 'object':
        case 'function':
            if (o === null) {
                return 0x42108422;
            }
            if (typeof o.hashCode === 'function') {
                // Drop any high bits from accidentally long hash codes.
                return smi(o.hashCode(o));
            }
            if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {
                o = o.valueOf(o);
            }
            return hashJSObj(o);
        case 'undefined':
            return 0x42108423;
        default:
            if (typeof o.toString === 'function') {
                return hashString(o.toString());
            }
            throw new Error('Value type ' + typeof o + ' cannot be hashed.');
    }
}
// Compress arbitrarily large numbers into smi hashes.
function hashNumber(n) {
    if (n !== n || n === Infinity) {
        return 0;
    }
    var hash = n | 0;
    if (hash !== n) {
        hash ^= n * 0xffffffff;
    }
    while (n > 0xffffffff) {
        n /= 0xffffffff;
        hash ^= n;
    }
    return smi(hash);
}
function cachedHashString(string) {
    var hashed = stringHashCache[string];
    if (hashed === undefined) {
        hashed = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
            STRING_HASH_CACHE_SIZE = 0;
            stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hashed;
    }
    return hashed;
}
// http://jsperf.com/hashing-strings
function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hashed = 0;
    for (var ii = 0; ii < string.length; ii++) {
        hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
    }
    return smi(hashed);
}
function hashJSObj(obj) {
    var hashed;
    if (usingWeakMap) {
        hashed = weakMap.get(obj);
        if (hashed !== undefined) {
            return hashed;
        }
    }
    hashed = obj[UID_HASH_KEY];
    if (hashed !== undefined) {
        return hashed;
    }
    if (!canDefineProperty) {
        hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hashed !== undefined) {
            return hashed;
        }
        hashed = getIENodeHash(obj);
        if (hashed !== undefined) {
            return hashed;
        }
    }
    hashed = ++objHashUID;
    if (objHashUID & 0x40000000) {
        objHashUID = 0;
    }
    if (usingWeakMap) {
        weakMap.set(obj, hashed);
    }
    else if (isExtensible !== undefined && isExtensible(obj) === false) {
        throw new Error('Non-extensible objects are not allowed as keys.');
    }
    else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: hashed,
        });
    }
    else if (obj.propertyIsEnumerable !== undefined &&
        obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        // Since we can't define a non-enumerable property on the object
        // we'll hijack one of the less-used non-enumerable properties to
        // save our hash on it. Since this is a function it will not show up in
        // `JSON.stringify` which is what we want.
        obj.propertyIsEnumerable = function () {
            return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
    }
    else if (obj.nodeType !== undefined) {
        // At this point we couldn't get the IE `uniqueID` to use as a hash
        // and we couldn't use a non-enumerable property to exploit the
        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
        // itself.
        obj[UID_HASH_KEY] = hashed;
    }
    else {
        throw new Error('Unable to set a non-enumerable property on object.');
    }
    return hashed;
}
// Get references to ES5 object methods.
var isExtensible = Object.isExtensible;
// True if Object.defineProperty works as expected. IE8 fails this test.
var canDefineProperty = (function () {
    try {
        Object.defineProperty({}, '@', {});
        return true;
    }
    catch (e) {
        return false;
    }
})();
// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
// and avoid memory leaks from the IE cloneNode bug.
function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
        switch (node.nodeType) {
            case 1: // Element
                return node.uniqueID;
            case 9: // Document
                return node.documentElement && node.documentElement.uniqueID;
        }
    }
}
// If possible, use a WeakMap.
var usingWeakMap = typeof WeakMap === 'function';
var weakMap;
if (usingWeakMap) {
    weakMap = new WeakMap();
}
var objHashUID = 0;
var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = /*@__PURE__*/ (function (KeyedSeq$$1) {
    function ToKeyedSequence(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
    }
    if (KeyedSeq$$1)
        ToKeyedSequence.__proto__ = KeyedSeq$$1;
    ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
    ToKeyedSequence.prototype.constructor = ToKeyedSequence;
    ToKeyedSequence.prototype.get = function get(key, notSetValue) {
        return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence.prototype.has = function has(key) {
        return this._iter.has(key);
    };
    ToKeyedSequence.prototype.valueSeq = function valueSeq() {
        return this._iter.valueSeq();
    };
    ToKeyedSequence.prototype.reverse = function reverse() {
        var this$1 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
            reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };
        }
        return reversedSequence;
    };
    ToKeyedSequence.prototype.map = function map(mapper, context) {
        var this$1 = this;
        var mappedSequence = mapFactory(this, mapper, context);
        if (!this._useKeys) {
            mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };
        }
        return mappedSequence;
    };
    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
    };
    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
        return this._iter.__iterator(type, reverse);
    };
    return ToKeyedSequence;
}(KeyedSeq));
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = /*@__PURE__*/ (function (IndexedSeq$$1) {
    function ToIndexedSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
    }
    if (IndexedSeq$$1)
        ToIndexedSequence.__proto__ = IndexedSeq$$1;
    ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
    ToIndexedSequence.prototype.constructor = ToIndexedSequence;
    ToIndexedSequence.prototype.includes = function includes(value) {
        return this._iter.includes(value);
    };
    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        var i = 0;
        reverse && ensureSize(this);
        return this._iter.__iterate(function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); }, reverse);
    };
    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
        var this$1 = this;
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        var i = 0;
        reverse && ensureSize(this);
        return new Iterator(function () {
            var step = iterator.next();
            return step.done
                ? step
                : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);
        });
    };
    return ToIndexedSequence;
}(IndexedSeq));
var ToSetSequence = /*@__PURE__*/ (function (SetSeq$$1) {
    function ToSetSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
    }
    if (SetSeq$$1)
        ToSetSequence.__proto__ = SetSeq$$1;
    ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);
    ToSetSequence.prototype.constructor = ToSetSequence;
    ToSetSequence.prototype.has = function has(key) {
        return this._iter.includes(key);
    };
    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);
    };
    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        return new Iterator(function () {
            var step = iterator.next();
            return step.done
                ? step
                : iteratorValue(type, step.value, step.value, step);
        });
    };
    return ToSetSequence;
}(SetSeq));
var FromEntriesSequence = /*@__PURE__*/ (function (KeyedSeq$$1) {
    function FromEntriesSequence(entries) {
        this._iter = entries;
        this.size = entries.size;
    }
    if (KeyedSeq$$1)
        FromEntriesSequence.__proto__ = KeyedSeq$$1;
    FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
    FromEntriesSequence.prototype.constructor = FromEntriesSequence;
    FromEntriesSequence.prototype.entrySeq = function entrySeq() {
        return this._iter.toSeq();
    };
    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        return this._iter.__iterate(function (entry) {
            // Check if entry exists first so array access doesn't throw for holes
            // in the parent iteration.
            if (entry) {
                validateEntry(entry);
                var indexedCollection = isCollection(entry);
                return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);
            }
        }, reverse);
    };
    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        return new Iterator(function () {
            while (true) {
                var step = iterator.next();
                if (step.done) {
                    return step;
                }
                var entry = step.value;
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                    validateEntry(entry);
                    var indexedCollection = isCollection(entry);
                    return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
                }
            }
        });
    };
    return FromEntriesSequence;
}(KeyedSeq));
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
    var flipSequence = makeSequence(collection);
    flipSequence._iter = collection;
    flipSequence.size = collection.size;
    flipSequence.flip = function () { return collection; };
    flipSequence.reverse = function () {
        var reversedSequence = collection.reverse.apply(this); // super.reverse()
        reversedSequence.flip = function () { return collection.reverse(); };
        return reversedSequence;
    };
    flipSequence.has = function (key) { return collection.includes(key); };
    flipSequence.includes = function (key) { return collection.has(key); };
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);
    };
    flipSequence.__iteratorUncached = function (type, reverse) {
        if (type === ITERATE_ENTRIES) {
            var iterator = collection.__iterator(type, reverse);
            return new Iterator(function () {
                var step = iterator.next();
                if (!step.done) {
                    var k = step.value[0];
                    step.value[0] = step.value[1];
                    step.value[1] = k;
                }
                return step;
            });
        }
        return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
    };
    return flipSequence;
}
function mapFactory(collection, mapper, context) {
    var mappedSequence = makeSequence(collection);
    mappedSequence.size = collection.size;
    mappedSequence.has = function (key) { return collection.has(key); };
    mappedSequence.get = function (key, notSetValue) {
        var v = collection.get(key, NOT_SET);
        return v === NOT_SET
            ? notSetValue
            : mapper.call(context, v, key, collection);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        return collection.__iterate(function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; }, reverse);
    };
    mappedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
        return new Iterator(function () {
            var step = iterator.next();
            if (step.done) {
                return step;
            }
            var entry = step.value;
            var key = entry[0];
            return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
        });
    };
    return mappedSequence;
}
function reverseFactory(collection, useKeys) {
    var this$1 = this;
    var reversedSequence = makeSequence(collection);
    reversedSequence._iter = collection;
    reversedSequence.size = collection.size;
    reversedSequence.reverse = function () { return collection; };
    if (collection.flip) {
        reversedSequence.flip = function () {
            var flipSequence = flipFactory(collection);
            flipSequence.reverse = function () { return collection.flip(); };
            return flipSequence;
        };
    }
    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
    reversedSequence.includes = function (value) { return collection.includes(value); };
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {
        var this$1 = this;
        var i = 0;
        reverse && ensureSize(collection);
        return collection.__iterate(function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); }, !reverse);
    };
    reversedSequence.__iterator = function (type, reverse) {
        var i = 0;
        reverse && ensureSize(collection);
        var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
        return new Iterator(function () {
            var step = iterator.next();
            if (step.done) {
                return step;
            }
            var entry = step.value;
            return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);
        });
    };
    return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
    var filterSequence = makeSequence(collection);
    if (useKeys) {
        filterSequence.has = function (key) {
            var v = collection.get(key, NOT_SET);
            return v !== NOT_SET && !!predicate.call(context, v, key, collection);
        };
        filterSequence.get = function (key, notSetValue) {
            var v = collection.get(key, NOT_SET);
            return v !== NOT_SET && predicate.call(context, v, key, collection)
                ? v
                : notSetValue;
        };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        var iterations = 0;
        collection.__iterate(function (v, k, c) {
            if (predicate.call(context, v, k, c)) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1);
            }
        }, reverse);
        return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new Iterator(function () {
            while (true) {
                var step = iterator.next();
                if (step.done) {
                    return step;
                }
                var entry = step.value;
                var key = entry[0];
                var value = entry[1];
                if (predicate.call(context, value, key, collection)) {
                    return iteratorValue(type, useKeys ? key : iterations++, value, step);
                }
            }
        });
    };
    return filterSequence;
}
function countByFactory(collection, grouper, context) {
    var groups = Map$1().asMutable();
    collection.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
    });
    return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
    var isKeyedIter = isKeyed(collection);
    var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
    collection.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, collection), function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); });
    });
    var coerce = collectionClass(collection);
    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();
}
function sliceFactory(collection, begin, end, useKeys) {
    var originalSize = collection.size;
    if (wholeSlice(begin, end, originalSize)) {
        return collection;
    }
    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);
    // begin or end will be NaN if they were provided as negative numbers and
    // this collection's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
    }
    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }
    var sliceSeq = makeSequence(collection);
    // If collection.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size =
        sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;
    if (!useKeys && isSeq(collection) && sliceSize >= 0) {
        sliceSeq.get = function (index, notSetValue) {
            index = wrapIndex(this, index);
            return index >= 0 && index < sliceSize
                ? collection.get(index + resolvedBegin, notSetValue)
                : notSetValue;
        };
    }
    sliceSeq.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        if (sliceSize === 0) {
            return 0;
        }
        if (reverse) {
            return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        collection.__iterate(function (v, k) {
            if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                iterations++;
                return (fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
                    iterations !== sliceSize);
            }
        });
        return iterations;
    };
    sliceSeq.__iteratorUncached = function (type, reverse) {
        if (sliceSize !== 0 && reverse) {
            return this.cacheResult().__iterator(type, reverse);
        }
        // Don't bother instantiating parent iterator if taking 0.
        if (sliceSize === 0) {
            return new Iterator(iteratorDone);
        }
        var iterator = collection.__iterator(type, reverse);
        var skipped = 0;
        var iterations = 0;
        return new Iterator(function () {
            while (skipped++ < resolvedBegin) {
                iterator.next();
            }
            if (++iterations > sliceSize) {
                return iteratorDone();
            }
            var step = iterator.next();
            if (useKeys || type === ITERATE_VALUES || step.done) {
                return step;
            }
            if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations - 1, undefined, step);
            }
            return iteratorValue(type, iterations - 1, step.value[1], step);
        });
    };
    return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
    var takeSequence = makeSequence(collection);
    takeSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        if (reverse) {
            return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        collection.__iterate(function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); });
        return iterations;
    };
    takeSequence.__iteratorUncached = function (type, reverse) {
        var this$1 = this;
        if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new Iterator(function () {
            if (!iterating) {
                return iteratorDone();
            }
            var step = iterator.next();
            if (step.done) {
                return step;
            }
            var entry = step.value;
            var k = entry[0];
            var v = entry[1];
            if (!predicate.call(context, v, k, this$1)) {
                iterating = false;
                return iteratorDone();
            }
            return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
    };
    return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
    var skipSequence = makeSequence(collection);
    skipSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        if (reverse) {
            return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        collection.__iterate(function (v, k, c) {
            if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                iterations++;
                return fn(v, useKeys ? k : iterations - 1, this$1);
            }
        });
        return iterations;
    };
    skipSequence.__iteratorUncached = function (type, reverse) {
        var this$1 = this;
        if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new Iterator(function () {
            var step;
            var k;
            var v;
            do {
                step = iterator.next();
                if (step.done) {
                    if (useKeys || type === ITERATE_VALUES) {
                        return step;
                    }
                    if (type === ITERATE_KEYS) {
                        return iteratorValue(type, iterations++, undefined, step);
                    }
                    return iteratorValue(type, iterations++, step.value[1], step);
                }
                var entry = step.value;
                k = entry[0];
                v = entry[1];
                skipping && (skipping = predicate.call(context, v, k, this$1));
            } while (skipping);
            return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
    };
    return skipSequence;
}
function concatFactory(collection, values) {
    var isKeyedCollection = isKeyed(collection);
    var iters = [collection]
        .concat(values)
        .map(function (v) {
        if (!isCollection(v)) {
            v = isKeyedCollection
                ? keyedSeqFromValue(v)
                : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        }
        else if (isKeyedCollection) {
            v = KeyedCollection(v);
        }
        return v;
    })
        .filter(function (v) { return v.size !== 0; });
    if (iters.length === 0) {
        return collection;
    }
    if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === collection ||
            (isKeyedCollection && isKeyed(singleton)) ||
            (isIndexed(collection) && isIndexed(singleton))) {
            return singleton;
        }
    }
    var concatSeq = new ArraySeq(iters);
    if (isKeyedCollection) {
        concatSeq = concatSeq.toKeyedSeq();
    }
    else if (!isIndexed(collection)) {
        concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(function (sum, seq) {
        if (sum !== undefined) {
            var size = seq.size;
            if (size !== undefined) {
                return sum + size;
            }
        }
    }, 0);
    return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
    var flatSequence = makeSequence(collection);
    flatSequence.__iterateUncached = function (fn, reverse) {
        if (reverse) {
            return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
            iter.__iterate(function (v, k) {
                if ((!depth || currentDepth < depth) && isCollection(v)) {
                    flatDeep(v, currentDepth + 1);
                }
                else {
                    iterations++;
                    if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
                        stopped = true;
                    }
                }
                return !stopped;
            }, reverse);
        }
        flatDeep(collection, 0);
        return iterations;
    };
    flatSequence.__iteratorUncached = function (type, reverse) {
        if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = collection.__iterator(type, reverse);
        var stack = [];
        var iterations = 0;
        return new Iterator(function () {
            while (iterator) {
                var step = iterator.next();
                if (step.done !== false) {
                    iterator = stack.pop();
                    continue;
                }
                var v = step.value;
                if (type === ITERATE_ENTRIES) {
                    v = v[1];
                }
                if ((!depth || stack.length < depth) && isCollection(v)) {
                    stack.push(iterator);
                    iterator = v.__iterator(type, reverse);
                }
                else {
                    return useKeys ? step : iteratorValue(type, iterations++, v, step);
                }
            }
            return iteratorDone();
        });
    };
    return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
    var coerce = collectionClass(collection);
    return collection
        .toSeq()
        .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
        .flatten(true);
}
function interposeFactory(collection, separator) {
    var interposedSequence = makeSequence(collection);
    interposedSequence.size = collection.size && collection.size * 2 - 1;
    interposedSequence.__iterateUncached = function (fn, reverse) {
        var this$1 = this;
        var iterations = 0;
        collection.__iterate(function (v) {
            return (!iterations || fn(separator, iterations++, this$1) !== false) &&
                fn(v, iterations++, this$1) !== false;
        }, reverse);
        return iterations;
    };
    interposedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = collection.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new Iterator(function () {
            if (!step || iterations % 2) {
                step = iterator.next();
                if (step.done) {
                    return step;
                }
            }
            return iterations % 2
                ? iteratorValue(type, iterations++, separator)
                : iteratorValue(type, iterations++, step.value, step);
        });
    };
    return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
    if (!comparator) {
        comparator = defaultComparator;
    }
    var isKeyedCollection = isKeyed(collection);
    var index = 0;
    var entries = collection
        .toSeq()
        .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
        .valueSeq()
        .toArray();
    entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(isKeyedCollection
        ? function (v, i) {
            entries[i].length = 2;
        }
        : function (v, i) {
            entries[i] = v[1];
        });
    return isKeyedCollection
        ? KeyedSeq(entries)
        : isIndexed(collection)
            ? IndexedSeq(entries)
            : SetSeq(entries);
}
function maxFactory(collection, comparator, mapper) {
    if (!comparator) {
        comparator = defaultComparator;
    }
    if (mapper) {
        var entry = collection
            .toSeq()
            .map(function (v, k) { return [v, mapper(v, k, collection)]; })
            .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });
        return entry && entry[0];
    }
    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });
}
function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return ((comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||
        comp > 0);
}
function zipWithFactory(keyIter, zipper, iters, zipAll) {
    var zipSequence = makeSequence(keyIter);
    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });
    zipSequence.size = zipAll ? sizes.max() : sizes.min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function (fn, reverse) {
        /* generic:
        var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          iterations++;
          if (fn(step.value[1], step.value[0], this) === false) {
            break;
          }
        }
        return iterations;
        */
        // indexed:
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
            if (fn(step.value, iterations++, this) === false) {
                break;
            }
        }
        return iterations;
    };
    zipSequence.__iteratorUncached = function (type, reverse) {
        var iterators = iters.map(function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); });
        var iterations = 0;
        var isDone = false;
        return new Iterator(function () {
            var steps;
            if (!isDone) {
                steps = iterators.map(function (i) { return i.next(); });
                isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });
            }
            if (isDone) {
                return iteratorDone();
            }
            return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) { return s.value; })));
        });
    };
    return zipSequence;
}
// #pragma Helper Functions
function reify(iter, seq) {
    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
    if (entry !== Object(entry)) {
        throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
}
function collectionClass(collection) {
    return isKeyed(collection)
        ? KeyedCollection
        : isIndexed(collection)
            ? IndexedCollection
            : SetCollection;
}
function makeSequence(collection) {
    return Object.create((isKeyed(collection)
        ? KeyedSeq
        : isIndexed(collection)
            ? IndexedSeq
            : SetSeq).prototype);
}
function cacheResultThrough() {
    if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
    }
    return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
    if (a === undefined && b === undefined) {
        return 0;
    }
    if (a === undefined) {
        return 1;
    }
    if (b === undefined) {
        return -1;
    }
    return a > b ? 1 : a < b ? -1 : 0;
}
// http://jsperf.com/copy-array-inline
function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
    }
    return newArr;
}
function invariant(condition, error) {
    if (!condition) {
        throw new Error(error);
    }
}
function assertNotInfinite(size) {
    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
}
function coerceKeyPath(keyPath) {
    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
        return keyPath;
    }
    if (isOrdered(keyPath)) {
        return keyPath.toArray();
    }
    throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
}
function isPlainObj(value) {
    return (value &&
        (typeof value.constructor !== 'function' ||
            value.constructor.name === 'Object'));
}
/**
 * Returns true if the value is a potentially-persistent data structure, either
 * provided by Immutable.js or a plain Array or Object.
 */
function isDataStructure(value) {
    return (typeof value === 'object' &&
        (isImmutable(value) || Array.isArray(value) || isPlainObj(value)));
}
/**
 * Converts a value to a string, adding quotes if a string was provided.
 */
function quoteString(value) {
    try {
        return typeof value === 'string' ? JSON.stringify(value) : String(value);
    }
    catch (_ignoreError) {
        return JSON.stringify(value);
    }
}
function has(collection, key) {
    return isImmutable(collection)
        ? collection.has(key)
        : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get(collection, key, notSetValue) {
    return isImmutable(collection)
        ? collection.get(key, notSetValue)
        : !has(collection, key)
            ? notSetValue
            : typeof collection.get === 'function'
                ? collection.get(key)
                : collection[key];
}
function shallowCopy(from) {
    if (Array.isArray(from)) {
        return arrCopy(from);
    }
    var to = {};
    for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
        }
    }
    return to;
}
function remove(collection, key) {
    if (!isDataStructure(collection)) {
        throw new TypeError('Cannot update non-data-structure value: ' + collection);
    }
    if (isImmutable(collection)) {
        if (!collection.remove) {
            throw new TypeError('Cannot update immutable value without .remove() method: ' + collection);
        }
        return collection.remove(key);
    }
    if (!hasOwnProperty.call(collection, key)) {
        return collection;
    }
    var collectionCopy = shallowCopy(collection);
    if (Array.isArray(collectionCopy)) {
        collectionCopy.splice(key, 1);
    }
    else {
        delete collectionCopy[key];
    }
    return collectionCopy;
}
function set(collection, key, value) {
    if (!isDataStructure(collection)) {
        throw new TypeError('Cannot update non-data-structure value: ' + collection);
    }
    if (isImmutable(collection)) {
        if (!collection.set) {
            throw new TypeError('Cannot update immutable value without .set() method: ' + collection);
        }
        return collection.set(key, value);
    }
    if (hasOwnProperty.call(collection, key) && value === collection[key]) {
        return collection;
    }
    var collectionCopy = shallowCopy(collection);
    collectionCopy[key] = value;
    return collectionCopy;
}
function updateIn(collection, keyPath, notSetValue, updater) {
    if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
    }
    var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
    return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
    var wasNotSet = existing === NOT_SET;
    if (i === keyPath.length) {
        var existingValue = wasNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
    }
    if (!wasNotSet && !isDataStructure(existing)) {
        throw new TypeError('Cannot update within non-data-structure value in path [' +
            keyPath.slice(0, i).map(quoteString) +
            ']: ' +
            existing);
    }
    var key = keyPath[i];
    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
    var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
    return nextUpdated === nextExisting
        ? existing
        : nextUpdated === NOT_SET
            ? remove(existing, key)
            : set(wasNotSet ? (inImmutable ? emptyMap() : {}) : existing, key, nextUpdated);
}
function setIn(collection, keyPath, value) {
    return updateIn(collection, keyPath, NOT_SET, function () { return value; });
}
function setIn$1(keyPath, v) {
    return setIn(this, keyPath, v);
}
function removeIn(collection, keyPath) {
    return updateIn(collection, keyPath, function () { return NOT_SET; });
}
function deleteIn(keyPath) {
    return removeIn(this, keyPath);
}
function update(collection, key, notSetValue, updater) {
    return updateIn(collection, [key], notSetValue, updater);
}
function update$1(key, notSetValue, updater) {
    return arguments.length === 1
        ? key(this)
        : update(this, key, notSetValue, updater);
}
function updateIn$1(keyPath, notSetValue, updater) {
    return updateIn(this, keyPath, notSetValue, updater);
}
function merge() {
    var iters = [], len = arguments.length;
    while (len--)
        iters[len] = arguments[len];
    return mergeIntoKeyedWith(this, iters);
}
function mergeWith(merger) {
    var iters = [], len = arguments.length - 1;
    while (len-- > 0)
        iters[len] = arguments[len + 1];
    if (typeof merger !== 'function') {
        throw new TypeError('Invalid merger function: ' + merger);
    }
    return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
    var iters = [];
    for (var ii = 0; ii < collections.length; ii++) {
        var collection$1 = KeyedCollection(collections[ii]);
        if (collection$1.size !== 0) {
            iters.push(collection$1);
        }
    }
    if (iters.length === 0) {
        return collection;
    }
    if (collection.toSeq().size === 0 &&
        !collection.__ownerID &&
        iters.length === 1) {
        return collection.constructor(iters[0]);
    }
    return collection.withMutations(function (collection) {
        var mergeIntoCollection = merger
            ? function (value, key) {
                update(collection, key, NOT_SET, function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); });
            }
            : function (value, key) {
                collection.set(key, value);
            };
        for (var ii = 0; ii < iters.length; ii++) {
            iters[ii].forEach(mergeIntoCollection);
        }
    });
}
function merge$1(collection) {
    var sources = [], len = arguments.length - 1;
    while (len-- > 0)
        sources[len] = arguments[len + 1];
    return mergeWithSources(collection, sources);
}
function mergeWith$1(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while (len-- > 0)
        sources[len] = arguments[len + 2];
    return mergeWithSources(collection, sources, merger);
}
function mergeDeep(collection) {
    var sources = [], len = arguments.length - 1;
    while (len-- > 0)
        sources[len] = arguments[len + 1];
    return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while (len-- > 0)
        sources[len] = arguments[len + 2];
    return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
    return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
    if (!isDataStructure(collection)) {
        throw new TypeError('Cannot merge into non-data-structure value: ' + collection);
    }
    if (isImmutable(collection)) {
        return typeof merger === 'function' && collection.mergeWith
            ? collection.mergeWith.apply(collection, [merger].concat(sources))
            : collection.merge
                ? collection.merge.apply(collection, sources)
                : collection.concat.apply(collection, sources);
    }
    var isArray = Array.isArray(collection);
    var merged = collection;
    var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
    var mergeItem = isArray
        ? function (value) {
            // Copy on write
            if (merged === collection) {
                merged = shallowCopy(merged);
            }
            merged.push(value);
        }
        : function (value, key) {
            var hasVal = hasOwnProperty.call(merged, key);
            var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
            if (!hasVal || nextVal !== merged[key]) {
                // Copy on write
                if (merged === collection) {
                    merged = shallowCopy(merged);
                }
                merged[key] = nextVal;
            }
        };
    for (var i = 0; i < sources.length; i++) {
        Collection$$1(sources[i]).forEach(mergeItem);
    }
    return merged;
}
function deepMergerWith(merger) {
    function deepMerger(oldValue, newValue, key) {
        return isDataStructure(oldValue) && isDataStructure(newValue)
            ? mergeWithSources(oldValue, [newValue], deepMerger)
            : merger
                ? merger(oldValue, newValue, key)
                : newValue;
    }
    return deepMerger;
}
function mergeDeep$1() {
    var iters = [], len = arguments.length;
    while (len--)
        iters[len] = arguments[len];
    return mergeDeepWithSources(this, iters);
}
function mergeDeepWith$1(merger) {
    var iters = [], len = arguments.length - 1;
    while (len-- > 0)
        iters[len] = arguments[len + 1];
    return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while (len-- > 0)
        iters[len] = arguments[len + 1];
    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });
}
function mergeDeepIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while (len-- > 0)
        iters[len] = arguments[len + 1];
    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); });
}
function withMutations(fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
    return this.__ensureOwner();
}
function wasAltered() {
    return this.__altered;
}
var Map$1 = /*@__PURE__*/ (function (KeyedCollection$$1) {
    function Map(value) {
        return value === null || value === undefined
            ? emptyMap()
            : isMap(value) && !isOrdered(value)
                ? value
                : emptyMap().withMutations(function (map) {
                    var iter = KeyedCollection$$1(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v, k) { return map.set(k, v); });
                });
    }
    if (KeyedCollection$$1)
        Map.__proto__ = KeyedCollection$$1;
    Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);
    Map.prototype.constructor = Map;
    Map.of = function of() {
        var keyValues = [], len = arguments.length;
        while (len--)
            keyValues[len] = arguments[len];
        return emptyMap().withMutations(function (map) {
            for (var i = 0; i < keyValues.length; i += 2) {
                if (i + 1 >= keyValues.length) {
                    throw new Error('Missing value for key: ' + keyValues[i]);
                }
                map.set(keyValues[i], keyValues[i + 1]);
            }
        });
    };
    Map.prototype.toString = function toString() {
        return this.__toString('Map {', '}');
    };
    // @pragma Access
    Map.prototype.get = function get(k, notSetValue) {
        return this._root
            ? this._root.get(0, undefined, k, notSetValue)
            : notSetValue;
    };
    // @pragma Modification
    Map.prototype.set = function set(k, v) {
        return updateMap(this, k, v);
    };
    Map.prototype.remove = function remove(k) {
        return updateMap(this, k, NOT_SET);
    };
    Map.prototype.deleteAll = function deleteAll(keys) {
        var collection = Collection(keys);
        if (collection.size === 0) {
            return this;
        }
        return this.withMutations(function (map) {
            collection.forEach(function (key) { return map.remove(key); });
        });
    };
    Map.prototype.clear = function clear() {
        if (this.size === 0) {
            return this;
        }
        if (this.__ownerID) {
            this.size = 0;
            this._root = null;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return emptyMap();
    };
    // @pragma Composition
    Map.prototype.sort = function sort(comparator) {
        // Late binding
        return OrderedMap(sortFactory(this, comparator));
    };
    Map.prototype.sortBy = function sortBy(mapper, comparator) {
        // Late binding
        return OrderedMap(sortFactory(this, comparator, mapper));
    };
    Map.prototype.map = function map(mapper, context) {
        return this.withMutations(function (map) {
            map.forEach(function (value, key) {
                map.set(key, mapper.call(context, value, key, map));
            });
        });
    };
    // @pragma Mutability
    Map.prototype.__iterator = function __iterator(type, reverse) {
        return new MapIterator(this, type, reverse);
    };
    Map.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        var iterations = 0;
        this._root &&
            this._root.iterate(function (entry) {
                iterations++;
                return fn(entry[1], entry[0], this$1);
            }, reverse);
        return iterations;
    };
    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        if (!ownerID) {
            if (this.size === 0) {
                return emptyMap();
            }
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
    };
    return Map;
}(KeyedCollection));
Map$1.isMap = isMap;
var MapPrototype = Map$1.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn$1;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update$1;
MapPrototype.updateIn = updateIn$1;
MapPrototype.merge = MapPrototype.concat = merge;
MapPrototype.mergeWith = mergeWith;
MapPrototype.mergeDeep = mergeDeep$1;
MapPrototype.mergeDeepWith = mergeDeepWith$1;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
MapPrototype['@@transducer/step'] = function (result, arr) {
    return result.set(arr[0], arr[1]);
};
MapPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
};
// #pragma Trie Nodes
var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
};
ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
            return entries[ii][1];
        }
    }
    return notSetValue;
};
ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
            break;
        }
    }
    var exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
        return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && entries.length === 1) {
        return; // undefined
    }
    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
        if (removed) {
            idx === len - 1
                ? newEntries.pop()
                : (newEntries[idx] = newEntries.pop());
        }
        else {
            newEntries[idx] = [key, value];
        }
    }
    else {
        newEntries.push([key, value]);
    }
    if (isEditable) {
        this.entries = newEntries;
        return this;
    }
    return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
};
BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
        keyHash = hash(key);
    }
    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0
        ? notSetValue
        : this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
};
BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
        keyHash = hash(key);
    }
    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var bit = 1 << keyHashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
        return this;
    }
    var idx = popCount(bitmap & (bit - 1));
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : undefined;
    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
    if (newNode === node) {
        return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }
    if (exists &&
        !newNode &&
        nodes.length === 2 &&
        isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;
    var newNodes = exists
        ? newNode
            ? setAt(nodes, idx, newNode, isEditable)
            : spliceOut(nodes, idx, isEditable)
        : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
    }
    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
    this.ownerID = ownerID;
    this.count = count;
    this.nodes = nodes;
};
HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
        keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node
        ? node.get(shift + SHIFT, keyHash, key, notSetValue)
        : notSetValue;
};
HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
        keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];
    if (removed && !node) {
        return this;
    }
    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
    if (newNode === node) {
        return this;
    }
    var newCount = this.count;
    if (!node) {
        newCount++;
    }
    else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
            return packNodes(ownerID, nodes, newCount, idx);
        }
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setAt(nodes, idx, newNode, isEditable);
    if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
    }
    return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
};
HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
            return entries[ii][1];
        }
    }
    return notSetValue;
};
HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
        keyHash = hash(key);
    }
    var removed = value === NOT_SET;
    if (keyHash !== this.keyHash) {
        if (removed) {
            return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
    }
    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
            break;
        }
    }
    var exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
        return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
        if (removed) {
            idx === len - 1
                ? newEntries.pop()
                : (newEntries[idx] = newEntries.pop());
        }
        else {
            newEntries[idx] = [key, value];
        }
    }
    else {
        newEntries.push([key, value]);
    }
    if (isEditable) {
        this.entries = newEntries;
        return this;
    }
    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
};
ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
        return this;
    }
    SetRef(didAlter);
    if (removed) {
        SetRef(didChangeSize);
        return; // undefined
    }
    if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
            this.entry[1] = value;
            return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
    }
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};
// #pragma Iterators
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
            return false;
        }
    }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
            return false;
        }
    }
};
// eslint-disable-next-line no-unused-vars
ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
};
var MapIterator = /*@__PURE__*/ (function (Iterator$$1) {
    function MapIterator(map, type, reverse) {
        this._type = type;
        this._reverse = reverse;
        this._stack = map._root && mapIteratorFrame(map._root);
    }
    if (Iterator$$1)
        MapIterator.__proto__ = Iterator$$1;
    MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
    MapIterator.prototype.constructor = MapIterator;
    MapIterator.prototype.next = function next() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
            var node = stack.node;
            var index = stack.index++;
            var maxIndex = (void 0);
            if (node.entry) {
                if (index === 0) {
                    return mapIteratorValue(type, node.entry);
                }
            }
            else if (node.entries) {
                maxIndex = node.entries.length - 1;
                if (index <= maxIndex) {
                    return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                }
            }
            else {
                maxIndex = node.nodes.length - 1;
                if (index <= maxIndex) {
                    var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                    if (subNode) {
                        if (subNode.entry) {
                            return mapIteratorValue(type, subNode.entry);
                        }
                        stack = this._stack = mapIteratorFrame(subNode, stack);
                    }
                    continue;
                }
            }
            stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
    };
    return MapIterator;
}(Iterator));
function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
    return {
        node: node,
        index: 0,
        __prev: prev,
    };
}
function makeMap(size, root, ownerID, hash$$1) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash$$1;
    map.__altered = false;
    return map;
}
var EMPTY_MAP;
function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
        if (v === NOT_SET) {
            return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    }
    else {
        var didChangeSize = MakeRef();
        var didAlter = MakeRef();
        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
            return map;
        }
        newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
    }
    if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = undefined;
        map.__altered = true;
        return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
        if (value === NOT_SET) {
            return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
    return (node.constructor === ValueNode || node.constructor === HashCollisionNode);
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }
    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var newNode;
    var nodes = idx1 === idx2
        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
        : ((newNode = new ValueNode(ownerID, keyHash, entry)),
            idx1 < idx2 ? [node, newNode] : [newNode, node]);
    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
}
function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
        ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
}
function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== undefined && ii !== excluding) {
            bitmap |= bit;
            packedNodes[packedII++] = node;
        }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}
function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x += x >> 8;
    x += x >> 16;
    return x & 0x7f;
}
function setAt(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
}
function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
            newArray[ii] = val;
            after = -1;
        }
        else {
            newArray[ii] = array[ii + after];
        }
    }
    return newArray;
}
function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
        array.pop();
        return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
            after = 1;
        }
        newArray[ii] = array[ii + after];
    }
    return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';
function isList(maybeList) {
    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
var List = /*@__PURE__*/ (function (IndexedCollection$$1) {
    function List(value) {
        var empty = emptyList();
        if (value === null || value === undefined) {
            return empty;
        }
        if (isList(value)) {
            return value;
        }
        var iter = IndexedCollection$$1(value);
        var size = iter.size;
        if (size === 0) {
            return empty;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
            return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty.withMutations(function (list) {
            list.setSize(size);
            iter.forEach(function (v, i) { return list.set(i, v); });
        });
    }
    if (IndexedCollection$$1)
        List.__proto__ = IndexedCollection$$1;
    List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
    List.prototype.constructor = List;
    List.of = function of( /*...values*/) {
        return this(arguments);
    };
    List.prototype.toString = function toString() {
        return this.__toString('List [', ']');
    };
    // @pragma Access
    List.prototype.get = function get(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
            index += this._origin;
            var node = listNodeFor(this, index);
            return node && node.array[index & MASK];
        }
        return notSetValue;
    };
    // @pragma Modification
    List.prototype.set = function set(index, value) {
        return updateList(this, index, value);
    };
    List.prototype.remove = function remove(index) {
        return !this.has(index)
            ? this
            : index === 0
                ? this.shift()
                : index === this.size - 1
                    ? this.pop()
                    : this.splice(index, 1);
    };
    List.prototype.insert = function insert(index, value) {
        return this.splice(index, 0, value);
    };
    List.prototype.clear = function clear() {
        if (this.size === 0) {
            return this;
        }
        if (this.__ownerID) {
            this.size = this._origin = this._capacity = 0;
            this._level = SHIFT;
            this._root = this._tail = null;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return emptyList();
    };
    List.prototype.push = function push( /*...values*/) {
        var values = arguments;
        var oldSize = this.size;
        return this.withMutations(function (list) {
            setListBounds(list, 0, oldSize + values.length);
            for (var ii = 0; ii < values.length; ii++) {
                list.set(oldSize + ii, values[ii]);
            }
        });
    };
    List.prototype.pop = function pop() {
        return setListBounds(this, 0, -1);
    };
    List.prototype.unshift = function unshift( /*...values*/) {
        var values = arguments;
        return this.withMutations(function (list) {
            setListBounds(list, -values.length);
            for (var ii = 0; ii < values.length; ii++) {
                list.set(ii, values[ii]);
            }
        });
    };
    List.prototype.shift = function shift() {
        return setListBounds(this, 1);
    };
    // @pragma Composition
    List.prototype.concat = function concat( /*...collections*/) {
        var arguments$1 = arguments;
        var seqs = [];
        for (var i = 0; i < arguments.length; i++) {
            var argument = arguments$1[i];
            var seq = IndexedCollection$$1(typeof argument !== 'string' && hasIterator(argument)
                ? argument
                : [argument]);
            if (seq.size !== 0) {
                seqs.push(seq);
            }
        }
        if (seqs.length === 0) {
            return this;
        }
        if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
            return this.constructor(seqs[0]);
        }
        return this.withMutations(function (list) {
            seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });
        });
    };
    List.prototype.setSize = function setSize(size) {
        return setListBounds(this, 0, size);
    };
    List.prototype.map = function map(mapper, context) {
        var this$1 = this;
        return this.withMutations(function (list) {
            for (var i = 0; i < this$1.size; i++) {
                list.set(i, mapper.call(context, list.get(i), i, list));
            }
        });
    };
    // @pragma Iteration
    List.prototype.slice = function slice(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
            return this;
        }
        return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
    };
    List.prototype.__iterator = function __iterator(type, reverse) {
        var index = reverse ? this.size : 0;
        var values = iterateList(this, reverse);
        return new Iterator(function () {
            var value = values();
            return value === DONE
                ? iteratorDone()
                : iteratorValue(type, reverse ? --index : index++, value);
        });
    };
    List.prototype.__iterate = function __iterate(fn, reverse) {
        var index = reverse ? this.size : 0;
        var values = iterateList(this, reverse);
        var value;
        while ((value = values()) !== DONE) {
            if (fn(value, reverse ? --index : index++, this) === false) {
                break;
            }
        }
        return index;
    };
    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        if (!ownerID) {
            if (this.size === 0) {
                return emptyList();
            }
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
        }
        return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    return List;
}(IndexedCollection));
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn$1;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update$1;
ListPrototype.updateIn = updateIn$1;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
ListPrototype['@@transducer/step'] = function (result, arr) {
    return result.push(arr);
};
ListPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
};
var VNode = function VNode(array, ownerID) {
    this.array = array;
    this.ownerID = ownerID;
};
// TODO: seems like these methods are very similar
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
    if (index === level ? 1 << level : this.array.length === 0) {
        return this;
    }
    var originIndex = (index >>> level) & MASK;
    if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
    }
    var removingFirst = originIndex === 0;
    var newChild;
    if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild =
            oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
            return this;
        }
    }
    if (removingFirst && !newChild) {
        return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
            editable.array[ii] = undefined;
        }
    }
    if (newChild) {
        editable.array[originIndex] = newChild;
    }
    return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
    }
    var sizeIndex = ((index - 1) >>> level) & MASK;
    if (sizeIndex >= this.array.length) {
        return this;
    }
    var newChild;
    if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild =
            oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
            return this;
        }
    }
    var editable = editableVNode(this, ownerID);
    editable.array.splice(sizeIndex + 1);
    if (newChild) {
        editable.array[sizeIndex] = newChild;
    }
    return editable;
};
var DONE = {};
function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;
    return iterateNodeOrLeaf(list._root, list._level, 0);
    function iterateNodeOrLeaf(node, level, offset) {
        return level === 0
            ? iterateLeaf(node, offset)
            : iterateNode(node, level, offset);
    }
    function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE) {
            to = SIZE;
        }
        return function () {
            if (from === to) {
                return DONE;
            }
            var idx = reverse ? --to : from++;
            return array && array[idx];
        };
    }
    function iterateNode(node, level, offset) {
        var values;
        var array = node && node.array;
        var from = offset > left ? 0 : (left - offset) >> level;
        var to = ((right - offset) >> level) + 1;
        if (to > SIZE) {
            to = SIZE;
        }
        return function () {
            while (true) {
                if (values) {
                    var value = values();
                    if (value !== DONE) {
                        return value;
                    }
                    values = null;
                }
                if (from === to) {
                    return DONE;
                }
                var idx = reverse ? --to : from++;
                values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
            }
        };
    }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
}
var EMPTY_LIST;
function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value) {
    index = wrapIndex(list, index);
    if (index !== index) {
        return list;
    }
    if (index >= list.size || index < 0) {
        return list.withMutations(function (list) {
            index < 0
                ? setListBounds(list, index).set(0, value)
                : setListBounds(list, 0, index + 1).set(index, value);
        });
    }
    index += list._origin;
    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef();
    if (index >= getTailOffset(list._capacity)) {
        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    }
    else {
        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }
    if (!didAlter.value) {
        return list;
    }
    if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
        return node;
    }
    var newNode;
    if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
        if (newLowerNode === lowerNode) {
            return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
    }
    if (nodeHas && node.array[idx] === value) {
        return node;
    }
    if (didAlter) {
        SetRef(didAlter);
    }
    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
        newNode.array.pop();
    }
    else {
        newNode.array[idx] = value;
    }
    return newNode;
}
function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
        return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
        return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
            node = node.array[(rawIndex >>> level) & MASK];
            level -= SHIFT;
        }
        return node;
    }
}
function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
        begin |= 0;
    }
    if (end !== undefined) {
        end |= 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined
        ? oldCapacity
        : end < 0
            ? oldCapacity + end
            : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
    }
    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
        return list.clear();
    }
    var newLevel = list._level;
    var newRoot = list._root;
    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
    }
    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);
    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
    }
    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset
        ? listNodeFor(list, newCapacity - 1)
        : newTailOffset > oldTailOffset
            ? new VNode([], owner)
            : oldTail;
    // Merge Tail into tree.
    if (oldTail &&
        newTailOffset > oldTailOffset &&
        newOrigin < oldCapacity &&
        oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
            var idx = (oldTailOffset >>> level) & MASK;
            node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }
    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }
    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
        // Otherwise, if the root has been trimmed, garbage collect.
    }
    else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;
        // Identify the new top root node of the subtree of the old root.
        while (newRoot) {
            var beginIndex = (newOrigin >>> newLevel) & MASK;
            if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
                break;
            }
            if (beginIndex) {
                offsetShift += (1 << newLevel) * beginIndex;
            }
            newLevel -= SHIFT;
            newRoot = newRoot.array[beginIndex];
        }
        // Trim the new sides of the new root.
        if (newRoot && newOrigin > oldOrigin) {
            newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
            newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
            newOrigin -= offsetShift;
            newCapacity -= offsetShift;
        }
    }
    if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
}
var OrderedMap = /*@__PURE__*/ (function (Map$$1) {
    function OrderedMap(value) {
        return value === null || value === undefined
            ? emptyOrderedMap()
            : isOrderedMap(value)
                ? value
                : emptyOrderedMap().withMutations(function (map) {
                    var iter = KeyedCollection(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v, k) { return map.set(k, v); });
                });
    }
    if (Map$$1)
        OrderedMap.__proto__ = Map$$1;
    OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
    OrderedMap.prototype.constructor = OrderedMap;
    OrderedMap.of = function of( /*...values*/) {
        return this(arguments);
    };
    OrderedMap.prototype.toString = function toString() {
        return this.__toString('OrderedMap {', '}');
    };
    // @pragma Access
    OrderedMap.prototype.get = function get(k, notSetValue) {
        var index = this._map.get(k);
        return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };
    // @pragma Modification
    OrderedMap.prototype.clear = function clear() {
        if (this.size === 0) {
            return this;
        }
        if (this.__ownerID) {
            this.size = 0;
            this._map.clear();
            this._list.clear();
            return this;
        }
        return emptyOrderedMap();
    };
    OrderedMap.prototype.set = function set(k, v) {
        return updateOrderedMap(this, k, v);
    };
    OrderedMap.prototype.remove = function remove(k) {
        return updateOrderedMap(this, k, NOT_SET);
    };
    OrderedMap.prototype.wasAltered = function wasAltered() {
        return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        return this._list.__iterate(function (entry) { return entry && fn(entry[1], entry[0], this$1); }, reverse);
    };
    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
        return this._list.fromEntrySeq().__iterator(type, reverse);
    };
    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
            if (this.size === 0) {
                return emptyOrderedMap();
            }
            this.__ownerID = ownerID;
            this._map = newMap;
            this._list = newList;
            return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };
    return OrderedMap;
}(Map$1));
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
    return (EMPTY_ORDERED_MAP ||
        (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList())));
}
function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) {
        // removed
        if (!has) {
            return omap;
        }
        if (list.size >= SIZE && list.size >= map.size * 2) {
            newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
            newMap = newList
                .toKeyedSeq()
                .map(function (entry) { return entry[0]; })
                .flip()
                .toMap();
            if (omap.__ownerID) {
                newMap.__ownerID = newList.__ownerID = omap.__ownerID;
            }
        }
        else {
            newMap = map.remove(k);
            newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
        }
    }
    else if (has) {
        if (v === list.get(i)[1]) {
            return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
    }
    else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
    }
    if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = undefined;
        return omap;
    }
    return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';
function isStack(maybeStack) {
    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
var Stack = /*@__PURE__*/ (function (IndexedCollection$$1) {
    function Stack(value) {
        return value === null || value === undefined
            ? emptyStack()
            : isStack(value)
                ? value
                : emptyStack().pushAll(value);
    }
    if (IndexedCollection$$1)
        Stack.__proto__ = IndexedCollection$$1;
    Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
    Stack.prototype.constructor = Stack;
    Stack.of = function of( /*...values*/) {
        return this(arguments);
    };
    Stack.prototype.toString = function toString() {
        return this.__toString('Stack [', ']');
    };
    // @pragma Access
    Stack.prototype.get = function get(index, notSetValue) {
        var head = this._head;
        index = wrapIndex(this, index);
        while (head && index--) {
            head = head.next;
        }
        return head ? head.value : notSetValue;
    };
    Stack.prototype.peek = function peek() {
        return this._head && this._head.value;
    };
    // @pragma Modification
    Stack.prototype.push = function push( /*...values*/) {
        var arguments$1 = arguments;
        if (arguments.length === 0) {
            return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
            head = {
                value: arguments$1[ii],
                next: head,
            };
        }
        if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return makeStack(newSize, head);
    };
    Stack.prototype.pushAll = function pushAll(iter) {
        iter = IndexedCollection$$1(iter);
        if (iter.size === 0) {
            return this;
        }
        if (this.size === 0 && isStack(iter)) {
            return iter;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.__iterate(function (value) {
            newSize++;
            head = {
                value: value,
                next: head,
            };
        }, /* reverse */ true);
        if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return makeStack(newSize, head);
    };
    Stack.prototype.pop = function pop() {
        return this.slice(1);
    };
    Stack.prototype.clear = function clear() {
        if (this.size === 0) {
            return this;
        }
        if (this.__ownerID) {
            this.size = 0;
            this._head = undefined;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return emptyStack();
    };
    Stack.prototype.slice = function slice(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
            return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
            // super.slice(begin, end);
            return IndexedCollection$$1.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
            head = head.next;
        }
        if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = undefined;
            this.__altered = true;
            return this;
        }
        return makeStack(newSize, head);
    };
    // @pragma Mutability
    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        if (!ownerID) {
            if (this.size === 0) {
                return emptyStack();
            }
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
    };
    // @pragma Iteration
    Stack.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        if (reverse) {
            return new ArraySeq(this.toArray()).__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
            if (fn(node.value, iterations++, this) === false) {
                break;
            }
            node = node.next;
        }
        return iterations;
    };
    Stack.prototype.__iterator = function __iterator(type, reverse) {
        if (reverse) {
            return new ArraySeq(this.toArray()).__iterator(type, reverse);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function () {
            if (node) {
                var value = node.value;
                node = node.next;
                return iteratorValue(type, iterations++, value);
            }
            return iteratorDone();
        });
    };
    return Stack;
}(IndexedCollection));
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
StackPrototype['@@transducer/step'] = function (result, arr) {
    return result.unshift(arr);
};
StackPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
}
var EMPTY_STACK;
function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';
function isSet(maybeSet) {
    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (!isCollection(b) ||
        (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
        (a.__hash !== undefined &&
            b.__hash !== undefined &&
            a.__hash !== b.__hash) ||
        isKeyed(a) !== isKeyed(b) ||
        isIndexed(a) !== isIndexed(b) ||
        isOrdered(a) !== isOrdered(b)) {
        return false;
    }
    if (a.size === 0 && b.size === 0) {
        return true;
    }
    var notAssociative = !isAssociative(a);
    if (isOrdered(a)) {
        var entries = a.entries();
        return (b.every(function (v, k) {
            var entry = entries.next().value;
            return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done);
    }
    var flipped = false;
    if (a.size === undefined) {
        if (b.size === undefined) {
            if (typeof a.cacheResult === 'function') {
                a.cacheResult();
            }
        }
        else {
            flipped = true;
            var _ = a;
            a = b;
            b = _;
        }
    }
    var allEqual = true;
    var bSize = b.__iterate(function (v, k) {
        if (notAssociative
            ? !a.has(v)
            : flipped
                ? !is(v, a.get(k, NOT_SET))
                : !is(a.get(k, NOT_SET), v)) {
            allEqual = false;
            return false;
        }
    });
    return allEqual && a.size === bSize;
}
/**
 * Contributes additional methods to a constructor
 */
function mixin(ctor, methods) {
    var keyCopier = function (key) {
        ctor.prototype[key] = methods[key];
    };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
        Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
}
function toJS(value) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    if (!isCollection(value)) {
        if (!isDataStructure(value)) {
            return value;
        }
        value = Seq(value);
    }
    if (isKeyed(value)) {
        var result$1 = {};
        value.__iterate(function (v, k) {
            result$1[k] = toJS(v);
        });
        return result$1;
    }
    var result = [];
    value.__iterate(function (v) {
        result.push(toJS(v));
    });
    return result;
}
var Set$1 = /*@__PURE__*/ (function (SetCollection$$1) {
    function Set(value) {
        return value === null || value === undefined
            ? emptySet()
            : isSet(value) && !isOrdered(value)
                ? value
                : emptySet().withMutations(function (set) {
                    var iter = SetCollection$$1(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v) { return set.add(v); });
                });
    }
    if (SetCollection$$1)
        Set.__proto__ = SetCollection$$1;
    Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);
    Set.prototype.constructor = Set;
    Set.of = function of( /*...values*/) {
        return this(arguments);
    };
    Set.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
    };
    Set.intersect = function intersect(sets) {
        sets = Collection(sets).toArray();
        return sets.length
            ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
            : emptySet();
    };
    Set.union = function union(sets) {
        sets = Collection(sets).toArray();
        return sets.length
            ? SetPrototype.union.apply(Set(sets.pop()), sets)
            : emptySet();
    };
    Set.prototype.toString = function toString() {
        return this.__toString('Set {', '}');
    };
    // @pragma Access
    Set.prototype.has = function has(value) {
        return this._map.has(value);
    };
    // @pragma Modification
    Set.prototype.add = function add(value) {
        return updateSet(this, this._map.set(value, value));
    };
    Set.prototype.remove = function remove(value) {
        return updateSet(this, this._map.remove(value));
    };
    Set.prototype.clear = function clear() {
        return updateSet(this, this._map.clear());
    };
    // @pragma Composition
    Set.prototype.map = function map(mapper, context) {
        var this$1 = this;
        var removes = [];
        var adds = [];
        this.forEach(function (value) {
            var mapped = mapper.call(context, value, value, this$1);
            if (mapped !== value) {
                removes.push(value);
                adds.push(mapped);
            }
        });
        return this.withMutations(function (set) {
            removes.forEach(function (value) { return set.remove(value); });
            adds.forEach(function (value) { return set.add(value); });
        });
    };
    Set.prototype.union = function union() {
        var iters = [], len = arguments.length;
        while (len--)
            iters[len] = arguments[len];
        iters = iters.filter(function (x) { return x.size !== 0; });
        if (iters.length === 0) {
            return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
            return this.constructor(iters[0]);
        }
        return this.withMutations(function (set) {
            for (var ii = 0; ii < iters.length; ii++) {
                SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });
            }
        });
    };
    Set.prototype.intersect = function intersect() {
        var iters = [], len = arguments.length;
        while (len--)
            iters[len] = arguments[len];
        if (iters.length === 0) {
            return this;
        }
        iters = iters.map(function (iter) { return SetCollection$$1(iter); });
        var toRemove = [];
        this.forEach(function (value) {
            if (!iters.every(function (iter) { return iter.includes(value); })) {
                toRemove.push(value);
            }
        });
        return this.withMutations(function (set) {
            toRemove.forEach(function (value) {
                set.remove(value);
            });
        });
    };
    Set.prototype.subtract = function subtract() {
        var iters = [], len = arguments.length;
        while (len--)
            iters[len] = arguments[len];
        if (iters.length === 0) {
            return this;
        }
        iters = iters.map(function (iter) { return SetCollection$$1(iter); });
        var toRemove = [];
        this.forEach(function (value) {
            if (iters.some(function (iter) { return iter.includes(value); })) {
                toRemove.push(value);
            }
        });
        return this.withMutations(function (set) {
            toRemove.forEach(function (value) {
                set.remove(value);
            });
        });
    };
    Set.prototype.sort = function sort(comparator) {
        // Late binding
        return OrderedSet(sortFactory(this, comparator));
    };
    Set.prototype.sortBy = function sortBy(mapper, comparator) {
        // Late binding
        return OrderedSet(sortFactory(this, comparator, mapper));
    };
    Set.prototype.wasAltered = function wasAltered() {
        return this._map.wasAltered();
    };
    Set.prototype.__iterate = function __iterate(fn, reverse) {
        var this$1 = this;
        return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);
    };
    Set.prototype.__iterator = function __iterator(type, reverse) {
        return this._map.__iterator(type, reverse);
    };
    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
            if (this.size === 0) {
                return this.__empty();
            }
            this.__ownerID = ownerID;
            this._map = newMap;
            return this;
        }
        return this.__make(newMap, ownerID);
    };
    return Set;
}(SetCollection));
Set$1.isSet = isSet;
var SetPrototype = Set$1.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
SetPrototype['@@transducer/step'] = function (result, arr) {
    return result.add(arr);
};
SetPrototype['@@transducer/result'] = function (obj) {
    return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set, newMap) {
    if (set.__ownerID) {
        set.size = newMap.size;
        set._map = newMap;
        return set;
    }
    return newMap === set._map
        ? set
        : newMap.size === 0
            ? set.__empty()
            : set.__make(newMap);
}
function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
}
var EMPTY_SET;
function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
/**
 * Returns a lazy seq of nums from start (inclusive) to end
 * (exclusive), by step, where start defaults to 0, step to 1, and end to
 * infinity. When start is equal to end, returns empty list.
 */
var Range = /*@__PURE__*/ (function (IndexedSeq$$1) {
    function Range(start, end, step) {
        if (!(this instanceof Range)) {
            return new Range(start, end, step);
        }
        invariant(step !== 0, 'Cannot step a Range by 0');
        start = start || 0;
        if (end === undefined) {
            end = Infinity;
        }
        step = step === undefined ? 1 : Math.abs(step);
        if (end < start) {
            step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
            if (EMPTY_RANGE) {
                return EMPTY_RANGE;
            }
            EMPTY_RANGE = this;
        }
    }
    if (IndexedSeq$$1)
        Range.__proto__ = IndexedSeq$$1;
    Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
    Range.prototype.constructor = Range;
    Range.prototype.toString = function toString() {
        if (this.size === 0) {
            return 'Range []';
        }
        return ('Range [ ' +
            this._start +
            '...' +
            this._end +
            (this._step !== 1 ? ' by ' + this._step : '') +
            ' ]');
    };
    Range.prototype.get = function get(index, notSetValue) {
        return this.has(index)
            ? this._start + wrapIndex(this, index) * this._step
            : notSetValue;
    };
    Range.prototype.includes = function includes(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return (possibleIndex >= 0 &&
            possibleIndex < this.size &&
            possibleIndex === Math.floor(possibleIndex));
    };
    Range.prototype.slice = function slice(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
            return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
            return new Range(0, 0);
        }
        return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range.prototype.indexOf = function indexOf(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
            var index = offsetValue / this._step;
            if (index >= 0 && index < this.size) {
                return index;
            }
        }
        return -1;
    };
    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
        return this.indexOf(searchValue);
    };
    Range.prototype.__iterate = function __iterate(fn, reverse) {
        var size = this.size;
        var step = this._step;
        var value = reverse ? this._start + (size - 1) * step : this._start;
        var i = 0;
        while (i !== size) {
            if (fn(value, reverse ? size - ++i : i++, this) === false) {
                break;
            }
            value += reverse ? -step : step;
        }
        return i;
    };
    Range.prototype.__iterator = function __iterator(type, reverse) {
        var size = this.size;
        var step = this._step;
        var value = reverse ? this._start + (size - 1) * step : this._start;
        var i = 0;
        return new Iterator(function () {
            if (i === size) {
                return iteratorDone();
            }
            var v = value;
            value += reverse ? -step : step;
            return iteratorValue(type, reverse ? size - ++i : i++, v);
        });
    };
    Range.prototype.equals = function equals(other) {
        return other instanceof Range
            ? this._start === other._start &&
                this._end === other._end &&
                this._step === other._step
            : deepEqual(this, other);
    };
    return Range;
}(IndexedSeq));
var EMPTY_RANGE;
function getIn(collection, searchKeyPath, notSetValue) {
    var keyPath = coerceKeyPath(searchKeyPath);
    var i = 0;
    while (i !== keyPath.length) {
        collection = get(collection, keyPath[i++], NOT_SET);
        if (collection === NOT_SET) {
            return notSetValue;
        }
    }
    return collection;
}
function getIn$1(searchKeyPath, notSetValue) {
    return getIn(this, searchKeyPath, notSetValue);
}
function hasIn(collection, keyPath) {
    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn$1(searchKeyPath) {
    return hasIn(this, searchKeyPath);
}
function toObject() {
    assertNotInfinite(this.size);
    var object = {};
    this.__iterate(function (v, k) {
        object[k] = v;
    });
    return object;
}
// Note: all of these methods are deprecated.
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
    // ### Conversion to other types
    toArray: function toArray() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        var useTuples = isKeyed(this);
        var i = 0;
        this.__iterate(function (v, k) {
            // Keyed collections produce an array of tuples.
            array[i++] = useTuples ? [k, v] : v;
        });
        return array;
    },
    toIndexedSeq: function toIndexedSeq() {
        return new ToIndexedSequence(this);
    },
    toJS: function toJS$1() {
        return toJS(this);
    },
    toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, true);
    },
    toMap: function toMap() {
        // Use Late Binding here to solve the circular dependency.
        return Map$1(this.toKeyedSeq());
    },
    toObject: toObject,
    toOrderedMap: function toOrderedMap() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedMap(this.toKeyedSeq());
    },
    toOrderedSet: function toOrderedSet() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },
    toSet: function toSet() {
        // Use Late Binding here to solve the circular dependency.
        return Set$1(isKeyed(this) ? this.valueSeq() : this);
    },
    toSetSeq: function toSetSeq() {
        return new ToSetSequence(this);
    },
    toSeq: function toSeq() {
        return isIndexed(this)
            ? this.toIndexedSeq()
            : isKeyed(this)
                ? this.toKeyedSeq()
                : this.toSetSeq();
    },
    toStack: function toStack() {
        // Use Late Binding here to solve the circular dependency.
        return Stack(isKeyed(this) ? this.valueSeq() : this);
    },
    toList: function toList() {
        // Use Late Binding here to solve the circular dependency.
        return List(isKeyed(this) ? this.valueSeq() : this);
    },
    // ### Common JavaScript methods and properties
    toString: function toString() {
        return '[Collection]';
    },
    __toString: function __toString(head, tail) {
        if (this.size === 0) {
            return head + tail;
        }
        return (head +
            ' ' +
            this.toSeq()
                .map(this.__toStringMapper)
                .join(', ') +
            ' ' +
            tail);
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    concat: function concat() {
        var values = [], len = arguments.length;
        while (len--)
            values[len] = arguments[len];
        return reify(this, concatFactory(this, values));
    },
    includes: function includes(searchValue) {
        return this.some(function (value) { return is(value, searchValue); });
    },
    entries: function entries() {
        return this.__iterator(ITERATE_ENTRIES);
    },
    every: function every(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function (v, k, c) {
            if (!predicate.call(context, v, k, c)) {
                returnValue = false;
                return false;
            }
        });
        return returnValue;
    },
    filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
    },
    find: function find(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
    },
    forEach: function forEach(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },
    join: function join(separator) {
        assertNotInfinite(this.size);
        separator = separator !== undefined ? '' + separator : ',';
        var joined = '';
        var isFirst = true;
        this.__iterate(function (v) {
            isFirst ? (isFirst = false) : (joined += separator);
            joined += v !== null && v !== undefined ? v.toString() : '';
        });
        return joined;
    },
    keys: function keys() {
        return this.__iterator(ITERATE_KEYS);
    },
    map: function map(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
    },
    reduce: function reduce$1(reducer, initialReduction, context) {
        return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
    },
    reduceRight: function reduceRight(reducer, initialReduction, context) {
        return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
    },
    reverse: function reverse() {
        return reify(this, reverseFactory(this, true));
    },
    slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
    },
    some: function some(predicate, context) {
        return !this.every(not(predicate), context);
    },
    sort: function sort(comparator) {
        return reify(this, sortFactory(this, comparator));
    },
    values: function values() {
        return this.__iterator(ITERATE_VALUES);
    },
    // ### More sequential methods
    butLast: function butLast() {
        return this.slice(0, -1);
    },
    isEmpty: function isEmpty() {
        return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
    },
    count: function count(predicate, context) {
        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
    },
    countBy: function countBy(grouper, context) {
        return countByFactory(this, grouper, context);
    },
    equals: function equals(other) {
        return deepEqual(this, other);
    },
    entrySeq: function entrySeq() {
        var collection = this;
        if (collection._cache) {
            // We cache as an entries array, so we can just return the cache!
            return new ArraySeq(collection._cache);
        }
        var entriesSequence = collection
            .toSeq()
            .map(entryMapper)
            .toIndexedSeq();
        entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };
        return entriesSequence;
    },
    filterNot: function filterNot(predicate, context) {
        return this.filter(not(predicate), context);
    },
    findEntry: function findEntry(predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function (v, k, c) {
            if (predicate.call(context, v, k, c)) {
                found = [k, v];
                return false;
            }
        });
        return found;
    },
    findKey: function findKey(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
    },
    findLast: function findLast(predicate, context, notSetValue) {
        return this.toKeyedSeq()
            .reverse()
            .find(predicate, context, notSetValue);
    },
    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
        return this.toKeyedSeq()
            .reverse()
            .findEntry(predicate, context, notSetValue);
    },
    findLastKey: function findLastKey(predicate, context) {
        return this.toKeyedSeq()
            .reverse()
            .findKey(predicate, context);
    },
    first: function first(notSetValue) {
        return this.find(returnTrue, null, notSetValue);
    },
    flatMap: function flatMap(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
    },
    flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, true));
    },
    fromEntrySeq: function fromEntrySeq() {
        return new FromEntriesSequence(this);
    },
    get: function get(searchKey, notSetValue) {
        return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
    },
    getIn: getIn$1,
    groupBy: function groupBy(grouper, context) {
        return groupByFactory(this, grouper, context);
    },
    has: function has(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
    },
    hasIn: hasIn$1,
    isSubset: function isSubset(iter) {
        iter = typeof iter.includes === 'function' ? iter : Collection(iter);
        return this.every(function (value) { return iter.includes(value); });
    },
    isSuperset: function isSuperset(iter) {
        iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
        return iter.isSubset(this);
    },
    keyOf: function keyOf(searchValue) {
        return this.findKey(function (value) { return is(value, searchValue); });
    },
    keySeq: function keySeq() {
        return this.toSeq()
            .map(keyMapper)
            .toIndexedSeq();
    },
    last: function last(notSetValue) {
        return this.toSeq()
            .reverse()
            .first(notSetValue);
    },
    lastKeyOf: function lastKeyOf(searchValue) {
        return this.toKeyedSeq()
            .reverse()
            .keyOf(searchValue);
    },
    max: function max(comparator) {
        return maxFactory(this, comparator);
    },
    maxBy: function maxBy(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
    },
    min: function min(comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },
    minBy: function minBy(mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },
    rest: function rest() {
        return this.slice(1);
    },
    skip: function skip(amount) {
        return amount === 0 ? this : this.slice(Math.max(0, amount));
    },
    skipLast: function skipLast(amount) {
        return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
    },
    skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
    },
    skipUntil: function skipUntil(predicate, context) {
        return this.skipWhile(not(predicate), context);
    },
    sortBy: function sortBy(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
    },
    take: function take(amount) {
        return this.slice(0, Math.max(0, amount));
    },
    takeLast: function takeLast(amount) {
        return this.slice(-Math.max(0, amount));
    },
    takeWhile: function takeWhile(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
    },
    takeUntil: function takeUntil(predicate, context) {
        return this.takeWhile(not(predicate), context);
    },
    update: function update(fn) {
        return fn(this);
    },
    valueSeq: function valueSeq() {
        return this.toIndexedSeq();
    },
    // ### Hashable Object
    hashCode: function hashCode() {
        return this.__hash || (this.__hash = hashCollection(this));
    },
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
    return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
    // ### More sequential methods
    flip: function flip() {
        return reify(this, flipFactory(this));
    },
    mapEntries: function mapEntries(mapper, context) {
        var this$1 = this;
        var iterations = 0;
        return reify(this, this.toSeq()
            .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })
            .fromEntrySeq());
    },
    mapKeys: function mapKeys(mapper, context) {
        var this$1 = this;
        return reify(this, this.toSeq()
            .flip()
            .map(function (k, v) { return mapper.call(context, k, v, this$1); })
            .flip());
    },
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };
mixin(IndexedCollection, {
    // ### Conversion to other types
    toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, false);
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
    },
    findIndex: function findIndex(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
    },
    indexOf: function indexOf(searchValue) {
        var key = this.keyOf(searchValue);
        return key === undefined ? -1 : key;
    },
    lastIndexOf: function lastIndexOf(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === undefined ? -1 : key;
    },
    reverse: function reverse() {
        return reify(this, reverseFactory(this, false));
    },
    slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
    },
    splice: function splice(index, removeNum /*, ...values*/) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum || 0, 0);
        if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
            return this;
        }
        // If index is negative, it should resolve relative to the size of the
        // collection. However size may be expensive to compute if not cached, so
        // only call count() if the number is in fact negative.
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(this, numArgs === 1
            ? spliced
            : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
    },
    // ### More collection methods
    findLastIndex: function findLastIndex(predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
    },
    first: function first(notSetValue) {
        return this.get(0, notSetValue);
    },
    flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, false));
    },
    get: function get(index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 ||
            (this.size === Infinity || (this.size !== undefined && index > this.size))
            ? notSetValue
            : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
    },
    has: function has(index) {
        index = wrapIndex(this, index);
        return (index >= 0 &&
            (this.size !== undefined
                ? this.size === Infinity || index < this.size
                : this.indexOf(index) !== -1));
    },
    interpose: function interpose(separator) {
        return reify(this, interposeFactory(this, separator));
    },
    interleave: function interleave( /*...collections*/) {
        var collections = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
            interleaved.size = zipped.size * collections.length;
        }
        return reify(this, interleaved);
    },
    keySeq: function keySeq() {
        return Range(0, this.size);
    },
    last: function last(notSetValue) {
        return this.get(-1, notSetValue);
    },
    skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
    },
    zip: function zip( /*, ...collections */) {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections));
    },
    zipAll: function zipAll( /*, ...collections */) {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections, true));
    },
    zipWith: function zipWith(zipper /*, ...collections */) {
        var collections = arrCopy(arguments);
        collections[0] = this;
        return reify(this, zipWithFactory(this, zipper, collections));
    },
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
    // ### ES6 Collection methods (ES6 Array and Map)
    get: function get(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
    },
    includes: function includes(value) {
        return this.has(value);
    },
    // ### More sequential methods
    keySeq: function keySeq() {
        return this.valueSeq();
    },
});
SetCollection.prototype.has = CollectionPrototype.includes;
SetCollection.prototype.contains = SetCollection.prototype.includes;
// Mixin subclasses
mixin(KeyedSeq, KeyedCollection.prototype);
mixin(IndexedSeq, IndexedCollection.prototype);
mixin(SetSeq, SetCollection.prototype);
// #pragma Helper functions
function reduce(collection, reducer, reduction, context, useFirst, reverse) {
    assertNotInfinite(collection.size);
    collection.__iterate(function (v, k, c) {
        if (useFirst) {
            useFirst = false;
            reduction = v;
        }
        else {
            reduction = reducer.call(context, reduction, v, k, c);
        }
    }, reverse);
    return reduction;
}
function keyMapper(v, k) {
    return k;
}
function entryMapper(v, k) {
    return [k, v];
}
function not(predicate) {
    return function () {
        return !predicate.apply(this, arguments);
    };
}
function neg(predicate) {
    return function () {
        return -predicate.apply(this, arguments);
    };
}
function defaultZipper() {
    return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
    if (collection.size === Infinity) {
        return 0;
    }
    var ordered = isOrdered(collection);
    var keyed = isKeyed(collection);
    var h = ordered ? 1 : 0;
    var size = collection.__iterate(keyed
        ? ordered
            ? function (v, k) {
                h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
            }
            : function (v, k) {
                h = (h + hashMerge(hash(v), hash(k))) | 0;
            }
        : ordered
            ? function (v) {
                h = (31 * h + hash(v)) | 0;
            }
            : function (v) {
                h = (h + hash(v)) | 0;
            });
    return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
    h = imul(h, 0xcc9e2d51);
    h = imul((h << 15) | (h >>> -15), 0x1b873593);
    h = imul((h << 13) | (h >>> -13), 5);
    h = ((h + 0xe6546b64) | 0) ^ size;
    h = imul(h ^ (h >>> 16), 0x85ebca6b);
    h = imul(h ^ (h >>> 13), 0xc2b2ae35);
    h = smi(h ^ (h >>> 16));
    return h;
}
function hashMerge(a, b) {
    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
}
var OrderedSet = /*@__PURE__*/ (function (Set$$1) {
    function OrderedSet(value) {
        return value === null || value === undefined
            ? emptyOrderedSet()
            : isOrderedSet(value)
                ? value
                : emptyOrderedSet().withMutations(function (set) {
                    var iter = SetCollection(value);
                    assertNotInfinite(iter.size);
                    iter.forEach(function (v) { return set.add(v); });
                });
    }
    if (Set$$1)
        OrderedSet.__proto__ = Set$$1;
    OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
    OrderedSet.prototype.constructor = OrderedSet;
    OrderedSet.of = function of( /*...values*/) {
        return this(arguments);
    };
    OrderedSet.fromKeys = function fromKeys(value) {
        return this(KeyedCollection(value).keySeq());
    };
    OrderedSet.prototype.toString = function toString() {
        return this.__toString('OrderedSet {', '}');
    };
    return OrderedSet;
}(Set$1));
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
    return (EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap())));
}
var Record = function Record(defaultValues, name) {
    var hasInitialized;
    var RecordType = function Record(values) {
        var this$1 = this;
        if (values instanceof RecordType) {
            return values;
        }
        if (!(this instanceof RecordType)) {
            return new RecordType(values);
        }
        if (!hasInitialized) {
            hasInitialized = true;
            var keys = Object.keys(defaultValues);
            var indices = (RecordTypePrototype._indices = {});
            // Deprecated: left to attempt not to break any external code which
            // relies on a ._name property existing on record instances.
            // Use Record.getDescriptiveName() instead
            RecordTypePrototype._name = name;
            RecordTypePrototype._keys = keys;
            RecordTypePrototype._defaultValues = defaultValues;
            for (var i = 0; i < keys.length; i++) {
                var propName = keys[i];
                indices[propName] = i;
                if (RecordTypePrototype[propName]) {
                    /* eslint-disable no-console */
                    typeof console === 'object' &&
                        console.warn &&
                        console.warn('Cannot define ' +
                            recordName(this) +
                            ' with property "' +
                            propName +
                            '" since that property name is part of the Record API.');
                    /* eslint-enable no-console */
                }
                else {
                    setProp(RecordTypePrototype, propName);
                }
            }
        }
        this.__ownerID = undefined;
        this._values = List().withMutations(function (l) {
            l.setSize(this$1._keys.length);
            KeyedCollection(values).forEach(function (v, k) {
                l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
            });
        });
    };
    var RecordTypePrototype = (RecordType.prototype = Object.create(RecordPrototype));
    RecordTypePrototype.constructor = RecordType;
    if (name) {
        RecordType.displayName = name;
    }
    return RecordType;
};
Record.prototype.toString = function toString() {
    var str = recordName(this) + ' { ';
    var keys = this._keys;
    var k;
    for (var i = 0, l = keys.length; i !== l; i++) {
        k = keys[i];
        str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
    }
    return str + ' }';
};
Record.prototype.equals = function equals(other) {
    return (this === other ||
        (other &&
            this._keys === other._keys &&
            recordSeq(this).equals(recordSeq(other))));
};
Record.prototype.hashCode = function hashCode() {
    return recordSeq(this).hashCode();
};
// @pragma Access
Record.prototype.has = function has(k) {
    return this._indices.hasOwnProperty(k);
};
Record.prototype.get = function get(k, notSetValue) {
    if (!this.has(k)) {
        return notSetValue;
    }
    var index = this._indices[k];
    var value = this._values.get(index);
    return value === undefined ? this._defaultValues[k] : value;
};
// @pragma Modification
Record.prototype.set = function set(k, v) {
    if (this.has(k)) {
        var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
        if (newValues !== this._values && !this.__ownerID) {
            return makeRecord(this, newValues);
        }
    }
    return this;
};
Record.prototype.remove = function remove(k) {
    return this.set(k);
};
Record.prototype.clear = function clear() {
    var newValues = this._values.clear().setSize(this._keys.length);
    return this.__ownerID ? this : makeRecord(this, newValues);
};
Record.prototype.wasAltered = function wasAltered() {
    return this._values.wasAltered();
};
Record.prototype.toSeq = function toSeq() {
    return recordSeq(this);
};
Record.prototype.toJS = function toJS$1() {
    return toJS(this);
};
Record.prototype.entries = function entries() {
    return this.__iterator(ITERATE_ENTRIES);
};
Record.prototype.__iterator = function __iterator(type, reverse) {
    return recordSeq(this).__iterator(type, reverse);
};
Record.prototype.__iterate = function __iterate(fn, reverse) {
    return recordSeq(this).__iterate(fn, reverse);
};
Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
        return this;
    }
    var newValues = this._values.__ensureOwner(ownerID);
    if (!ownerID) {
        this.__ownerID = ownerID;
        this._values = newValues;
        return this;
    }
    return makeRecord(this, newValues, ownerID);
};
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn$1;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge;
RecordPrototype.mergeWith = mergeWith;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep$1;
RecordPrototype.mergeDeepWith = mergeDeepWith$1;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn$1;
RecordPrototype.update = update$1;
RecordPrototype.updateIn = updateIn$1;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject =
    CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function () {
    return this.toString();
};
function makeRecord(likeRecord, values, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._values = values;
    record.__ownerID = ownerID;
    return record;
}
function recordName(record) {
    return record.constructor.displayName || record.constructor.name || 'Record';
}
function recordSeq(record) {
    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
}
function setProp(prototype, name) {
    try {
        Object.defineProperty(prototype, name, {
            get: function () {
                return this.get(name);
            },
            set: function (value) {
                invariant(this.__ownerID, 'Cannot set on an immutable record.');
                this.set(name, value);
            },
        });
    }
    catch (error) {
        // Object.defineProperty failed. Probably IE8.
    }
}
/**
 * Returns a lazy Seq of `value` repeated `times` times. When `times` is
 * undefined, returns an infinite sequence of `value`.
 */
var Repeat = /*@__PURE__*/ (function (IndexedSeq$$1) {
    function Repeat(value, times) {
        if (!(this instanceof Repeat)) {
            return new Repeat(value, times);
        }
        this._value = value;
        this.size = times === undefined ? Infinity : Math.max(0, times);
        if (this.size === 0) {
            if (EMPTY_REPEAT) {
                return EMPTY_REPEAT;
            }
            EMPTY_REPEAT = this;
        }
    }
    if (IndexedSeq$$1)
        Repeat.__proto__ = IndexedSeq$$1;
    Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
    Repeat.prototype.constructor = Repeat;
    Repeat.prototype.toString = function toString() {
        if (this.size === 0) {
            return 'Repeat []';
        }
        return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };
    Repeat.prototype.get = function get(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
    };
    Repeat.prototype.includes = function includes(searchValue) {
        return is(this._value, searchValue);
    };
    Repeat.prototype.slice = function slice(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size)
            ? this
            : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };
    Repeat.prototype.reverse = function reverse() {
        return this;
    };
    Repeat.prototype.indexOf = function indexOf(searchValue) {
        if (is(this._value, searchValue)) {
            return 0;
        }
        return -1;
    };
    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
        if (is(this._value, searchValue)) {
            return this.size;
        }
        return -1;
    };
    Repeat.prototype.__iterate = function __iterate(fn, reverse) {
        var size = this.size;
        var i = 0;
        while (i !== size) {
            if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
                break;
            }
        }
        return i;
    };
    Repeat.prototype.__iterator = function __iterator(type, reverse) {
        var this$1 = this;
        var size = this.size;
        var i = 0;
        return new Iterator(function () {
            return i === size
                ? iteratorDone()
                : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);
        });
    };
    Repeat.prototype.equals = function equals(other) {
        return other instanceof Repeat
            ? is(this._value, other._value)
            : deepEqual(other);
    };
    return Repeat;
}(IndexedSeq));
var EMPTY_REPEAT;
function fromJS(value, converter) {
    return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, { '': value });
}
function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
    var toSeq = Array.isArray(value)
        ? IndexedSeq
        : isPlainObj(value)
            ? KeyedSeq
            : null;
    if (toSeq) {
        if (~stack.indexOf(value)) {
            throw new TypeError('Cannot convert circular structure to Immutable');
        }
        stack.push(value);
        keyPath && key !== '' && keyPath.push(key);
        var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }), keyPath && keyPath.slice());
        stack.pop();
        keyPath && keyPath.pop();
        return converted;
    }
    return value;
}
function defaultConverter(k, v) {
    return isKeyed(v) ? v.toMap() : v.toList();
}
var version$1 = "4.0.0-rc.11";
var Immutable = {
    version: version$1,
    Collection: Collection,
    // Note: Iterable is deprecated
    Iterable: Collection,
    Seq: Seq,
    Map: Map$1,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set$1,
    OrderedSet: OrderedSet,
    Record: Record,
    Range: Range,
    Repeat: Repeat,
    is: is,
    fromJS: fromJS,
    hash: hash,
    isImmutable: isImmutable,
    isCollection: isCollection,
    isKeyed: isKeyed,
    isIndexed: isIndexed,
    isAssociative: isAssociative,
    isOrdered: isOrdered,
    isValueObject: isValueObject,
    isSeq: isSeq,
    isList: isList,
    isMap: isMap,
    isOrderedMap: isOrderedMap,
    isStack: isStack,
    isSet: isSet,
    isOrderedSet: isOrderedSet,
    isRecord: isRecord,
    get: get,
    getIn: getIn,
    has: has,
    hasIn: hasIn,
    merge: merge$1,
    mergeDeep: mergeDeep,
    mergeWith: mergeWith$1,
    mergeDeepWith: mergeDeepWith,
    remove: remove,
    removeIn: removeIn,
    set: set,
    setIn: setIn,
    update: update,
    updateIn: updateIn,
};

var OptionTypes;
(function (OptionTypes) {
    OptionTypes[OptionTypes["IGNORED_LABELS"] = 0] = "IGNORED_LABELS";
    OptionTypes[OptionTypes["ACCESSED_NODES"] = 1] = "ACCESSED_NODES";
    OptionTypes[OptionTypes["ARGUMENTS_VARIABLES"] = 2] = "ARGUMENTS_VARIABLES";
    OptionTypes[OptionTypes["ASSIGNED_NODES"] = 3] = "ASSIGNED_NODES";
    OptionTypes[OptionTypes["IGNORE_BREAK_STATEMENTS"] = 4] = "IGNORE_BREAK_STATEMENTS";
    OptionTypes[OptionTypes["IGNORE_RETURN_AWAIT_YIELD"] = 5] = "IGNORE_RETURN_AWAIT_YIELD";
    OptionTypes[OptionTypes["NODES_CALLED_AT_PATH_WITH_OPTIONS"] = 6] = "NODES_CALLED_AT_PATH_WITH_OPTIONS";
    OptionTypes[OptionTypes["REPLACED_VARIABLE_INITS"] = 7] = "REPLACED_VARIABLE_INITS";
    OptionTypes[OptionTypes["RETURN_EXPRESSIONS_ACCESSED_AT_PATH"] = 8] = "RETURN_EXPRESSIONS_ACCESSED_AT_PATH";
    OptionTypes[OptionTypes["RETURN_EXPRESSIONS_ASSIGNED_AT_PATH"] = 9] = "RETURN_EXPRESSIONS_ASSIGNED_AT_PATH";
    OptionTypes[OptionTypes["RETURN_EXPRESSIONS_CALLED_AT_PATH"] = 10] = "RETURN_EXPRESSIONS_CALLED_AT_PATH";
})(OptionTypes || (OptionTypes = {}));
const RESULT_KEY = {};
class ExecutionPathOptions {
    static create() {
        return new this(Immutable.Map());
    }
    constructor(optionValues) {
        this.optionValues = optionValues;
    }
    addAccessedNodeAtPath(path, node) {
        return this.setIn([OptionTypes.ACCESSED_NODES, node, ...path, RESULT_KEY], true);
    }
    addAccessedReturnExpressionAtPath(path, callExpression) {
        return this.setIn([OptionTypes.RETURN_EXPRESSIONS_ACCESSED_AT_PATH, callExpression, ...path, RESULT_KEY], true);
    }
    addAssignedNodeAtPath(path, node) {
        return this.setIn([OptionTypes.ASSIGNED_NODES, node, ...path, RESULT_KEY], true);
    }
    addAssignedReturnExpressionAtPath(path, callExpression) {
        return this.setIn([OptionTypes.RETURN_EXPRESSIONS_ASSIGNED_AT_PATH, callExpression, ...path, RESULT_KEY], true);
    }
    addCalledNodeAtPathWithOptions(path, node, callOptions) {
        return this.setIn([OptionTypes.NODES_CALLED_AT_PATH_WITH_OPTIONS, node, ...path, RESULT_KEY, callOptions], true);
    }
    addCalledReturnExpressionAtPath(path, callExpression) {
        return this.setIn([OptionTypes.RETURN_EXPRESSIONS_CALLED_AT_PATH, callExpression, ...path, RESULT_KEY], true);
    }
    getArgumentsVariables() {
        return (this.get(OptionTypes.ARGUMENTS_VARIABLES) || []);
    }
    getHasEffectsWhenCalledOptions() {
        return this.setIgnoreReturnAwaitYield()
            .setIgnoreBreakStatements(false)
            .setIgnoreNoLabels();
    }
    getReplacedVariableInit(variable) {
        return this.optionValues.getIn([OptionTypes.REPLACED_VARIABLE_INITS, variable]);
    }
    hasNodeBeenAccessedAtPath(path, node) {
        return this.optionValues.getIn([OptionTypes.ACCESSED_NODES, node, ...path, RESULT_KEY]);
    }
    hasNodeBeenAssignedAtPath(path, node) {
        return this.optionValues.getIn([OptionTypes.ASSIGNED_NODES, node, ...path, RESULT_KEY]);
    }
    hasNodeBeenCalledAtPathWithOptions(path, node, callOptions) {
        const previousCallOptions = this.optionValues.getIn([
            OptionTypes.NODES_CALLED_AT_PATH_WITH_OPTIONS,
            node,
            ...path,
            RESULT_KEY
        ]);
        return (previousCallOptions &&
            previousCallOptions.find((_, otherCallOptions) => otherCallOptions.equals(callOptions)));
    }
    hasReturnExpressionBeenAccessedAtPath(path, callExpression) {
        return this.optionValues.getIn([
            OptionTypes.RETURN_EXPRESSIONS_ACCESSED_AT_PATH,
            callExpression,
            ...path,
            RESULT_KEY
        ]);
    }
    hasReturnExpressionBeenAssignedAtPath(path, callExpression) {
        return this.optionValues.getIn([
            OptionTypes.RETURN_EXPRESSIONS_ASSIGNED_AT_PATH,
            callExpression,
            ...path,
            RESULT_KEY
        ]);
    }
    hasReturnExpressionBeenCalledAtPath(path, callExpression) {
        return this.optionValues.getIn([
            OptionTypes.RETURN_EXPRESSIONS_CALLED_AT_PATH,
            callExpression,
            ...path,
            RESULT_KEY
        ]);
    }
    ignoreBreakStatements() {
        return this.get(OptionTypes.IGNORE_BREAK_STATEMENTS);
    }
    ignoreLabel(labelName) {
        return this.optionValues.getIn([OptionTypes.IGNORED_LABELS, labelName]);
    }
    ignoreReturnAwaitYield() {
        return this.get(OptionTypes.IGNORE_RETURN_AWAIT_YIELD);
    }
    replaceVariableInit(variable, init) {
        return this.setIn([OptionTypes.REPLACED_VARIABLE_INITS, variable], init);
    }
    setArgumentsVariables(variables) {
        return this.set(OptionTypes.ARGUMENTS_VARIABLES, variables);
    }
    setIgnoreBreakStatements(value = true) {
        return this.set(OptionTypes.IGNORE_BREAK_STATEMENTS, value);
    }
    setIgnoreLabel(labelName) {
        return this.setIn([OptionTypes.IGNORED_LABELS, labelName], true);
    }
    setIgnoreNoLabels() {
        return this.remove(OptionTypes.IGNORED_LABELS);
    }
    setIgnoreReturnAwaitYield(value = true) {
        return this.set(OptionTypes.IGNORE_RETURN_AWAIT_YIELD, value);
    }
    get(option) {
        return this.optionValues.get(option);
    }
    remove(option) {
        return new ExecutionPathOptions(this.optionValues.remove(option));
    }
    set(option, value) {
        return new ExecutionPathOptions(this.optionValues.set(option, value));
    }
    setIn(optionPath, value) {
        return new ExecutionPathOptions(this.optionValues.setIn(optionPath, value));
    }
}

const keys = {
    Literal: [],
    Program: ['body']
};
function getAndCreateKeys(esTreeNode) {
    keys[esTreeNode.type] = Object.keys(esTreeNode).filter(key => typeof esTreeNode[key] === 'object');
    return keys[esTreeNode.type];
}

const NEW_EXECUTION_PATH = ExecutionPathOptions.create();
class NodeBase {
    constructor(esTreeNode, parent, parentScope) {
        this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
        this.parent = parent;
        this.context = parent.context;
        this.createScope(parentScope);
        this.parseNode(esTreeNode);
        this.initialise();
        this.context.magicString.addSourcemapLocation(this.start);
        this.context.magicString.addSourcemapLocation(this.end);
    }
    /**
     * Override this to bind assignments to variables and do any initialisations that
     * require the scopes to be populated with variables.
     */
    bind() {
        for (const key of this.keys) {
            const value = this[key];
            if (value === null || key === 'annotations')
                continue;
            if (Array.isArray(value)) {
                for (const child of value) {
                    if (child !== null)
                        child.bind();
                }
            }
            else {
                value.bind();
            }
        }
    }
    /**
     * Override if this node should receive a different scope than the parent scope.
     */
    createScope(parentScope) {
        this.scope = parentScope;
    }
    declare(_kind, _init) { }
    deoptimizePath(_path) { }
    getLiteralValueAtPath(_path, _recursionTracker, _origin) {
        return UNKNOWN_VALUE;
    }
    getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {
        return UNKNOWN_EXPRESSION;
    }
    hasEffects(options) {
        for (const key of this.keys) {
            const value = this[key];
            if (value === null || key === 'annotations')
                continue;
            if (Array.isArray(value)) {
                for (const child of value) {
                    if (child !== null && child.hasEffects(options))
                        return true;
                }
            }
            else if (value.hasEffects(options))
                return true;
        }
        return false;
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 0;
    }
    hasEffectsWhenAssignedAtPath(_path, _options) {
        return true;
    }
    hasEffectsWhenCalledAtPath(_path, _callOptions, _options) {
        return true;
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        for (const key of this.keys) {
            const value = this[key];
            if (value === null || key === 'annotations')
                continue;
            if (Array.isArray(value)) {
                for (const child of value) {
                    if (child !== null)
                        child.include(includeAllChildrenRecursively);
                }
            }
            else {
                value.include(includeAllChildrenRecursively);
            }
        }
    }
    includeWithAllDeclaredVariables(includeAllChildrenRecursively) {
        this.include(includeAllChildrenRecursively);
    }
    /**
     * Override to perform special initialisation steps after the scope is initialised
     */
    initialise() {
        this.included = false;
    }
    insertSemicolon(code) {
        if (code.original[this.end - 1] !== ';') {
            code.appendLeft(this.end, ';');
        }
    }
    locate() {
        // useful for debugging
        const location = locate(this.context.code, this.start, { offsetLine: 1 });
        location.file = this.context.fileName;
        location.toString = () => JSON.stringify(location);
        return location;
    }
    parseNode(esTreeNode) {
        for (const key of Object.keys(esTreeNode)) {
            // That way, we can override this function to add custom initialisation and then call super.parseNode
            if (this.hasOwnProperty(key))
                continue;
            const value = esTreeNode[key];
            if (typeof value !== 'object' || value === null || key === 'annotations') {
                this[key] = value;
            }
            else if (Array.isArray(value)) {
                this[key] = [];
                for (const child of value) {
                    this[key].push(child === null
                        ? null
                        : new (this.context.nodeConstructors[child.type] ||
                            this.context.nodeConstructors.UnknownNode)(child, this, this.scope));
                }
            }
            else {
                this[key] = new (this.context.nodeConstructors[value.type] ||
                    this.context.nodeConstructors.UnknownNode)(value, this, this.scope);
            }
        }
    }
    render(code, options) {
        for (const key of this.keys) {
            const value = this[key];
            if (value === null || key === 'annotations')
                continue;
            if (Array.isArray(value)) {
                for (const child of value) {
                    if (child !== null)
                        child.render(code, options);
                }
            }
            else {
                value.render(code, options);
            }
        }
    }
    shouldBeIncluded() {
        return this.included || this.hasEffects(NEW_EXECUTION_PATH);
    }
    toString() {
        return this.context.code.slice(this.start, this.end);
    }
}

class ClassNode extends NodeBase {
    createScope(parentScope) {
        this.scope = new ChildScope(parentScope);
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 1;
    }
    hasEffectsWhenAssignedAtPath(path, _options) {
        return path.length > 1;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        return (this.body.hasEffectsWhenCalledAtPath(path, callOptions, options) ||
            (this.superClass !== null &&
                this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, options)));
    }
    initialise() {
        this.included = false;
        if (this.id !== null) {
            this.id.declare('class', this);
        }
    }
}

class ClassDeclaration extends ClassNode {
    initialise() {
        super.initialise();
        if (this.id !== null) {
            this.id.variable.isId = true;
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope
                .parent);
        }
        super.parseNode(esTreeNode);
    }
    render(code, options) {
        if (options.format === 'system' && this.id && this.id.variable.exportName) {
            code.appendLeft(this.end, ` exports('${this.id.variable.exportName}', ${this.id.variable.getName()});`);
        }
        super.render(code, options);
    }
}

const getParameterVariable = (path, options) => {
    const firstArgNum = parseInt(path[0], 10);
    return ((firstArgNum < options.getArgumentsVariables().length &&
        options.getArgumentsVariables()[firstArgNum]) ||
        UNKNOWN_EXPRESSION);
};
class ArgumentsVariable extends LocalVariable {
    constructor(parameters, context) {
        super('arguments', null, UNKNOWN_EXPRESSION, context);
        this.parameters = parameters;
    }
    deoptimizePath(path) {
        const firstArgNum = parseInt(path[0], 10);
        if (path.length > 0) {
            if (firstArgNum >= 0 && this.parameters[firstArgNum]) {
                this.parameters[firstArgNum].deoptimizePath(path.slice(1));
            }
        }
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return (path.length > 1 &&
            getParameterVariable(path, options).hasEffectsWhenAccessedAtPath(path.slice(1), options));
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return (path.length === 0 ||
            this.included ||
            getParameterVariable(path, options).hasEffectsWhenAssignedAtPath(path.slice(1), options));
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length === 0) {
            return true;
        }
        return getParameterVariable(path, options).hasEffectsWhenCalledAtPath(path.slice(1), callOptions, options);
    }
}

class ThisVariable extends LocalVariable {
    constructor(context) {
        super('this', null, null, context);
    }
    _getInit(options) {
        return options.getReplacedVariableInit(this) || UNKNOWN_EXPRESSION;
    }
    getLiteralValueAtPath() {
        return UNKNOWN_VALUE;
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return (this._getInit(options).hasEffectsWhenAccessedAtPath(path, options) ||
            super.hasEffectsWhenAccessedAtPath(path, options));
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return (this._getInit(options).hasEffectsWhenAssignedAtPath(path, options) ||
            super.hasEffectsWhenAssignedAtPath(path, options));
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        return (this._getInit(options).hasEffectsWhenCalledAtPath(path, callOptions, options) ||
            super.hasEffectsWhenCalledAtPath(path, callOptions, options));
    }
}

class ParameterScope extends ChildScope {
    constructor(parent, context) {
        super(parent);
        this.parameters = [];
        this.context = context;
        this.hoistedBodyVarScope = new ChildScope(this);
    }
    /**
     * Adds a parameter to this scope. Parameters must be added in the correct
     * order, e.g. from left to right.
     */
    addParameterDeclaration(identifier) {
        const name = identifier.name;
        let variable;
        if (name in this.hoistedBodyVarScope.variables) {
            variable = this.hoistedBodyVarScope.variables[name];
            variable.addDeclaration(identifier, null);
        }
        else {
            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
        }
        this.variables[name] = variable;
        this.parameters.push(variable);
        return variable;
    }
    getParameterVariables() {
        return this.parameters;
    }
}

class ReturnValueScope extends ParameterScope {
    constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.returnExpressions = [];
    }
    addReturnExpression(expression) {
        this.returnExpressions.push(expression);
    }
    getReturnExpression() {
        if (this.returnExpression === null)
            this.updateReturnExpression();
        return this.returnExpression;
    }
    updateReturnExpression() {
        if (this.returnExpressions.length === 1) {
            this.returnExpression = this.returnExpressions[0];
        }
        else {
            this.returnExpression = UNKNOWN_EXPRESSION;
            for (const expression of this.returnExpressions) {
                expression.deoptimizePath(UNKNOWN_PATH);
            }
        }
    }
}

class FunctionScope extends ReturnValueScope {
    constructor(parent, context) {
        super(parent, context);
        this.variables.arguments = new ArgumentsVariable(super.getParameterVariables(), context);
        this.variables.this = new ThisVariable(context);
    }
    findLexicalBoundary() {
        return this;
    }
    getOptionsWhenCalledWith({ args, withNew }, options) {
        return options
            .replaceVariableInit(this.variables.this, withNew ? new UnknownObjectExpression() : UNKNOWN_EXPRESSION)
            .setArgumentsVariables(args.map((parameter, index) => super.getParameterVariables()[index] || parameter));
    }
}

class FunctionNode extends NodeBase {
    createScope(parentScope) {
        this.scope = new FunctionScope(parentScope, this.context);
    }
    deoptimizePath(path) {
        if (path.length === 1) {
            if (path[0] === 'prototype') {
                this.isPrototypeDeoptimized = true;
            }
            else if (path[0] === UNKNOWN_KEY) {
                this.isPrototypeDeoptimized = true;
                // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
                // which means the return expression needs to be reassigned as well
                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
            }
        }
    }
    getReturnExpressionWhenCalledAtPath(path) {
        return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;
    }
    hasEffects(options) {
        return this.id !== null && this.id.hasEffects(options);
    }
    hasEffectsWhenAccessedAtPath(path) {
        if (path.length <= 1) {
            return false;
        }
        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
    }
    hasEffectsWhenAssignedAtPath(path) {
        if (path.length <= 1) {
            return false;
        }
        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length > 0) {
            return true;
        }
        const innerOptions = this.scope.getOptionsWhenCalledWith(callOptions, options);
        for (const param of this.params) {
            if (param.hasEffects(innerOptions))
                return true;
        }
        return this.body.hasEffects(innerOptions);
    }
    include(includeAllChildrenRecursively) {
        this.scope.variables.arguments.include();
        super.include(includeAllChildrenRecursively);
    }
    initialise() {
        this.included = false;
        this.isPrototypeDeoptimized = false;
        if (this.id !== null) {
            this.id.declare('function', this);
        }
        for (const param of this.params) {
            param.declare('parameter', UNKNOWN_EXPRESSION);
        }
        this.body.addImplicitReturnExpressionToScope();
    }
    parseNode(esTreeNode) {
        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        super.parseNode(esTreeNode);
    }
}
FunctionNode.prototype.preventChildBlockScope = true;

class FunctionDeclaration extends FunctionNode {
    initialise() {
        super.initialise();
        if (this.id !== null) {
            this.id.variable.isId = true;
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope
                .parent);
        }
        super.parseNode(esTreeNode);
    }
}

const WHITESPACE = /\s/;
// The header ends at the first non-white-space after "default"
function getDeclarationStart(code, start = 0) {
    start = findFirstOccurrenceOutsideComment(code, 'default', start) + 7;
    while (WHITESPACE.test(code[start]))
        start++;
    return start;
}
function getIdInsertPosition(code, declarationKeyword, start = 0) {
    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, '{', declarationEnd));
    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
    if (generatorStarPos === -1) {
        return declarationEnd;
    }
    return declarationEnd + generatorStarPos + 1;
}
class ExportDefaultDeclaration extends NodeBase {
    include(includeAllChildrenRecursively) {
        super.include(includeAllChildrenRecursively);
        if (includeAllChildrenRecursively) {
            this.context.includeVariable(this.variable);
        }
    }
    initialise() {
        this.included = false;
        const declaration = this.declaration;
        this.declarationName =
            (declaration.id && declaration.id.name) || this.declaration.name;
        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
        this.context.addExport(this);
    }
    render(code, options, { start, end } = BLANK) {
        const declarationStart = getDeclarationStart(code.original, this.start);
        if (this.declaration instanceof FunctionDeclaration) {
            this.renderNamedDeclaration(code, declarationStart, 'function', this.declaration.id === null, options);
        }
        else if (this.declaration instanceof ClassDeclaration) {
            this.renderNamedDeclaration(code, declarationStart, 'class', this.declaration.id === null, options);
        }
        else if (this.variable.getOriginalVariable() !== this.variable) {
            // Remove altogether to prevent re-declaring the same variable
            if (options.format === 'system' && this.variable.exportName) {
                code.overwrite(start, end, `exports('${this.variable.exportName}', ${this.variable.getName()});`);
            }
            else {
                treeshakeNode(this, code, start, end);
            }
            return;
        }
        else if (this.variable.included) {
            this.renderVariableDeclaration(code, declarationStart, options);
        }
        else {
            code.remove(this.start, declarationStart);
            this.declaration.render(code, options, {
                isCalleeOfRenderedParent: false,
                renderedParentType: ExpressionStatement
            });
            if (code.original[this.end - 1] !== ';') {
                code.appendLeft(this.end, ';');
            }
            return;
        }
        this.declaration.render(code, options);
    }
    renderNamedDeclaration(code, declarationStart, declarationKeyword, needsId, options) {
        const name = this.variable.getName();
        // Remove `export default`
        code.remove(this.start, declarationStart);
        if (needsId) {
            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, declarationStart), ` ${name}`);
        }
        if (options.format === 'system' &&
            this.declaration instanceof ClassDeclaration &&
            this.variable.exportName) {
            code.appendLeft(this.end, ` exports('${this.variable.exportName}', ${name});`);
        }
    }
    renderVariableDeclaration(code, declarationStart, options) {
        const systemBinding = options.format === 'system' && this.variable.exportName
            ? `exports('${this.variable.exportName}', `
            : '';
        code.overwrite(this.start, declarationStart, `${options.varOrConst} ${this.variable.getName()} = ${systemBinding}`);
        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
        if (systemBinding) {
            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
        }
        else if (!hasTrailingSemicolon) {
            code.appendLeft(this.end, ';');
        }
    }
}
ExportDefaultDeclaration.prototype.needsBoundaries = true;

function isReference(node, parent) {
    if (node.type === 'MemberExpression') {
        return !node.computed && isReference(node.object, node);
    }
    if (node.type === 'Identifier') {
        switch (parent.type) {
            // disregard `bar` in `foo.bar`
            case 'MemberExpression': return parent.computed || node === parent.object;
            // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
            case 'MethodDefinition': return parent.computed;
            // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
            case 'Property': return parent.computed || node === parent.value;
            // disregard the `bar` in `export { foo as bar }`
            case 'ExportSpecifier': return node === parent.local;
            // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
            case 'LabeledStatement':
            case 'BreakStatement':
            case 'ContinueStatement': return false;
            default: return true;
        }
    }
    return false;
}

class Identifier$1 extends NodeBase {
    addExportedVariables(variables) {
        if (this.variable !== null && this.variable.exportName) {
            variables.push(this.variable);
        }
    }
    bind() {
        if (this.bound)
            return;
        this.bound = true;
        if (this.variable === null && isReference(this, this.parent)) {
            this.variable = this.scope.findVariable(this.name);
            this.variable.addReference(this);
        }
        if (this.variable !== null &&
            this.variable.isLocal &&
            this.variable.additionalInitializers !== null) {
            this.variable.consolidateInitializers();
        }
    }
    declare(kind, init) {
        switch (kind) {
            case 'var':
            case 'function':
                this.variable = this.scope.addDeclaration(this, this.context, init, true);
                break;
            case 'let':
            case 'const':
            case 'class':
                this.variable = this.scope.addDeclaration(this, this.context, init, false);
                break;
            case 'parameter':
                this.variable = this.scope.addParameterDeclaration(this);
                break;
            default:
                throw new Error(`Unexpected identifier kind ${kind}.`);
        }
    }
    deoptimizePath(path) {
        if (!this.bound)
            this.bind();
        if (this.variable !== null) {
            if (path.length === 0 &&
                this.name in this.context.importDescriptions &&
                !this.scope.contains(this.name)) {
                this.disallowImportReassignment();
            }
            this.variable.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (!this.bound)
            this.bind();
        if (this.variable !== null) {
            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
        }
        return UNKNOWN_VALUE;
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (!this.bound)
            this.bind();
        if (this.variable !== null) {
            return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
        }
        return UNKNOWN_EXPRESSION;
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return this.variable !== null && this.variable.hasEffectsWhenAccessedAtPath(path, options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return !this.variable || this.variable.hasEffectsWhenAssignedAtPath(path, options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        return !this.variable || this.variable.hasEffectsWhenCalledAtPath(path, callOptions, options);
    }
    include(_includeAllChildrenRecursively) {
        if (!this.included) {
            this.included = true;
            if (this.variable !== null) {
                this.context.includeVariable(this.variable);
            }
        }
    }
    initialise() {
        this.included = false;
        this.bound = false;
        // To avoid later shape mutations
        if (!this.variable) {
            this.variable = null;
        }
    }
    render(code, _options, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
        if (this.variable) {
            const name = this.variable.getName();
            if (name !== this.name) {
                code.overwrite(this.start, this.end, name, {
                    contentOnly: true,
                    storeName: true
                });
                if (isShorthandProperty) {
                    code.prependRight(this.start, `${this.name}: `);
                }
            }
            // In strict mode, any variable named "eval" must be the actual "eval" function
            if (name === 'eval' &&
                renderedParentType === CallExpression &&
                isCalleeOfRenderedParent) {
                code.appendRight(this.start, '0, ');
            }
        }
    }
    disallowImportReassignment() {
        this.context.error({
            code: 'ILLEGAL_REASSIGNMENT',
            message: `Illegal reassignment to import '${this.name}'`
        }, this.start);
    }
}

class ExportDefaultVariable extends LocalVariable {
    constructor(name, exportDefaultDeclaration, context) {
        super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);
        // Not initialised during construction
        this.originalId = null;
        this.originalVariable = null;
        const declaration = exportDefaultDeclaration.declaration;
        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) &&
            declaration.id) {
            this.hasId = true;
            this.originalId = declaration.id;
        }
        else if (declaration instanceof Identifier$1) {
            this.originalId = declaration;
        }
    }
    addReference(identifier) {
        if (!this.hasId) {
            this.name = identifier.name;
        }
    }
    getAssignedVariableName() {
        return (this.originalId && this.originalId.name) || null;
    }
    getName() {
        const original = this.getOriginalVariable();
        if (original === this) {
            return super.getName();
        }
        else {
            return original.getName();
        }
    }
    getOriginalVariable() {
        if (this.originalVariable === null) {
            if (!this.originalId || (!this.hasId && this.originalId.variable.isReassigned)) {
                this.originalVariable = this;
            }
            else {
                const assignedOriginal = this.originalId.variable;
                this.originalVariable =
                    assignedOriginal instanceof ExportDefaultVariable
                        ? assignedOriginal.getOriginalVariable()
                        : assignedOriginal;
            }
        }
        return this.originalVariable;
    }
    setRenderNames(baseName, name) {
        const original = this.getOriginalVariable();
        if (original === this) {
            super.setRenderNames(baseName, name);
        }
        else {
            original.setRenderNames(baseName, name);
        }
    }
    setSafeName(name) {
        const original = this.getOriginalVariable();
        if (original === this) {
            super.setSafeName(name);
        }
        else {
            original.setSafeName(name);
        }
    }
}
ExportDefaultVariable.prototype.getBaseVariableName = ExportDefaultVariable.prototype.getName;
ExportDefaultVariable.prototype.isDefault = true;

const MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';
const INTEROP_DEFAULT_VARIABLE = '_interopDefault';

class ExportShimVariable extends Variable {
    constructor(module) {
        super(MISSING_EXPORT_SHIM_VARIABLE);
        this.module = module;
    }
}

const pureFunctions = {};
const arrayTypes = 'Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array'.split(' ');
const simdTypes = 'Int8x16 Int16x8 Int32x4 Float32x4 Float64x2'.split(' ');
const simdMethods = 'abs add and bool check div equal extractLane fromFloat32x4 fromFloat32x4Bits fromFloat64x2 fromFloat64x2Bits fromInt16x8Bits fromInt32x4 fromInt32x4Bits fromInt8x16Bits greaterThan greaterThanOrEqual lessThan lessThanOrEqual load max maxNum min minNum mul neg not notEqual or reciprocalApproximation reciprocalSqrtApproximation replaceLane select selectBits shiftLeftByScalar shiftRightArithmeticByScalar shiftRightLogicalByScalar shuffle splat sqrt store sub swizzle xor'.split(' ');
const allSimdMethods = [];
simdTypes.forEach(t => {
    simdMethods.forEach(m => {
        allSimdMethods.push(`SIMD.${t}.${m}`);
    });
});
[
    'Array.isArray',
    'Error',
    'EvalError',
    'InternalError',
    'RangeError',
    'ReferenceError',
    'SyntaxError',
    'TypeError',
    'URIError',
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'escape',
    'unescape',
    'Object',
    'Object.create',
    'Object.getNotifier',
    'Object.getOwn',
    'Object.getOwnPropertyDescriptor',
    'Object.getOwnPropertyNames',
    'Object.getOwnPropertySymbols',
    'Object.getPrototypeOf',
    'Object.is',
    'Object.isExtensible',
    'Object.isFrozen',
    'Object.isSealed',
    'Object.keys',
    'Boolean',
    'Number',
    'Number.isFinite',
    'Number.isInteger',
    'Number.isNaN',
    'Number.isSafeInteger',
    'Number.parseFloat',
    'Number.parseInt',
    'Symbol',
    'Symbol.for',
    'Symbol.keyFor',
    'Math.abs',
    'Math.acos',
    'Math.acosh',
    'Math.asin',
    'Math.asinh',
    'Math.atan',
    'Math.atan2',
    'Math.atanh',
    'Math.cbrt',
    'Math.ceil',
    'Math.clz32',
    'Math.cos',
    'Math.cosh',
    'Math.exp',
    'Math.expm1',
    'Math.floor',
    'Math.fround',
    'Math.hypot',
    'Math.imul',
    'Math.log',
    'Math.log10',
    'Math.log1p',
    'Math.log2',
    'Math.max',
    'Math.min',
    'Math.pow',
    'Math.random',
    'Math.round',
    'Math.sign',
    'Math.sin',
    'Math.sinh',
    'Math.sqrt',
    'Math.tan',
    'Math.tanh',
    'Math.trunc',
    'Date',
    'Date.UTC',
    'Date.now',
    'Date.parse',
    'String',
    'String.fromCharCode',
    'String.fromCodePoint',
    'String.raw',
    'RegExp',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'ArrayBuffer',
    'ArrayBuffer.isView',
    'DataView',
    'Promise.all',
    'Promise.race',
    'Promise.resolve',
    'Intl.Collator',
    'Intl.Collator.supportedLocalesOf',
    'Intl.DateTimeFormat',
    'Intl.DateTimeFormat.supportedLocalesOf',
    'Intl.NumberFormat',
    'Intl.NumberFormat.supportedLocalesOf'
    // TODO properties of e.g. window...
]
    .concat(arrayTypes, arrayTypes.map(t => `${t}.from`), arrayTypes.map(t => `${t}.of`), simdTypes.map(t => `SIMD.${t}`), allSimdMethods)
    .forEach(name => (pureFunctions[name] = true));

class GlobalVariable extends Variable {
    hasEffectsWhenAccessedAtPath(path) {
        // path.length == 0 can also have an effect but we postpone this for now
        return (path.length > 0 &&
            !this.isPureFunctionMember(path) &&
            !(this.name === 'Reflect' && path.length === 1));
    }
    hasEffectsWhenCalledAtPath(path) {
        return !pureFunctions[[this.name, ...path].join('.')];
    }
    isPureFunctionMember(path) {
        return (pureFunctions[[this.name, ...path].join('.')] ||
            (path.length >= 1 && pureFunctions[[this.name, ...path.slice(0, -1)].join('.')]) ||
            (path.length >= 2 &&
                pureFunctions[[this.name, ...path.slice(0, -2)].join('.')] &&
                path[path.length - 2] === 'prototype'));
    }
}

// Verified on IE 6/7 that these keywords can't be used for object properties without escaping:
//   break case catch class const continue debugger default delete do
//   else enum export extends false finally for function if import
//   in instanceof new null return super switch this throw true
//   try typeof var void while with
const RESERVED_NAMES = Object.assign(Object.create(null), {
    await: true,
    break: true,
    case: true,
    catch: true,
    class: true,
    const: true,
    continue: true,
    debugger: true,
    default: true,
    delete: true,
    do: true,
    else: true,
    enum: true,
    eval: true,
    export: true,
    extends: true,
    false: true,
    finally: true,
    for: true,
    function: true,
    if: true,
    implements: true,
    import: true,
    in: true,
    instanceof: true,
    interface: true,
    let: true,
    new: true,
    null: true,
    package: true,
    private: true,
    protected: true,
    public: true,
    return: true,
    static: true,
    super: true,
    switch: true,
    this: true,
    throw: true,
    true: true,
    try: true,
    typeof: true,
    undefined: true,
    var: true,
    void: true,
    while: true,
    with: true,
    yield: true
});
const NONE = {};
const EXPORTS = { exports: true };
const RESERVED_NAMES_BY_FORMAT = {
    amd: { formatGlobals: EXPORTS, forbiddenNames: RESERVED_NAMES },
    cjs: {
        forbiddenNames: RESERVED_NAMES,
        formatGlobals: { exports: true, module: true, [INTEROP_DEFAULT_VARIABLE]: true }
    },
    es: { formatGlobals: NONE, forbiddenNames: RESERVED_NAMES },
    iife: { formatGlobals: EXPORTS, forbiddenNames: RESERVED_NAMES },
    system: {
        forbiddenNames: Object.assign(Object.create(null), RESERVED_NAMES, EXPORTS),
        formatGlobals: NONE
    },
    umd: { formatGlobals: EXPORTS, forbiddenNames: RESERVED_NAMES }
};

class NamespaceVariable extends Variable {
    constructor(context) {
        super(context.getModuleName());
        this.memberVariables = Object.create(null);
        this.containsExternalNamespace = false;
        this.referencedEarly = false;
        this.references = [];
        this.context = context;
        this.module = context.module;
        for (const name of this.context.getExports().concat(this.context.getReexports())) {
            if (name[0] === '*' && name.length > 1)
                this.containsExternalNamespace = true;
            this.memberVariables[name] = this.context.traceExport(name);
        }
    }
    addReference(identifier) {
        this.references.push(identifier);
        this.name = identifier.name;
    }
    // This is only called if "UNKNOWN_PATH" is reassigned as in all other situations, either the
    // build fails due to an illegal namespace reassignment or MemberExpression already forwards
    // the reassignment to the right variable. This means we lost track of this variable and thus
    // need to reassign all exports.
    deoptimizePath() {
        for (const key in this.memberVariables) {
            this.memberVariables[key].deoptimizePath(UNKNOWN_PATH);
        }
    }
    include() {
        if (!this.included) {
            if (this.containsExternalNamespace) {
                this.context.error({
                    code: 'NAMESPACE_CANNOT_CONTAIN_EXTERNAL',
                    id: this.module.id,
                    message: `Cannot create an explicit namespace object for module "${this.context.getModuleName()}" because it contains a reexported external namespace`
                }, undefined);
            }
            this.included = true;
            for (const identifier of this.references) {
                if (identifier.context.getModuleExecIndex() <= this.context.getModuleExecIndex()) {
                    this.referencedEarly = true;
                    break;
                }
            }
            if (this.context.preserveModules) {
                for (const memberName of Object.keys(this.memberVariables))
                    this.memberVariables[memberName].include();
            }
            else {
                for (const memberName of Object.keys(this.memberVariables))
                    this.context.includeVariable(this.memberVariables[memberName]);
            }
        }
    }
    renderBlock(options) {
        const _ = options.compact ? '' : ' ';
        const n = options.compact ? '' : '\n';
        const t = options.indent;
        const members = Object.keys(this.memberVariables).map(name => {
            const original = this.memberVariables[name];
            if (this.referencedEarly || original.isReassigned) {
                return `${t}get ${name}${_}()${_}{${_}return ${original.getName()}${options.compact ? '' : ';'}${_}}`;
            }
            const safeName = RESERVED_NAMES[name] ? `'${name}'` : name;
            return `${t}${safeName}: ${original.getName()}`;
        });
        const name = this.getName();
        const callee = options.freeze ? `/*#__PURE__*/Object.freeze` : '';
        let output = `${options.varOrConst} ${name} = ${options.namespaceToStringTag
            ? `{${n}${members.join(`,${n}`)}${n}};`
            : `${callee}({${n}${members.join(`,${n}`)}${n}});`}`;
        if (options.namespaceToStringTag) {
            output += `${n}if${_}(typeof Symbol${_}!==${_}'undefined'${_}&&${_}Symbol.toStringTag)${n}`;
            output += `${t}Object.defineProperty(${name},${_}Symbol.toStringTag,${_}{${_}value:${_}'Module'${_}});${n}`;
            output += `else${n || ' '}`;
            output += `${t}Object.defineProperty(${name},${_}'toString',${_}{${_}value:${_}function${_}()${_}{${_}return${_}'[object Module]'${options.compact ? ';' : ''}${_}}${_}});${n}`;
            output += `${callee}(${name});`;
        }
        if (options.format === 'system' && this.exportName) {
            output += `${n}exports('${this.exportName}',${_}${name});`;
        }
        return output;
    }
    renderFirst() {
        return this.referencedEarly;
    }
}
NamespaceVariable.prototype.isNamespace = true;

const esModuleExport = `Object.defineProperty(exports, '__esModule', { value: true });`;
const compactEsModuleExport = `Object.defineProperty(exports,'__esModule',{value:true});`;

function getExportBlock(exports, dependencies, namedExportsMode, interop, compact, t, mechanism = 'return ') {
    const _ = compact ? '' : ' ';
    const n = compact ? '' : '\n';
    if (!namedExportsMode) {
        let local;
        exports.some(expt => {
            if (expt.exported === 'default') {
                local = expt.local;
                return true;
            }
            return false;
        });
        // search for reexported default otherwise
        if (!local) {
            dependencies.some(dep => {
                if (!dep.reexports)
                    return false;
                return dep.reexports.some(expt => {
                    if (expt.reexported === 'default') {
                        local = dep.namedExportsMode ? `${dep.name}.${expt.imported}` : dep.name;
                        return true;
                    }
                    return false;
                });
            });
        }
        return `${mechanism}${local};`;
    }
    let exportBlock = '';
    // star exports must always output first for precedence
    dependencies.forEach(({ name, reexports }) => {
        if (reexports && namedExportsMode) {
            reexports.forEach(specifier => {
                if (specifier.reexported === '*') {
                    if (!compact && exportBlock)
                        exportBlock += '\n';
                    exportBlock +=
                        `Object.keys(${name}).forEach(function${_}(key)${_}{${n}` +
                            `${t}Object.defineProperty(exports,${_}key,${_}{${n}` +
                            `${t}${t}enumerable:${_}true,${n}` +
                            `${t}${t}get:${_}function${_}()${_}{${n}` +
                            `${t}${t}${t}return ${name}[key];${n}` +
                            `${t}${t}}${n}${t}});${n}});`;
                }
            });
        }
    });
    dependencies.forEach(({ name, imports, reexports, isChunk, namedExportsMode: depNamedExportsMode }) => {
        if (reexports && namedExportsMode) {
            reexports.forEach(specifier => {
                if (specifier.imported === 'default' && !isChunk) {
                    const exportsNamesOrNamespace = (imports && imports.some(specifier => specifier.imported !== 'default')) ||
                        (reexports &&
                            reexports.some(specifier => specifier.imported !== 'default' && specifier.imported !== '*'));
                    const reexportsDefaultAsDefault = reexports &&
                        reexports.some(specifier => specifier.imported === 'default' && specifier.reexported === 'default');
                    if (exportBlock && !compact)
                        exportBlock += '\n';
                    if (exportsNamesOrNamespace || reexportsDefaultAsDefault)
                        exportBlock += `exports.${specifier.reexported}${_}=${_}${name}${interop !== false ? '__default' : '.default'};`;
                    else
                        exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;
                }
                else if (specifier.imported !== '*') {
                    if (exportBlock && !compact)
                        exportBlock += '\n';
                    const importName = specifier.imported === 'default' && !depNamedExportsMode
                        ? name
                        : `${name}.${specifier.imported}`;
                    exportBlock += specifier.needsLiveBinding
                        ? `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n}` +
                            `${t}enumerable:${_}true,${n}` +
                            `${t}get:${_}function${_}()${_}{${n}` +
                            `${t}${t}return ${importName};${n}${t}}${n}});`
                        : `exports.${specifier.reexported}${_}=${_}${importName};`;
                }
                else if (specifier.reexported !== '*') {
                    if (exportBlock && !compact)
                        exportBlock += '\n';
                    exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;
                }
            });
        }
    });
    exports.forEach(expt => {
        const lhs = `exports.${expt.exported}`;
        const rhs = expt.local;
        if (lhs === rhs) {
            return;
        }
        if (exportBlock && !compact)
            exportBlock += '\n';
        exportBlock += `${lhs}${_}=${_}${rhs};`;
    });
    return exportBlock;
}

function getInteropBlock(dependencies, options, varOrConst) {
    return dependencies
        .map(({ name, exportsNames, exportsDefault, namedExportsMode }) => {
        if (!namedExportsMode)
            return;
        if (!exportsDefault || options.interop === false)
            return null;
        if (exportsNames) {
            if (options.compact)
                return `${varOrConst} ${name}__default='default'in ${name}?${name}['default']:${name};`;
            return `${varOrConst} ${name}__default = 'default' in ${name} ? ${name}['default'] : ${name};`;
        }
        if (options.compact)
            return `${name}=${name}&&${name}.hasOwnProperty('default')?${name}['default']:${name};`;
        return `${name} = ${name} && ${name}.hasOwnProperty('default') ? ${name}['default'] : ${name};`;
    })
        .filter(Boolean)
        .join(options.compact ? '' : '\n');
}

const builtins$1 = {
    assert: true,
    buffer: true,
    console: true,
    constants: true,
    domain: true,
    events: true,
    http: true,
    https: true,
    os: true,
    path: true,
    process: true,
    punycode: true,
    querystring: true,
    stream: true,
    string_decoder: true,
    timers: true,
    tty: true,
    url: true,
    util: true,
    vm: true,
    zlib: true
};
// Creating a browser chunk that depends on Node.js built-in modules ('util'). You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins
function warnOnBuiltins(warn, dependencies) {
    const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins$1);
    if (!externalBuiltins.length)
        return;
    const detail = externalBuiltins.length === 1
        ? `module ('${externalBuiltins[0]}')`
        : `modules (${externalBuiltins
            .slice(0, -1)
            .map(name => `'${name}'`)
            .join(', ')} and '${externalBuiltins.slice(-1)}')`;
    warn({
        code: 'MISSING_NODE_BUILTINS',
        message: `Creating a browser bundle that depends on Node.js built-in ${detail}. You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins`,
        modules: externalBuiltins
    });
}

// TODO consider using improved AMD relative imports:
// https://requirejs.org/docs/api.html#modulenotes-urls
// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.
// The assumption is that this makes sense for all relative ids:
// https://requirejs.org/docs/api.html#jsfiles
function removeExtensionFromRelativeAmdId(id) {
    if (id[0] === '.' && id.endsWith('.js')) {
        return id.slice(0, -3);
    }
    return id;
}
function amd(magicString, { dependencies, dynamicImport, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, needsAmdModule, outro, varOrConst, warn }, options) {
    warnOnBuiltins(warn, dependencies);
    const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
    const args = dependencies.map(m => m.name);
    const n = options.compact ? '' : '\n';
    const _ = options.compact ? '' : ' ';
    if (namedExportsMode && hasExports) {
        args.unshift(`exports`);
        deps.unshift(`'exports'`);
    }
    if (dynamicImport) {
        args.unshift('require');
        deps.unshift(`'require'`);
    }
    if (needsAmdModule) {
        args.unshift('module');
        deps.unshift(`'module'`);
    }
    const amdOptions = options.amd || {};
    const params = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +
        (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
    const useStrict = options.strict !== false ? `${_}'use strict';` : ``;
    const define = amdOptions.define || 'define';
    const wrapperStart = `${define}(${params}function${_}(${args.join(`,${_}`)})${_}{${useStrict}${n}${n}`;
    // var foo__default = 'default' in foo ? foo['default'] : foo;
    const interopBlock = getInteropBlock(dependencies, options, varOrConst);
    if (interopBlock)
        magicString.prepend(interopBlock + n + n);
    if (intro)
        magicString.prepend(intro);
    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
    if (exportBlock)
        magicString.append(n + n + exportBlock);
    if (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule)
        magicString.append(`${n}${n}${options.compact ? compactEsModuleExport : esModuleExport}`);
    if (outro)
        magicString.append(outro);
    return magicString
        .indent(t)
        .append(n + n + '});')
        .prepend(wrapperStart);
}

function cjs(magicString, { dependencies, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, outro, varOrConst }, options) {
    const n = options.compact ? '' : '\n';
    const _ = options.compact ? '' : ' ';
    intro =
        (options.strict === false ? intro : `'use strict';${n}${n}${intro}`) +
            (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule
                ? `${options.compact ? compactEsModuleExport : esModuleExport}${n}${n}`
                : '');
    let needsInterop = false;
    const interop = options.interop !== false;
    let importBlock;
    let definingVariable = false;
    importBlock = '';
    for (const { id, namedExportsMode, isChunk, name, reexports, imports, exportsNames, exportsDefault } of dependencies) {
        if (!reexports && !imports) {
            if (importBlock) {
                importBlock += !options.compact || definingVariable ? `;${n}` : ',';
            }
            definingVariable = false;
            importBlock += `require('${id}')`;
        }
        else {
            importBlock +=
                options.compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${varOrConst} `;
            definingVariable = true;
            if (!interop || isChunk || !exportsDefault || !namedExportsMode) {
                importBlock += `${name}${_}=${_}require('${id}')`;
            }
            else {
                needsInterop = true;
                if (exportsNames)
                    importBlock += `${name}${_}=${_}require('${id}')${options.compact ? ',' : `;\n${varOrConst} `}${name}__default${_}=${_}${INTEROP_DEFAULT_VARIABLE}(${name})`;
                else
                    importBlock += `${name}${_}=${_}${INTEROP_DEFAULT_VARIABLE}(require('${id}'))`;
            }
        }
    }
    if (importBlock)
        importBlock += ';';
    if (needsInterop) {
        const ex = options.compact ? 'e' : 'ex';
        intro +=
            `function ${INTEROP_DEFAULT_VARIABLE}${_}(${ex})${_}{${_}return${_}` +
                `(${ex}${_}&&${_}(typeof ${ex}${_}===${_}'object')${_}&&${_}'default'${_}in ${ex})${_}` +
                `?${_}${ex}['default']${_}:${_}${ex}${options.compact ? '' : '; '}}${n}${n}`;
    }
    if (importBlock)
        intro += importBlock + n + n;
    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t, `module.exports${_}=${_}`);
    magicString.prepend(intro);
    if (exportBlock)
        magicString.append(n + n + exportBlock);
    if (outro)
        magicString.append(outro);
    return magicString;
}

function esm(magicString, { intro, outro, dependencies, exports }, options) {
    const _ = options.compact ? '' : ' ';
    const n = options.compact ? '' : '\n';
    const importBlock = dependencies
        .map(({ id, reexports, imports, name }) => {
        if (!reexports && !imports) {
            return `import${_}'${id}';`;
        }
        let output = '';
        if (imports) {
            const defaultImport = imports.find(specifier => specifier.imported === 'default');
            const starImport = imports.find(specifier => specifier.imported === '*');
            if (starImport) {
                output += `import${_}*${_}as ${starImport.local} from${_}'${id}';`;
                if (imports.length > 1)
                    output += n;
            }
            if (defaultImport && imports.length === 1) {
                output += `import ${defaultImport.local} from${_}'${id}';`;
            }
            else if (!starImport || imports.length > 1) {
                output += `import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${imports
                    .filter(specifier => specifier !== defaultImport && specifier !== starImport)
                    .map(specifier => {
                    if (specifier.imported === specifier.local) {
                        return specifier.imported;
                    }
                    else {
                        return `${specifier.imported} as ${specifier.local}`;
                    }
                })
                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`;
            }
        }
        if (reexports) {
            if (imports)
                output += n;
            const starExport = reexports.find(specifier => specifier.reexported === '*');
            const namespaceReexport = reexports.find(specifier => specifier.imported === '*' && specifier.reexported !== '*');
            if (starExport) {
                output += `export${_}*${_}from${_}'${id}';`;
                if (reexports.length === 1) {
                    return output;
                }
                output += n;
            }
            if (namespaceReexport) {
                if (!imports ||
                    !imports.some(specifier => specifier.imported === '*' && specifier.local === name))
                    output += `import${_}*${_}as ${name} from${_}'${id}';${n}`;
                output += `export${_}{${_}${name === namespaceReexport.reexported
                    ? name
                    : `${name} as ${namespaceReexport.reexported}`} };`;
                if (reexports.length === (starExport ? 2 : 1)) {
                    return output;
                }
                output += n;
            }
            output += `export${_}{${_}${reexports
                .filter(specifier => specifier !== starExport && specifier !== namespaceReexport)
                .map(specifier => {
                if (specifier.imported === specifier.reexported) {
                    return specifier.imported;
                }
                else {
                    return `${specifier.imported} as ${specifier.reexported}`;
                }
            })
                .join(`,${_}`)}${_}}${_}from${_}'${id}';`;
        }
        return output;
    })
        .join(n);
    if (importBlock)
        intro += importBlock + n + n;
    if (intro)
        magicString.prepend(intro);
    const exportBlock = [];
    const exportDeclaration = [];
    exports.forEach(specifier => {
        if (specifier.exported === 'default') {
            exportBlock.push(`export default ${specifier.local};`);
        }
        else {
            exportDeclaration.push(specifier.exported === specifier.local
                ? specifier.local
                : `${specifier.local} as ${specifier.exported}`);
        }
    });
    if (exportDeclaration.length) {
        exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
    }
    if (exportBlock.length)
        magicString.append(n + n + exportBlock.join(n).trim());
    if (outro)
        magicString.append(outro);
    return magicString.trim();
}

function spaces(i) {
    let result = '';
    while (i--)
        result += ' ';
    return result;
}
function tabsToSpaces(str) {
    return str.replace(/^\t+/, match => match.split('\t').join('  '));
}
function getCodeFrame(source, line, column) {
    let lines = source.split('\n');
    const frameStart = Math.max(0, line - 3);
    let frameEnd = Math.min(line + 2, lines.length);
    lines = lines.slice(frameStart, frameEnd);
    while (!/\S/.test(lines[lines.length - 1])) {
        lines.pop();
        frameEnd -= 1;
    }
    const digits = String(frameEnd).length;
    return lines
        .map((str, i) => {
        const isErrorLine = frameStart + i + 1 === line;
        let lineNum = String(i + frameStart + 1);
        while (lineNum.length < digits)
            lineNum = ` ${lineNum}`;
        if (isErrorLine) {
            const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';
            return `${lineNum}: ${tabsToSpaces(str)}\n${indicator}`;
        }
        return `${lineNum}: ${tabsToSpaces(str)}`;
    })
        .join('\n');
}

function getAliasName(id) {
    const base = basename(id);
    return base.substr(0, base.length - extname(id).length);
}
function relativeId(id) {
    if (typeof process === 'undefined' || !isAbsolute(id))
        return id;
    return relative(process.cwd(), id);
}
function isPlainName(name) {
    // not starting with "./", "/". "../"
    return !(name[0] === '/' ||
        (name[1] === '.' && (name[2] === '/' || (name[2] === '.' && name[3] === '/'))));
}

function error(base, props) {
    if (base instanceof Error === false)
        base = Object.assign(new Error(base.message), base);
    if (props)
        Object.assign(base, props);
    throw base;
}
function augmentCodeLocation(object, pos, source, id) {
    if (pos.line !== undefined && pos.column !== undefined) {
        const { line, column } = pos;
        object.loc = { file: id, line, column };
    }
    else {
        object.pos = pos;
        const { line, column } = locate(source, pos, { offsetLine: 1 });
        object.loc = { file: id, line, column };
    }
    if (object.frame === undefined) {
        const { line, column } = object.loc;
        object.frame = getCodeFrame(source, line, column);
    }
}
var Errors;
(function (Errors) {
    Errors["ASSET_NOT_FINALISED"] = "ASSET_NOT_FINALISED";
    Errors["ASSET_NOT_FOUND"] = "ASSET_NOT_FOUND";
    Errors["ASSET_SOURCE_ALREADY_SET"] = "ASSET_SOURCE_ALREADY_SET";
    Errors["ASSET_SOURCE_MISSING"] = "ASSET_SOURCE_MISSING";
    Errors["BAD_LOADER"] = "BAD_LOADER";
    Errors["CHUNK_NOT_FOUND"] = "CHUNK_NOT_FOUND";
    Errors["CHUNK_NOT_GENERATED"] = "CHUNK_NOT_GENERATED";
    Errors["INVALID_ASSET_NAME"] = "INVALID_ASSET_NAME";
    Errors["INVALID_CHUNK"] = "INVALID_CHUNK";
    Errors["INVALID_EXTERNAL_ID"] = "INVALID_EXTERNAL_ID";
    Errors["INVALID_OPTION"] = "INVALID_OPTION";
    Errors["INVALID_PLUGIN_HOOK"] = "INVALID_PLUGIN_HOOK";
    Errors["INVALID_ROLLUP_PHASE"] = "INVALID_ROLLUP_PHASE";
    Errors["NAMESPACE_CONFLICT"] = "NAMESPACE_CONFLICT";
    Errors["UNRESOLVED_ENTRY"] = "UNRESOLVED_ENTRY";
    Errors["UNRESOLVED_IMPORT"] = "UNRESOLVED_IMPORT";
})(Errors || (Errors = {}));
function errAssetNotFinalisedForFileName(asset) {
    return {
        code: Errors.ASSET_NOT_FINALISED,
        message: `Plugin error - Unable to get file name for asset "${asset.name}". Ensure that the source is set and that generate is called first.`
    };
}
function errChunkNotGeneratedForFileName(entry) {
    return {
        code: Errors.CHUNK_NOT_GENERATED,
        message: `Plugin error - Unable to get file name for chunk "${entry.name}". Ensure that generate is called first.`
    };
}
function errAssetReferenceIdNotFoundForFilename(assetReferenceId) {
    return {
        code: Errors.ASSET_NOT_FOUND,
        message: `Plugin error - Unable to get file name for unknown asset "${assetReferenceId}".`
    };
}
function errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
    return {
        code: Errors.ASSET_NOT_FOUND,
        message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
    };
}
function errAssetSourceAlreadySet(asset) {
    return {
        code: Errors.ASSET_SOURCE_ALREADY_SET,
        message: `Plugin error - Unable to set the source for asset "${asset.name}", source already set.`
    };
}
function errAssetSourceMissingForSetSource(asset) {
    return {
        code: Errors.ASSET_SOURCE_MISSING,
        message: `Plugin error creating asset "${asset.name}", setAssetSource call without a source.`
    };
}
function errNoAssetSourceSet(asset) {
    return {
        code: Errors.ASSET_SOURCE_MISSING,
        message: `Plugin error creating asset "${asset.name}" - no asset source set.`
    };
}
function errBadLoader(id) {
    return {
        code: Errors.BAD_LOADER,
        message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`
    };
}
function errChunkReferenceIdNotFoundForFilename(chunkReferenceId) {
    return {
        code: Errors.CHUNK_NOT_FOUND,
        message: `Plugin error - Unable to get file name for unknown chunk "${chunkReferenceId}".`
    };
}
function errInvalidAssetName(name) {
    return {
        code: Errors.INVALID_ASSET_NAME,
        message: `Plugin error creating asset, name "${name}" is not a plain (non relative or absolute URL) string name.`
    };
}
function errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
    return {
        code: Errors.INVALID_CHUNK,
        message: `Cannot assign ${relativeId(moduleId)} to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
    };
}
function errInternalIdCannotBeExternal(source, importer) {
    return {
        code: Errors.INVALID_EXTERNAL_ID,
        message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`
    };
}
function errInvalidOption(option, explanation) {
    return {
        code: Errors.INVALID_OPTION,
        message: `Invalid value for option "${option}" - ${explanation}.`
    };
}
function errInvalidRollupPhaseForAddWatchFile() {
    return {
        code: Errors.INVALID_ROLLUP_PHASE,
        message: `Cannot call addWatchFile after the build has finished.`
    };
}
function errInvalidRollupPhaseForEmitChunk() {
    return {
        code: Errors.INVALID_ROLLUP_PHASE,
        message: `Cannot call emitChunk after module loading has finished.`
    };
}
function errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {
    return {
        code: Errors.NAMESPACE_CONFLICT,
        message: `Conflicting namespaces: ${relativeId(reexportingModule.id)} re-exports '${name}' from both ${relativeId(reexportingModule.exportsAll[name])} and ${relativeId(additionalExportAllModule.exportsAll[name])} (will be ignored)`,
        name,
        reexporter: reexportingModule.id,
        sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]
    };
}
function errEntryCannotBeExternal(unresolvedId) {
    return {
        code: Errors.UNRESOLVED_ENTRY,
        message: `Entry module cannot be external (${relativeId(unresolvedId)}).`
    };
}
function errUnresolvedEntry(unresolvedId) {
    return {
        code: Errors.UNRESOLVED_ENTRY,
        message: `Could not resolve entry module (${relativeId(unresolvedId)}).`
    };
}
function errUnresolvedImport(source, importer) {
    return {
        code: Errors.UNRESOLVED_IMPORT,
        message: `Could not resolve '${source}' from ${relativeId(importer)}`
    };
}
function errUnresolvedImportTreatedAsExternal(source, importer) {
    return {
        code: Errors.UNRESOLVED_IMPORT,
        importer: relativeId(importer),
        message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,
        source,
        url: 'https://rollupjs.org/guide/en#warning-treating-module-as-external-dependency'
    };
}

// Generate strings which dereference dotted properties, but use array notation `['prop-deref']`
// if the property name isn't trivial
const shouldUseDot = /^[a-zA-Z$_][a-zA-Z0-9$_]*$/;
function property(prop) {
    return shouldUseDot.test(prop) ? `.${prop}` : `['${prop}']`;
}
function keypath(keypath) {
    return keypath
        .split('.')
        .map(property)
        .join('');
}

function setupNamespace(name, root, globals, compact) {
    const parts = name.split('.');
    if (globals) {
        parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
    }
    const _ = compact ? '' : ' ';
    parts.pop();
    let acc = root;
    return (parts
        .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}${compact ? '' : ';'}`))
        .join(compact ? ',' : '\n') + (compact && parts.length ? ';' : '\n'));
}
function assignToDeepVariable(deepName, root, globals, compact, assignment) {
    const _ = compact ? '' : ' ';
    const parts = deepName.split('.');
    if (globals) {
        parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
    }
    const last = parts.pop();
    let acc = root;
    let deepAssignment = parts
        .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}`))
        .concat(`${acc}${property(last)}`)
        .join(`,${_}`)
        .concat(`${_}=${_}${assignment}`);
    if (parts.length > 0) {
        deepAssignment = `(${deepAssignment})`;
    }
    return deepAssignment;
}

function trimEmptyImports(dependencies) {
    let i = dependencies.length;
    while (i--) {
        const dependency = dependencies[i];
        if (dependency.exportsDefault || dependency.exportsNames) {
            return dependencies.slice(0, i + 1);
        }
    }
    return [];
}

const thisProp = (name) => `this${keypath(name)}`;
function iife(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {
    const _ = options.compact ? '' : ' ';
    const n = options.compact ? '' : '\n';
    const { extend, name } = options;
    const isNamespaced = name && name.indexOf('.') !== -1;
    const useVariableAssignment = !extend && !isNamespaced;
    if (name && useVariableAssignment && !isLegal(name)) {
        error({
            code: 'ILLEGAL_IDENTIFIER_AS_NAME',
            message: `Given name (${name}) is not legal JS identifier. If you need this you can try --extend option`
        });
    }
    warnOnBuiltins(warn, dependencies);
    const external = trimEmptyImports(dependencies);
    const deps = external.map(dep => dep.globalName || 'null');
    const args = external.map(m => m.name);
    if (hasExports && !name) {
        error({
            code: 'INVALID_OPTION',
            message: `You must supply "output.name" for IIFE bundles.`
        });
    }
    if (namedExportsMode && hasExports) {
        if (extend) {
            deps.unshift(`${thisProp(name)}${_}=${_}${thisProp(name)}${_}||${_}{}`);
            args.unshift('exports');
        }
        else {
            deps.unshift('{}');
            args.unshift('exports');
        }
    }
    const useStrict = options.strict !== false ? `${t}'use strict';${n}${n}` : ``;
    let wrapperIntro = `(function${_}(${args.join(`,${_}`)})${_}{${n}${useStrict}`;
    if (hasExports && (!extend || !namedExportsMode)) {
        wrapperIntro =
            (useVariableAssignment ? `${varOrConst} ${name}` : thisProp(name)) +
                `${_}=${_}${wrapperIntro}`;
    }
    if (isNamespaced && hasExports) {
        wrapperIntro =
            setupNamespace(name, 'this', options.globals, options.compact) + wrapperIntro;
    }
    let wrapperOutro = `${n}${n}}(${deps.join(`,${_}`)}));`;
    if (!extend && namedExportsMode && hasExports) {
        wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;
    }
    // var foo__default = 'default' in foo ? foo['default'] : foo;
    const interopBlock = getInteropBlock(dependencies, options, varOrConst);
    if (interopBlock)
        magicString.prepend(interopBlock + n + n);
    if (intro)
        magicString.prepend(intro);
    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
    if (exportBlock)
        magicString.append(n + n + exportBlock);
    if (outro)
        magicString.append(outro);
    return magicString
        .indent(t)
        .prepend(wrapperIntro)
        .append(wrapperOutro);
}

function getStarExcludes({ dependencies, exports }) {
    const starExcludes = new Set(exports.map(expt => expt.exported));
    if (!starExcludes.has('default'))
        starExcludes.add('default');
    // also include reexport names
    dependencies.forEach(({ reexports }) => {
        if (reexports)
            reexports.forEach(reexport => {
                if (reexport.imported !== '*' && !starExcludes.has(reexport.reexported))
                    starExcludes.add(reexport.reexported);
            });
    });
    return starExcludes;
}
const getStarExcludesBlock = (starExcludes, varOrConst, _, t, n) => starExcludes
    ? `${n}${t}${varOrConst} _starExcludes${_}=${_}{${_}${Array.from(starExcludes).join(`:${_}1,${_}`)}${starExcludes.size ? `:${_}1` : ''}${_}};`
    : '';
const getImportBindingsBlock = (importBindings, _, t, n) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
function getExportsBlock(exports, _, t, n) {
    if (exports.length === 0) {
        return '';
    }
    if (exports.length === 1) {
        return `${t}${t}${t}exports('${exports[0].name}',${_}${exports[0].value});${n}${n}`;
    }
    return (`${t}${t}${t}exports({${n}` +
        exports.map(({ name, value }) => `${t}${t}${t}${t}${name}:${_}${value}`).join(`,${n}`) +
        `${n}${t}${t}${t}});${n}${n}`);
}
const getHoistedExportsBlock = (exports, _, t, n) => getExportsBlock(exports
    .filter(expt => expt.hoisted || expt.uninitialized)
    .map(expt => ({ name: expt.exported, value: expt.uninitialized ? 'void 0' : expt.local })), _, t, n);
const getMissingExportsBlock = (exports, _, t, n) => getExportsBlock(exports
    .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)
    .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), _, t, n);
function system(magicString, { dependencies, exports, indentString: t, intro, outro, usesTopLevelAwait, varOrConst }, options) {
    const n = options.compact ? '' : '\n';
    const _ = options.compact ? '' : ' ';
    const dependencyIds = dependencies.map(m => `'${m.id}'`);
    const importBindings = [];
    let starExcludes;
    const setters = [];
    dependencies.forEach(({ imports, reexports }) => {
        const setter = [];
        if (imports) {
            imports.forEach(specifier => {
                importBindings.push(specifier.local);
                if (specifier.imported === '*') {
                    setter.push(`${specifier.local}${_}=${_}module;`);
                }
                else {
                    setter.push(`${specifier.local}${_}=${_}module.${specifier.imported};`);
                }
            });
        }
        if (reexports) {
            let createdSetter = false;
            // bulk-reexport form
            if (reexports.length > 1 ||
                (reexports.length === 1 &&
                    (reexports[0].reexported === '*' || reexports[0].imported === '*'))) {
                // star reexports
                reexports.forEach(specifier => {
                    if (specifier.reexported !== '*')
                        return;
                    // need own exports list for deduping in star export case
                    if (!starExcludes) {
                        starExcludes = getStarExcludes({ dependencies, exports });
                    }
                    if (!createdSetter) {
                        setter.push(`${varOrConst} _setter${_}=${_}{};`);
                        createdSetter = true;
                    }
                    setter.push(`for${_}(var _$p${_}in${_}module)${_}{`);
                    setter.push(`${t}if${_}(!_starExcludes[_$p])${_}_setter[_$p]${_}=${_}module[_$p];`);
                    setter.push('}');
                });
                // star import reexport
                reexports.forEach(specifier => {
                    if (specifier.imported !== '*' || specifier.reexported === '*')
                        return;
                    setter.push(`exports('${specifier.reexported}',${_}module);`);
                });
                // reexports
                reexports.forEach(specifier => {
                    if (specifier.reexported === '*' || specifier.imported === '*')
                        return;
                    if (!createdSetter) {
                        setter.push(`${varOrConst} _setter${_}=${_}{};`);
                        createdSetter = true;
                    }
                    setter.push(`_setter.${specifier.reexported}${_}=${_}module.${specifier.imported};`);
                });
                if (createdSetter) {
                    setter.push('exports(_setter);');
                }
            }
            else {
                // single reexport
                reexports.forEach(specifier => {
                    setter.push(`exports('${specifier.reexported}',${_}module.${specifier.imported});`);
                });
            }
        }
        setters.push(setter.join(`${n}${t}${t}${t}`));
    });
    const registeredName = options.name ? `'${options.name}',${_}` : '';
    let wrapperStart = `System.register(${registeredName}[` +
        dependencyIds.join(`,${_}`) +
        `],${_}function${_}(exports,${_}module)${_}{${n}${t}'use strict';` +
        getStarExcludesBlock(starExcludes, varOrConst, _, t, n) +
        getImportBindingsBlock(importBindings, _, t, n) +
        `${n}${t}return${_}{${setters.length
            ? `${n}${t}${t}setters:${_}[${setters
                .map(s => s
                ? `function${_}(module)${_}{${n}${t}${t}${t}${s}${n}${t}${t}}`
                : `function${_}()${_}{}`)
                .join(`,${_}`)}],`
            : ''}${n}`;
    wrapperStart +=
        `${t}${t}execute:${_}${usesTopLevelAwait ? `async${_}` : ''}function${_}()${_}{${n}${n}` +
            getHoistedExportsBlock(exports, _, t, n);
    const wrapperEnd = `${n}${n}` +
        getMissingExportsBlock(exports, _, t, n) +
        `${t}${t}}${n}${t}}${options.compact ? '' : ';'}${n}});`;
    if (intro)
        magicString.prepend(intro);
    if (outro)
        magicString.append(outro);
    return magicString
        .indent(`${t}${t}${t}`)
        .append(wrapperEnd)
        .prepend(wrapperStart);
}

function globalProp(name, globalVar) {
    if (!name)
        return 'null';
    return `${globalVar}${keypath(name)}`;
}
function safeAccess(name, globalVar, _) {
    const parts = name.split('.');
    let acc = globalVar;
    return parts.map(part => ((acc += property(part)), acc)).join(`${_}&&${_}`);
}
function umd(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {
    const _ = options.compact ? '' : ' ';
    const n = options.compact ? '' : '\n';
    const factoryVar = options.compact ? 'f' : 'factory';
    const globalVar = options.compact ? 'g' : 'global';
    if (hasExports && !options.name) {
        error({
            code: 'INVALID_OPTION',
            message: 'You must supply "output.name" for UMD bundles.'
        });
    }
    warnOnBuiltins(warn, dependencies);
    const amdDeps = dependencies.map(m => `'${m.id}'`);
    const cjsDeps = dependencies.map(m => `require('${m.id}')`);
    const trimmedImports = trimEmptyImports(dependencies);
    const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar));
    const factoryArgs = trimmedImports.map(m => m.name);
    if (namedExportsMode && (hasExports || options.noConflict === true)) {
        amdDeps.unshift(`'exports'`);
        cjsDeps.unshift(`exports`);
        globalDeps.unshift(assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${options.extend ? `${globalProp(options.name, globalVar)}${_}||${_}` : ''}{}`));
        factoryArgs.unshift('exports');
    }
    const amdOptions = options.amd || {};
    const amdParams = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +
        (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
    const define = amdOptions.define || 'define';
    const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
    const useStrict = options.strict !== false ? `${_}'use strict';${n}` : ``;
    let iifeExport;
    if (options.noConflict === true) {
        const noConflictExportsVar = options.compact ? 'e' : 'exports';
        let factory;
        if (!namedExportsMode && hasExports) {
            factory = `var ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${factoryVar}(${globalDeps.join(`,${_}`)})`)};`;
        }
        else if (namedExportsMode) {
            const module = globalDeps.shift();
            factory =
                `var ${noConflictExportsVar}${_}=${_}${module};${n}` +
                    `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
        }
        iifeExport =
            `(function${_}()${_}{${n}` +
                `${t}${t}var current${_}=${_}${safeAccess(options.name, globalVar, _)};${n}` +
                `${t}${t}${factory}${n}` +
                `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}function${_}()${_}{${_}` +
                `${globalProp(options.name, globalVar)}${_}=${_}current;${_}return ${noConflictExportsVar}${options.compact ? '' : '; '}};${n}` +
                `${t}}())`;
    }
    else {
        iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
        if (!namedExportsMode && hasExports) {
            iifeExport = assignToDeepVariable(options.name, globalVar, options.globals, options.compact, iifeExport);
        }
    }
    const iifeNeedsGlobal = hasExports || (options.noConflict === true && namedExportsMode) || globalDeps.length > 0;
    const globalParam = iifeNeedsGlobal ? `${globalVar},${_}` : '';
    const globalArg = iifeNeedsGlobal ? `this,${_}` : '';
    const iifeStart = iifeNeedsGlobal ? `(${globalVar}${_}=${_}${globalVar}${_}||${_}self,${_}` : '';
    const iifeEnd = iifeNeedsGlobal ? ')' : '';
    const cjsIntro = iifeNeedsGlobal
        ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +
            `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`
        : '';
    const wrapperIntro = `(function${_}(${globalParam}${factoryVar})${_}{${n}` +
        cjsIntro +
        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +
        `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +
        `}(${globalArg}function${_}(${factoryArgs.join(', ')})${_}{${useStrict}${n}`;
    const wrapperOutro = n + n + '}));';
    // var foo__default = 'default' in foo ? foo['default'] : foo;
    const interopBlock = getInteropBlock(dependencies, options, varOrConst);
    if (interopBlock)
        magicString.prepend(interopBlock + n + n);
    if (intro)
        magicString.prepend(intro);
    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);
    if (exportBlock)
        magicString.append(n + n + exportBlock);
    if (namedExportsMode && hasExports && options.esModule)
        magicString.append(n + n + (options.compact ? compactEsModuleExport : esModuleExport));
    if (outro)
        magicString.append(outro);
    return magicString
        .trim()
        .indent(t)
        .append(wrapperOutro)
        .prepend(wrapperIntro);
}

var finalisers = { system, amd, cjs, es: esm, iife, umd };

const extractors = {
    ArrayPattern(names, param) {
        for (const element of param.elements) {
            if (element)
                extractors[element.type](names, element);
        }
    },
    AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
    },
    Identifier(names, param) {
        names.push(param.name);
    },
    MemberExpression() { },
    ObjectPattern(names, param) {
        for (const prop of param.properties) {
            if (prop.type === 'RestElement') {
                extractors.RestElement(names, prop);
            }
            else {
                extractors[prop.value.type](names, prop.value);
            }
        }
    },
    RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
    }
};
const extractAssignedNames = function extractAssignedNames(param) {
    const names = [];
    extractors[param.type](names, param);
    return names;
};

class ArrayExpression extends NodeBase {
    bind() {
        super.bind();
        for (const element of this.elements) {
            if (element !== null)
                element.deoptimizePath(UNKNOWN_PATH);
        }
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1)
            return UNKNOWN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);
    }
    hasEffectsWhenAccessedAtPath(path) {
        return path.length > 1;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length === 1) {
            return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, options);
        }
        return true;
    }
}

class ArrayPattern extends NodeBase {
    addExportedVariables(variables) {
        for (const element of this.elements) {
            if (element !== null) {
                element.addExportedVariables(variables);
            }
        }
    }
    declare(kind, _init) {
        for (const element of this.elements) {
            if (element !== null) {
                element.declare(kind, UNKNOWN_EXPRESSION);
            }
        }
    }
    deoptimizePath(path) {
        if (path.length === 0) {
            for (const element of this.elements) {
                if (element !== null) {
                    element.deoptimizePath(path);
                }
            }
        }
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (path.length > 0)
            return true;
        for (const element of this.elements) {
            if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options))
                return true;
        }
        return false;
    }
}

class BlockScope extends ChildScope {
    addDeclaration(identifier, context, init = null, isHoisted = false) {
        if (isHoisted) {
            return this.parent.addDeclaration(identifier, context, UNKNOWN_EXPRESSION, true);
        }
        else {
            return super.addDeclaration(identifier, context, init, false);
        }
    }
}

class BlockStatement$1 extends NodeBase {
    addImplicitReturnExpressionToScope() {
        const lastStatement = this.body[this.body.length - 1];
        if (!lastStatement || lastStatement.type !== ReturnStatement) {
            this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
        }
    }
    createScope(parentScope) {
        this.scope = this.parent.preventChildBlockScope
            ? parentScope
            : new BlockScope(parentScope);
    }
    hasEffects(options) {
        for (const node of this.body) {
            if (node.hasEffects(options))
                return true;
        }
        return false;
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
            if (includeAllChildrenRecursively || node.shouldBeIncluded())
                node.include(includeAllChildrenRecursively);
        }
    }
    render(code, options) {
        if (this.body.length) {
            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class ArrowFunctionExpression extends NodeBase {
    createScope(parentScope) {
        this.scope = new ReturnValueScope(parentScope, this.context);
    }
    deoptimizePath(path) {
        // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
        // which means the return expression needs to be reassigned
        if (path.length === 1 && path[0] === UNKNOWN_KEY) {
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
        }
    }
    getReturnExpressionWhenCalledAtPath(path) {
        return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;
    }
    hasEffects(_options) {
        return false;
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 1;
    }
    hasEffectsWhenAssignedAtPath(path, _options) {
        return path.length > 1;
    }
    hasEffectsWhenCalledAtPath(path, _callOptions, options) {
        if (path.length > 0) {
            return true;
        }
        for (const param of this.params) {
            if (param.hasEffects(options))
                return true;
        }
        return this.body.hasEffects(options);
    }
    initialise() {
        this.included = false;
        for (const param of this.params) {
            param.declare('parameter', UNKNOWN_EXPRESSION);
        }
        if (this.body instanceof BlockStatement$1) {
            this.body.addImplicitReturnExpressionToScope();
        }
        else {
            this.scope.addReturnExpression(this.body);
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.body.type === BlockStatement) {
            this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        }
        super.parseNode(esTreeNode);
    }
}
ArrowFunctionExpression.prototype.preventChildBlockScope = true;

function getSystemExportStatement(exportedVariables) {
    if (exportedVariables.length === 1) {
        return `exports('${exportedVariables[0].safeExportName ||
            exportedVariables[0].exportName}', ${exportedVariables[0].getName()});`;
    }
    else {
        return `exports({${exportedVariables
            .map(variable => `${variable.safeExportName || variable.exportName}: ${variable.getName()}`)
            .join(', ')}});`;
    }
}

class AssignmentExpression extends NodeBase {
    bind() {
        super.bind();
        this.left.deoptimizePath(EMPTY_PATH);
        // We cannot propagate mutations of the new binding to the old binding with certainty
        this.right.deoptimizePath(UNKNOWN_PATH);
    }
    hasEffects(options) {
        return (this.right.hasEffects(options) ||
            this.left.hasEffects(options) ||
            this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options));
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, options);
    }
    render(code, options) {
        this.left.render(code, options);
        this.right.render(code, options);
        if (options.format === 'system') {
            if (this.left.variable && this.left.variable.exportName) {
                code.prependLeft(code.original.indexOf('=', this.left.end) + 1, ` exports('${this.left.variable.exportName}',`);
                code.appendLeft(this.right.end, `)`);
            }
            else if ('addExportedVariables' in this.left) {
                const systemPatternExports = [];
                this.left.addExportedVariables(systemPatternExports);
                if (systemPatternExports.length > 0) {
                    code.prependRight(this.start, `function (v) {${getSystemExportStatement(systemPatternExports)} return v;} (`);
                    code.appendLeft(this.end, ')');
                }
            }
        }
    }
}

class AssignmentPattern extends NodeBase {
    addExportedVariables(variables) {
        this.left.addExportedVariables(variables);
    }
    bind() {
        super.bind();
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
    }
    declare(kind, init) {
        this.left.declare(kind, init);
    }
    deoptimizePath(path) {
        path.length === 0 && this.left.deoptimizePath(path);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options);
    }
    render(code, options, { isShorthandProperty } = BLANK) {
        this.left.render(code, options, { isShorthandProperty });
        this.right.render(code, options);
    }
}

class AwaitExpression extends NodeBase {
    hasEffects(options) {
        return super.hasEffects(options) || !options.ignoreReturnAwaitYield();
    }
    include(includeAllChildrenRecursively) {
        super.include(includeAllChildrenRecursively);
        if (!this.context.usesTopLevelAwait) {
            let parent = this.parent;
            do {
                if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)
                    return;
            } while ((parent = parent.parent));
            this.context.usesTopLevelAwait = true;
        }
    }
    render(code, options) {
        super.render(code, options);
    }
}

const binaryOperators = {
    '!=': (left, right) => left != right,
    '!==': (left, right) => left !== right,
    '%': (left, right) => left % right,
    '&': (left, right) => left & right,
    '*': (left, right) => left * right,
    // At the moment, "**" will be transpiled to Math.pow
    '**': (left, right) => Math.pow(left, right),
    '+': (left, right) => left + right,
    '-': (left, right) => left - right,
    '/': (left, right) => left / right,
    '<': (left, right) => left < right,
    '<<': (left, right) => left << right,
    '<=': (left, right) => left <= right,
    '==': (left, right) => left == right,
    '===': (left, right) => left === right,
    '>': (left, right) => left > right,
    '>=': (left, right) => left >= right,
    '>>': (left, right) => left >> right,
    '>>>': (left, right) => left >>> right,
    '^': (left, right) => left ^ right,
    in: () => UNKNOWN_VALUE,
    instanceof: () => UNKNOWN_VALUE,
    '|': (left, right) => left | right
};
class BinaryExpression extends NodeBase {
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UNKNOWN_VALUE;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (leftValue === UNKNOWN_VALUE)
            return UNKNOWN_VALUE;
        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (rightValue === UNKNOWN_VALUE)
            return UNKNOWN_VALUE;
        const operatorFn = binaryOperators[this.operator];
        if (!operatorFn)
            return UNKNOWN_VALUE;
        return operatorFn(leftValue, rightValue);
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 1;
    }
}

class BreakStatement extends NodeBase {
    hasEffects(options) {
        return (super.hasEffects(options) ||
            !options.ignoreBreakStatements() ||
            (this.label !== null && !options.ignoreLabel(this.label.name)));
    }
}

const RESULT_KEY$1 = {};
class ImmutableEntityPathTracker {
    constructor(existingEntityPaths = Immutable.Map()) {
        this.entityPaths = existingEntityPaths;
    }
    isTracked(entity, path) {
        return this.entityPaths.getIn([entity, ...path, RESULT_KEY$1]);
    }
    track(entity, path) {
        return new ImmutableEntityPathTracker(this.entityPaths.setIn([entity, ...path, RESULT_KEY$1], true));
    }
}
const EMPTY_IMMUTABLE_TRACKER = new ImmutableEntityPathTracker();

class CallExpression$1 extends NodeBase {
    bind() {
        super.bind();
        if (this.callee instanceof Identifier$1) {
            const variable = this.scope.findVariable(this.callee.name);
            if (variable.isNamespace) {
                this.context.error({
                    code: 'CANNOT_CALL_NAMESPACE',
                    message: `Cannot call a namespace ('${this.callee.name}')`
                }, this.start);
            }
            if (this.callee.name === 'eval') {
                this.context.warn({
                    code: 'EVAL',
                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
                    url: 'https://rollupjs.org/guide/en#avoiding-eval'
                }, this.start);
            }
        }
        if (this.returnExpression === null) {
            this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
        }
        for (const argument of this.arguments) {
            // This will make sure all properties of parameters behave as "unknown"
            argument.deoptimizePath(UNKNOWN_PATH);
        }
    }
    deoptimizeCache() {
        if (this.returnExpression !== UNKNOWN_EXPRESSION) {
            this.returnExpression = UNKNOWN_EXPRESSION;
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
        }
    }
    deoptimizePath(path) {
        if (path.length > 0 && !this.context.deoptimizationTracker.track(this, path)) {
            if (this.returnExpression === null) {
                this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
            }
            this.returnExpression.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.returnExpression === null) {
            this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, recursionTracker, this);
        }
        if (this.returnExpression === UNKNOWN_EXPRESSION ||
            recursionTracker.isTracked(this.returnExpression, path)) {
            return UNKNOWN_VALUE;
        }
        this.expressionsToBeDeoptimized.push(origin);
        return this.returnExpression.getLiteralValueAtPath(path, recursionTracker.track(this.returnExpression, path), origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (this.returnExpression === null) {
            this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, recursionTracker, this);
        }
        if (this.returnExpression === UNKNOWN_EXPRESSION ||
            recursionTracker.isTracked(this.returnExpression, path)) {
            return UNKNOWN_EXPRESSION;
        }
        this.expressionsToBeDeoptimized.push(origin);
        return this.returnExpression.getReturnExpressionWhenCalledAtPath(path, recursionTracker.track(this.returnExpression, path), origin);
    }
    hasEffects(options) {
        for (const argument of this.arguments) {
            if (argument.hasEffects(options))
                return true;
        }
        if (this.context.annotations && this.annotatedPure)
            return false;
        return (this.callee.hasEffects(options) ||
            this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, options.getHasEffectsWhenCalledOptions()));
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return (path.length > 0 &&
            !options.hasReturnExpressionBeenAccessedAtPath(path, this) &&
            this.returnExpression.hasEffectsWhenAccessedAtPath(path, options.addAccessedReturnExpressionAtPath(path, this)));
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return (path.length === 0 ||
            (!options.hasReturnExpressionBeenAssignedAtPath(path, this) &&
                this.returnExpression.hasEffectsWhenAssignedAtPath(path, options.addAssignedReturnExpressionAtPath(path, this))));
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (options.hasReturnExpressionBeenCalledAtPath(path, this))
            return false;
        return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, options.addCalledReturnExpressionAtPath(path, this));
    }
    include(includeAllChildrenRecursively) {
        super.include(includeAllChildrenRecursively);
        if (!this.returnExpression.included) {
            this.returnExpression.include(false);
        }
    }
    initialise() {
        this.included = false;
        this.returnExpression = null;
        this.callOptions = CallOptions.create({
            args: this.arguments,
            callIdentifier: this,
            withNew: false
        });
        this.expressionsToBeDeoptimized = [];
    }
    render(code, options, { renderedParentType } = BLANK) {
        super.render(code, options);
        if (renderedParentType === ExpressionStatement &&
            this.callee.type === FunctionExpression) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
}

class CatchScope extends ParameterScope {
    addDeclaration(identifier, context, init = null, isHoisted = false) {
        if (isHoisted) {
            return this.parent.addDeclaration(identifier, context, init, true);
        }
        else {
            return super.addDeclaration(identifier, context, init, false);
        }
    }
}

class CatchClause extends NodeBase {
    createScope(parentScope) {
        this.scope = new CatchScope(parentScope, this.context);
    }
    initialise() {
        this.included = false;
        if (this.param) {
            this.param.declare('parameter', UNKNOWN_EXPRESSION);
        }
    }
    parseNode(esTreeNode) {
        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope);
        super.parseNode(esTreeNode);
    }
}
CatchClause.prototype.preventChildBlockScope = true;

class ClassBody extends NodeBase {
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length > 0) {
            return true;
        }
        return (this.classConstructor !== null &&
            this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, options));
    }
    initialise() {
        this.included = false;
        for (const method of this.body) {
            if (method.kind === 'constructor') {
                this.classConstructor = method;
                return;
            }
        }
        this.classConstructor = null;
    }
}

class ClassExpression extends ClassNode {
}

class MultiExpression {
    constructor(expressions) {
        this.expressions = expressions;
    }
    deoptimizePath(path) {
        for (const expression of this.expressions) {
            expression.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath() {
        return UNKNOWN_VALUE;
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)));
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        for (const expression of this.expressions) {
            if (expression.hasEffectsWhenAccessedAtPath(path, options))
                return true;
        }
        return false;
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        for (const expression of this.expressions) {
            if (expression.hasEffectsWhenAssignedAtPath(path, options))
                return true;
        }
        return false;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        for (const expression of this.expressions) {
            if (expression.hasEffectsWhenCalledAtPath(path, callOptions, options))
                return true;
        }
        return false;
    }
    include() { }
}

class ConditionalExpression extends NodeBase {
    bind() {
        super.bind();
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
    }
    deoptimizeCache() {
        if (this.usedBranch !== null) {
            // We did not track if there were reassignments to the previous branch.
            // Also, the return value might need to be reassigned.
            this.usedBranch = null;
            this.unusedBranch.deoptimizePath(UNKNOWN_PATH);
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
        }
    }
    deoptimizePath(path) {
        if (path.length > 0) {
            if (!this.isBranchResolutionAnalysed)
                this.analyseBranchResolution();
            if (this.usedBranch === null) {
                this.consequent.deoptimizePath(path);
                this.alternate.deoptimizePath(path);
            }
            else {
                this.usedBranch.deoptimizePath(path);
            }
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
        if (this.usedBranch === null)
            return UNKNOWN_VALUE;
        this.expressionsToBeDeoptimized.push(origin);
        return this.usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
        if (this.usedBranch === null)
            return new MultiExpression([
                this.consequent.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),
                this.alternate.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)
            ]);
        this.expressionsToBeDeoptimized.push(origin);
        return this.usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    }
    hasEffects(options) {
        if (this.test.hasEffects(options))
            return true;
        if (this.usedBranch === null) {
            return this.consequent.hasEffects(options) || this.alternate.hasEffects(options);
        }
        return this.usedBranch.hasEffects(options);
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (path.length === 0)
            return false;
        if (this.usedBranch === null) {
            return (this.consequent.hasEffectsWhenAccessedAtPath(path, options) ||
                this.alternate.hasEffectsWhenAccessedAtPath(path, options));
        }
        return this.usedBranch.hasEffectsWhenAccessedAtPath(path, options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (path.length === 0)
            return true;
        if (this.usedBranch === null) {
            return (this.consequent.hasEffectsWhenAssignedAtPath(path, options) ||
                this.alternate.hasEffectsWhenAssignedAtPath(path, options));
        }
        return this.usedBranch.hasEffectsWhenAssignedAtPath(path, options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (this.usedBranch === null) {
            return (this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, options) ||
                this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, options));
        }
        return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, options);
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        if (includeAllChildrenRecursively || this.usedBranch === null || this.test.shouldBeIncluded()) {
            this.test.include(includeAllChildrenRecursively);
            this.consequent.include(includeAllChildrenRecursively);
            this.alternate.include(includeAllChildrenRecursively);
        }
        else {
            this.usedBranch.include(includeAllChildrenRecursively);
        }
    }
    initialise() {
        this.included = false;
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
        this.unusedBranch = null;
        this.expressionsToBeDeoptimized = [];
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {
        if (!this.test.included) {
            code.remove(this.start, this.usedBranch.start);
            code.remove(this.usedBranch.end, this.end);
            removeAnnotations(this, code);
            this.usedBranch.render(code, options, {
                isCalleeOfRenderedParent: renderedParentType
                    ? isCalleeOfRenderedParent
                    : this.parent.callee === this,
                renderedParentType: renderedParentType || this.parent.type
            });
        }
        else {
            super.render(code, options);
        }
    }
    analyseBranchResolution() {
        this.isBranchResolutionAnalysed = true;
        const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
        if (testValue !== UNKNOWN_VALUE) {
            if (testValue) {
                this.usedBranch = this.consequent;
                this.unusedBranch = this.alternate;
            }
            else {
                this.usedBranch = this.alternate;
                this.unusedBranch = this.consequent;
            }
        }
    }
}

class DoWhileStatement extends NodeBase {
    hasEffects(options) {
        return (this.test.hasEffects(options) || this.body.hasEffects(options.setIgnoreBreakStatements()));
    }
}

class EmptyStatement extends NodeBase {
    hasEffects() {
        return false;
    }
}

class ExportAllDeclaration$1 extends NodeBase {
    hasEffects() {
        return false;
    }
    initialise() {
        this.included = false;
        this.context.addExport(this);
    }
    render(code, _options, { start, end } = BLANK) {
        code.remove(start, end);
    }
}
ExportAllDeclaration$1.prototype.needsBoundaries = true;

class ExportNamedDeclaration extends NodeBase {
    bind() {
        // Do not bind specifiers
        if (this.declaration !== null)
            this.declaration.bind();
    }
    hasEffects(options) {
        return this.declaration !== null && this.declaration.hasEffects(options);
    }
    initialise() {
        this.included = false;
        this.context.addExport(this);
    }
    render(code, options, { start, end } = BLANK) {
        if (this.declaration === null) {
            code.remove(start, end);
        }
        else {
            code.remove(this.start, this.declaration.start);
            this.declaration.render(code, options, { start, end });
        }
    }
}
ExportNamedDeclaration.prototype.needsBoundaries = true;

class ExpressionStatement$1 extends NodeBase {
    initialise() {
        this.included = false;
        if (this.directive &&
            this.directive !== 'use strict' &&
            this.parent.type === Program) {
            this.context.warn(
            // This is necessary, because either way (deleting or not) can lead to errors.
            {
                code: 'MODULE_LEVEL_DIRECTIVE',
                message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
            }, this.start);
        }
    }
    render(code, options) {
        super.render(code, options);
        if (this.included)
            this.insertSemicolon(code);
    }
    shouldBeIncluded() {
        if (this.directive && this.directive !== 'use strict')
            return this.parent.type !== Program;
        return super.shouldBeIncluded();
    }
}

class ForInStatement extends NodeBase {
    bind() {
        this.left.bind();
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.bind();
        this.body.bind();
    }
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(options) {
        return ((this.left &&
            (this.left.hasEffects(options) ||
                this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options))) ||
            (this.right && this.right.hasEffects(options)) ||
            this.body.hasEffects(options.setIgnoreBreakStatements()));
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        this.left.includeWithAllDeclaredVariables(includeAllChildrenRecursively);
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.include(includeAllChildrenRecursively);
        this.body.include(includeAllChildrenRecursively);
    }
    render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
    }
}

class ForOfStatement extends NodeBase {
    bind() {
        this.left.bind();
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.bind();
        this.body.bind();
    }
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(options) {
        return ((this.left &&
            (this.left.hasEffects(options) ||
                this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options))) ||
            (this.right && this.right.hasEffects(options)) ||
            this.body.hasEffects(options.setIgnoreBreakStatements()));
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        this.left.includeWithAllDeclaredVariables(includeAllChildrenRecursively);
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.include(includeAllChildrenRecursively);
        this.body.include(includeAllChildrenRecursively);
    }
    render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
    }
}

class ForStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(options) {
        return ((this.init && this.init.hasEffects(options)) ||
            (this.test && this.test.hasEffects(options)) ||
            (this.update && this.update.hasEffects(options)) ||
            this.body.hasEffects(options.setIgnoreBreakStatements()));
    }
    render(code, options) {
        if (this.init)
            this.init.render(code, options, NO_SEMICOLON);
        if (this.test)
            this.test.render(code, options, NO_SEMICOLON);
        if (this.update)
            this.update.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
    }
}

class FunctionExpression$1 extends FunctionNode {
}

class IfStatement extends NodeBase {
    bind() {
        super.bind();
        if (!this.isTestValueAnalysed) {
            this.testValue = UNKNOWN_VALUE;
            this.isTestValueAnalysed = true;
            this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
        }
    }
    deoptimizeCache() {
        this.testValue = UNKNOWN_VALUE;
    }
    hasEffects(options) {
        if (this.test.hasEffects(options))
            return true;
        if (this.testValue === UNKNOWN_VALUE) {
            return (this.consequent.hasEffects(options) ||
                (this.alternate !== null && this.alternate.hasEffects(options)));
        }
        return this.testValue
            ? this.consequent.hasEffects(options)
            : this.alternate !== null && this.alternate.hasEffects(options);
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        if (includeAllChildrenRecursively) {
            this.test.include(true);
            this.consequent.include(true);
            if (this.alternate !== null) {
                this.alternate.include(true);
            }
            return;
        }
        const hasUnknownTest = this.testValue === UNKNOWN_VALUE;
        if (hasUnknownTest || this.test.shouldBeIncluded()) {
            this.test.include(false);
        }
        if ((hasUnknownTest || this.testValue) && this.consequent.shouldBeIncluded()) {
            this.consequent.include(false);
        }
        if (this.alternate !== null &&
            ((hasUnknownTest || !this.testValue) && this.alternate.shouldBeIncluded())) {
            this.alternate.include(false);
        }
    }
    initialise() {
        this.included = false;
        this.isTestValueAnalysed = false;
    }
    render(code, options) {
        // Note that unknown test values are always included
        if (!this.test.included &&
            (this.testValue
                ? this.alternate === null || !this.alternate.included
                : !this.consequent.included)) {
            const singleRetainedBranch = (this.testValue
                ? this.consequent
                : this.alternate);
            code.remove(this.start, singleRetainedBranch.start);
            code.remove(singleRetainedBranch.end, this.end);
            removeAnnotations(this, code);
            singleRetainedBranch.render(code, options);
        }
        else {
            if (this.test.included) {
                this.test.render(code, options);
            }
            else {
                code.overwrite(this.test.start, this.test.end, this.testValue ? 'true' : 'false');
            }
            if (this.consequent.included) {
                this.consequent.render(code, options);
            }
            else {
                code.overwrite(this.consequent.start, this.consequent.end, ';');
            }
            if (this.alternate !== null) {
                if (this.alternate.included) {
                    this.alternate.render(code, options);
                }
                else {
                    code.remove(this.consequent.end, this.alternate.end);
                }
            }
        }
    }
}

const getDynamicImportMechanism = (options) => {
    switch (options.format) {
        case 'cjs': {
            const _ = options.compact ? '' : ' ';
            return {
                interopLeft: `Promise.resolve({${_}default:${_}require(`,
                interopRight: `)${_}})`,
                left: 'Promise.resolve(require(',
                right: '))'
            };
        }
        case 'amd': {
            const _ = options.compact ? '' : ' ';
            const resolve = options.compact ? 'c' : 'resolve';
            const reject = options.compact ? 'e' : 'reject';
            return {
                interopLeft: `new Promise(function${_}(${resolve},${_}${reject})${_}{${_}require([`,
                interopRight: `],${_}function${_}(m)${_}{${_}${resolve}({${_}default:${_}m${_}})${_}},${_}${reject})${_}})`,
                left: `new Promise(function${_}(${resolve},${_}${reject})${_}{${_}require([`,
                right: `],${_}${resolve},${_}${reject})${_}})`
            };
        }
        case 'system':
            return {
                left: 'module.import(',
                right: ')'
            };
        case 'es':
            return {
                left: `${options.dynamicImportFunction || 'import'}(`,
                right: ')'
            };
    }
    return undefined;
};
class Import extends NodeBase {
    include() {
        this.included = true;
        this.context.includeDynamicImport(this);
    }
    initialise() {
        this.included = false;
        this.resolutionNamespace = undefined;
        this.resolutionInterop = false;
        this.context.addDynamicImport(this);
    }
    render(code, options) {
        if (this.resolutionNamespace) {
            const _ = options.compact ? '' : ' ';
            const s = options.compact ? '' : ';';
            code.overwrite(this.parent.start, this.parent.end, `Promise.resolve().then(function${_}()${_}{${_}return ${this.resolutionNamespace}${s}${_}})`);
            return;
        }
        const importMechanism = getDynamicImportMechanism(options);
        if (importMechanism) {
            const leftMechanism = (this.resolutionInterop && importMechanism.interopLeft) || importMechanism.left;
            const leftMechanismEnd = findFirstOccurrenceOutsideComment(code.original, '(', this.parent.callee.end) + 1;
            code.overwrite(this.parent.start, leftMechanismEnd, leftMechanism);
            const rightMechanism = (this.resolutionInterop && importMechanism.interopRight) || importMechanism.right;
            code.overwrite(this.parent.end - 1, this.parent.end, rightMechanism);
        }
    }
    renderFinalResolution(code, resolution, format) {
        if (this.included) {
            if (format === 'amd' && resolution.startsWith("'.") && resolution.endsWith(".js'")) {
                resolution = resolution.slice(0, -4) + "'";
            }
            code.overwrite(this.parent.arguments[0].start, this.parent.arguments[0].end, resolution);
        }
    }
    setResolution(interop, namespace) {
        this.resolutionInterop = interop;
        this.resolutionNamespace = namespace;
    }
}

class ImportDeclaration extends NodeBase {
    bind() { }
    hasEffects() {
        return false;
    }
    initialise() {
        this.included = false;
        this.context.addImport(this);
    }
    render(code, _options, { start, end } = BLANK) {
        code.remove(start, end);
    }
}
ImportDeclaration.prototype.needsBoundaries = true;

class LabeledStatement extends NodeBase {
    hasEffects(options) {
        return this.body.hasEffects(options.setIgnoreLabel(this.label.name).setIgnoreBreakStatements());
    }
}

class Literal extends NodeBase {
    getLiteralValueAtPath(path) {
        if (path.length > 0 ||
            // unknown literals such as bigints can also be null but do not start with an "n"
            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
            typeof this.value === 'bigint') {
            return UNKNOWN_VALUE;
        }
        return this.value;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1)
            return UNKNOWN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
    }
    hasEffectsWhenAccessedAtPath(path) {
        if (this.value === null) {
            return path.length > 0;
        }
        return path.length > 1;
    }
    hasEffectsWhenAssignedAtPath(path) {
        return path.length > 0;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (path.length === 1) {
            return hasMemberEffectWhenCalled(this.members, path[0], this.included, callOptions, options);
        }
        return true;
    }
    initialise() {
        this.included = false;
        this.members = getLiteralMembersForValue(this.value);
    }
    render(code, _options) {
        if (typeof this.value === 'string') {
            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
        }
    }
}

class LogicalExpression extends NodeBase {
    bind() {
        super.bind();
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
    }
    deoptimizeCache() {
        if (this.usedBranch !== null) {
            // We did not track if there were reassignments to any of the branches.
            // Also, the return values might need reassignment.
            this.usedBranch = null;
            this.unusedBranch.deoptimizePath(UNKNOWN_PATH);
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
        }
    }
    deoptimizePath(path) {
        if (path.length > 0) {
            if (!this.isBranchResolutionAnalysed)
                this.analyseBranchResolution();
            if (this.usedBranch === null) {
                this.left.deoptimizePath(path);
                this.right.deoptimizePath(path);
            }
            else {
                this.usedBranch.deoptimizePath(path);
            }
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
        if (this.usedBranch === null)
            return UNKNOWN_VALUE;
        this.expressionsToBeDeoptimized.push(origin);
        return this.usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (!this.isBranchResolutionAnalysed)
            this.analyseBranchResolution();
        if (this.usedBranch === null)
            return new MultiExpression([
                this.left.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),
                this.right.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)
            ]);
        this.expressionsToBeDeoptimized.push(origin);
        return this.usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    }
    hasEffects(options) {
        if (this.usedBranch === null) {
            return this.left.hasEffects(options) || this.right.hasEffects(options);
        }
        return this.usedBranch.hasEffects(options);
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (path.length === 0)
            return false;
        if (this.usedBranch === null) {
            return (this.left.hasEffectsWhenAccessedAtPath(path, options) ||
                this.right.hasEffectsWhenAccessedAtPath(path, options));
        }
        return this.usedBranch.hasEffectsWhenAccessedAtPath(path, options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (path.length === 0)
            return true;
        if (this.usedBranch === null) {
            return (this.left.hasEffectsWhenAssignedAtPath(path, options) ||
                this.right.hasEffectsWhenAssignedAtPath(path, options));
        }
        return this.usedBranch.hasEffectsWhenAssignedAtPath(path, options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (this.usedBranch === null) {
            return (this.left.hasEffectsWhenCalledAtPath(path, callOptions, options) ||
                this.right.hasEffectsWhenCalledAtPath(path, callOptions, options));
        }
        return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, options);
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        if (includeAllChildrenRecursively ||
            this.usedBranch === null ||
            this.unusedBranch.shouldBeIncluded()) {
            this.left.include(includeAllChildrenRecursively);
            this.right.include(includeAllChildrenRecursively);
        }
        else {
            this.usedBranch.include(includeAllChildrenRecursively);
        }
    }
    initialise() {
        this.included = false;
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
        this.unusedBranch = null;
        this.expressionsToBeDeoptimized = [];
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {
        if (!this.left.included || !this.right.included) {
            code.remove(this.start, this.usedBranch.start);
            code.remove(this.usedBranch.end, this.end);
            removeAnnotations(this, code);
            this.usedBranch.render(code, options, {
                isCalleeOfRenderedParent: renderedParentType
                    ? isCalleeOfRenderedParent
                    : this.parent.callee === this,
                renderedParentType: renderedParentType || this.parent.type
            });
        }
        else {
            super.render(code, options);
        }
    }
    analyseBranchResolution() {
        this.isBranchResolutionAnalysed = true;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
        if (leftValue !== UNKNOWN_VALUE) {
            if (this.operator === '||' ? leftValue : !leftValue) {
                this.usedBranch = this.left;
                this.unusedBranch = this.right;
            }
            else {
                this.usedBranch = this.right;
                this.unusedBranch = this.left;
            }
        }
    }
}

function getResolvablePropertyKey(memberExpression) {
    return memberExpression.computed
        ? getResolvableComputedPropertyKey(memberExpression.property)
        : memberExpression.property.name;
}
function getResolvableComputedPropertyKey(propertyKey) {
    if (propertyKey instanceof Literal) {
        return String(propertyKey.value);
    }
    return null;
}
function getPathIfNotComputed(memberExpression) {
    const nextPathKey = memberExpression.propertyKey;
    const object = memberExpression.object;
    if (typeof nextPathKey === 'string') {
        if (object instanceof Identifier$1) {
            return [
                { key: object.name, pos: object.start },
                { key: nextPathKey, pos: memberExpression.property.start }
            ];
        }
        if (object instanceof MemberExpression) {
            const parentPath = getPathIfNotComputed(object);
            return (parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }]);
        }
    }
    return null;
}
function getStringFromPath(path) {
    let pathString = path[0].key;
    for (let index = 1; index < path.length; index++) {
        pathString += '.' + path[index].key;
    }
    return pathString;
}
class MemberExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.variable = null;
    }
    addExportedVariables() { }
    bind() {
        if (this.bound)
            return;
        this.bound = true;
        const path = getPathIfNotComputed(this);
        const baseVariable = path && this.scope.findVariable(path[0].key);
        if (baseVariable && baseVariable.isNamespace) {
            const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));
            if (!resolvedVariable) {
                super.bind();
            }
            else if (typeof resolvedVariable === 'string') {
                this.replacement = resolvedVariable;
            }
            else {
                if (resolvedVariable.isExternal && resolvedVariable.module) {
                    resolvedVariable.module.suggestName(path[0].key);
                }
                this.variable = resolvedVariable;
                this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);
            }
        }
        else {
            super.bind();
            if (this.propertyKey === null)
                this.analysePropertyKey();
        }
    }
    deoptimizeCache() {
        for (const expression of this.expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
        }
    }
    deoptimizePath(path) {
        if (!this.bound)
            this.bind();
        if (path.length === 0)
            this.disallowNamespaceReassignment();
        if (this.variable) {
            this.variable.deoptimizePath(path);
        }
        else {
            if (this.propertyKey === null)
                this.analysePropertyKey();
            this.object.deoptimizePath([this.propertyKey, ...path]);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.variable !== null) {
            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
        }
        if (this.propertyKey === null)
            this.analysePropertyKey();
        this.expressionsToBeDeoptimized.push(origin);
        return this.object.getLiteralValueAtPath([this.propertyKey, ...path], recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (this.variable !== null) {
            return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
        }
        if (this.propertyKey === null)
            this.analysePropertyKey();
        this.expressionsToBeDeoptimized.push(origin);
        return this.object.getReturnExpressionWhenCalledAtPath([this.propertyKey, ...path], recursionTracker, origin);
    }
    hasEffects(options) {
        return (this.property.hasEffects(options) ||
            this.object.hasEffects(options) ||
            (this.context.propertyReadSideEffects &&
                this.object.hasEffectsWhenAccessedAtPath([this.propertyKey], options)));
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (path.length === 0) {
            return false;
        }
        if (this.variable !== null) {
            return this.variable.hasEffectsWhenAccessedAtPath(path, options);
        }
        return this.object.hasEffectsWhenAccessedAtPath([this.propertyKey, ...path], options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (this.variable !== null) {
            return this.variable.hasEffectsWhenAssignedAtPath(path, options);
        }
        return this.object.hasEffectsWhenAssignedAtPath([this.propertyKey, ...path], options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (this.variable !== null) {
            return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, options);
        }
        return this.object.hasEffectsWhenCalledAtPath([this.propertyKey, ...path], callOptions, options);
    }
    include(includeAllChildrenRecursively) {
        if (!this.included) {
            this.included = true;
            if (this.variable !== null) {
                this.context.includeVariable(this.variable);
            }
        }
        this.object.include(includeAllChildrenRecursively);
        this.property.include(includeAllChildrenRecursively);
    }
    initialise() {
        this.included = false;
        this.propertyKey = getResolvablePropertyKey(this);
        this.variable = null;
        this.bound = false;
        this.replacement = null;
        this.expressionsToBeDeoptimized = [];
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {
        const isCalleeOfDifferentParent = renderedParentType === CallExpression && isCalleeOfRenderedParent;
        if (this.variable || this.replacement) {
            let replacement = this.variable ? this.variable.getName() : this.replacement;
            if (isCalleeOfDifferentParent)
                replacement = '0, ' + replacement;
            code.overwrite(this.start, this.end, replacement, {
                contentOnly: true,
                storeName: true
            });
        }
        else {
            if (isCalleeOfDifferentParent) {
                code.appendRight(this.start, '0, ');
            }
            super.render(code, options);
        }
    }
    analysePropertyKey() {
        this.propertyKey = UNKNOWN_KEY;
        const value = this.property.getLiteralValueAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
        this.propertyKey = value === UNKNOWN_VALUE ? UNKNOWN_KEY : String(value);
    }
    disallowNamespaceReassignment() {
        if (this.object instanceof Identifier$1 &&
            this.scope.findVariable(this.object.name).isNamespace) {
            this.context.error({
                code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',
                message: `Illegal reassignment to import '${this.object.name}'`
            }, this.start);
        }
    }
    resolveNamespaceVariables(baseVariable, path) {
        if (path.length === 0)
            return baseVariable;
        if (!baseVariable.isNamespace)
            return null;
        const exportName = path[0].key;
        const variable = baseVariable.isExternal
            ? baseVariable.module.getVariableForExportName(exportName)
            : baseVariable.context.traceExport(exportName);
        if (!variable) {
            const fileName = baseVariable.isExternal
                ? baseVariable.module.id
                : baseVariable.context.fileName;
            this.context.warn({
                code: 'MISSING_EXPORT',
                exporter: relativeId(fileName),
                importer: relativeId(this.context.fileName),
                message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
                missing: exportName,
                url: `https://rollupjs.org/guide/en#error-name-is-not-exported-by-module-`
            }, path[0].pos);
            return 'undefined';
        }
        return this.resolveNamespaceVariables(variable, path.slice(1));
    }
}

const ASSET_PREFIX = 'ROLLUP_ASSET_URL_';
const CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';
class MetaProperty extends NodeBase {
    hasEffectsWhenAccessedAtPath(path) {
        return path.length > 1;
    }
    initialise() {
        if (this.meta.name === 'import') {
            this.context.addImportMeta(this);
        }
        this.included = false;
    }
    renderFinalMechanism(code, chunkId, format, pluginDriver) {
        if (!this.included)
            return false;
        const parent = this.parent;
        const importMetaProperty = parent instanceof MemberExpression && typeof parent.propertyKey === 'string'
            ? parent.propertyKey
            : null;
        if (importMetaProperty &&
            (importMetaProperty.startsWith(ASSET_PREFIX) || importMetaProperty.startsWith(CHUNK_PREFIX))) {
            let assetReferenceId = null;
            let chunkReferenceId = null;
            let fileName;
            if (importMetaProperty.startsWith(ASSET_PREFIX)) {
                assetReferenceId = importMetaProperty.substr(ASSET_PREFIX.length);
                fileName = this.context.getAssetFileName(assetReferenceId);
            }
            else {
                chunkReferenceId = importMetaProperty.substr(CHUNK_PREFIX.length);
                fileName = this.context.getChunkFileName(chunkReferenceId);
            }
            const relativePath = normalize(relative(dirname(chunkId), fileName));
            let replacement;
            if (assetReferenceId !== null) {
                // deprecated hook for assets
                replacement = pluginDriver.hookFirstSync('resolveAssetUrl', [
                    {
                        assetFileName: fileName,
                        chunkId,
                        format,
                        moduleId: this.context.module.id,
                        relativeAssetPath: relativePath
                    }
                ]);
            }
            if (!replacement) {
                replacement = pluginDriver.hookFirstSync('resolveFileUrl', [
                    {
                        assetReferenceId,
                        chunkId,
                        chunkReferenceId,
                        fileName,
                        format,
                        moduleId: this.context.module.id,
                        relativePath
                    }
                ]);
            }
            code.overwrite(parent.start, parent.end, replacement);
            return true;
        }
        const replacement = pluginDriver.hookFirstSync('resolveImportMeta', [
            importMetaProperty,
            {
                chunkId,
                format,
                moduleId: this.context.module.id
            }
        ]);
        if (typeof replacement === 'string') {
            if (parent instanceof MemberExpression) {
                code.overwrite(parent.start, parent.end, replacement);
            }
            else {
                code.overwrite(this.start, this.end, replacement);
            }
            return true;
        }
        return false;
    }
}

class MethodDefinition extends NodeBase {
    hasEffects(options) {
        return this.key.hasEffects(options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        return (path.length > 0 || this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, options));
    }
}

class NewExpression extends NodeBase {
    bind() {
        super.bind();
        for (const argument of this.arguments) {
            // This will make sure all properties of parameters behave as "unknown"
            argument.deoptimizePath(UNKNOWN_PATH);
        }
    }
    hasEffects(options) {
        for (const argument of this.arguments) {
            if (argument.hasEffects(options))
                return true;
        }
        if (this.annotatedPure)
            return false;
        return this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, options.getHasEffectsWhenCalledOptions());
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 1;
    }
    initialise() {
        this.included = false;
        this.callOptions = CallOptions.create({
            args: this.arguments,
            callIdentifier: this,
            withNew: true
        });
    }
}

class SpreadElement extends NodeBase {
    bind() {
        super.bind();
        // Only properties of properties of the argument could become subject to reassignment
        // This will also reassign the return values of iterators
        this.argument.deoptimizePath([UNKNOWN_KEY, UNKNOWN_KEY]);
    }
}

class ObjectExpression extends NodeBase {
    bind() {
        super.bind();
        if (this.propertyMap === null)
            this.buildPropertyMap();
    }
    // We could also track this per-property but this would quickly become much more complex
    deoptimizeCache() {
        if (!this.hasUnknownDeoptimizedProperty)
            this.deoptimizeAllProperties();
    }
    deoptimizePath(path) {
        if (this.hasUnknownDeoptimizedProperty)
            return;
        if (this.propertyMap === null)
            this.buildPropertyMap();
        if (path.length === 0) {
            this.deoptimizeAllProperties();
            return;
        }
        const key = path[0];
        if (path.length === 1) {
            if (typeof key !== 'string') {
                this.deoptimizeAllProperties();
                return;
            }
            if (!this.deoptimizedPaths[key]) {
                this.deoptimizedPaths[key] = true;
                // we only deoptimizeCache exact matches as in all other cases,
                // we do not return a literal value or return expression
                if (this.expressionsToBeDeoptimized[key]) {
                    for (const expression of this.expressionsToBeDeoptimized[key]) {
                        expression.deoptimizeCache();
                    }
                }
            }
        }
        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);
        for (const property of typeof key === 'string'
            ? this.propertyMap[key]
                ? this.propertyMap[key].propertiesRead
                : []
            : this.properties) {
            property.deoptimizePath(subPath);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.propertyMap === null)
            this.buildPropertyMap();
        const key = path[0];
        if (path.length === 0 ||
            this.hasUnknownDeoptimizedProperty ||
            typeof key !== 'string' ||
            this.deoptimizedPaths[key])
            return UNKNOWN_VALUE;
        if (path.length === 1 &&
            !this.propertyMap[key] &&
            !objectMembers[key] &&
            this.unmatchablePropertiesRead.length === 0) {
            if (!this.expressionsToBeDeoptimized[key]) {
                this.expressionsToBeDeoptimized[key] = [origin];
            }
            else {
                this.expressionsToBeDeoptimized[key].push(origin);
            }
            return undefined;
        }
        if (!this.propertyMap[key] ||
            this.propertyMap[key].exactMatchRead === null ||
            this.propertyMap[key].propertiesRead.length > 1)
            return UNKNOWN_VALUE;
        if (!this.expressionsToBeDeoptimized[key]) {
            this.expressionsToBeDeoptimized[key] = [origin];
        }
        else {
            this.expressionsToBeDeoptimized[key].push(origin);
        }
        return this.propertyMap[key]
            .exactMatchRead.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (this.propertyMap === null)
            this.buildPropertyMap();
        const key = path[0];
        if (path.length === 0 ||
            this.hasUnknownDeoptimizedProperty ||
            typeof key !== 'string' ||
            this.deoptimizedPaths[key])
            return UNKNOWN_EXPRESSION;
        if (path.length === 1 &&
            objectMembers[key] &&
            this.unmatchablePropertiesRead.length === 0 &&
            (!this.propertyMap[key] ||
                this.propertyMap[key].exactMatchRead === null))
            return getMemberReturnExpressionWhenCalled(objectMembers, key);
        if (!this.propertyMap[key] ||
            this.propertyMap[key].exactMatchRead === null ||
            this.propertyMap[key].propertiesRead.length > 1)
            return UNKNOWN_EXPRESSION;
        if (!this.expressionsToBeDeoptimized[key]) {
            this.expressionsToBeDeoptimized[key] = [origin];
        }
        else {
            this.expressionsToBeDeoptimized[key].push(origin);
        }
        return this.propertyMap[key]
            .exactMatchRead.getReturnExpressionWhenCalledAtPath(path.slice(1), recursionTracker, origin);
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (path.length === 0)
            return false;
        const key = path[0];
        if (path.length > 1 &&
            (this.hasUnknownDeoptimizedProperty ||
                typeof key !== 'string' ||
                this.deoptimizedPaths[key] ||
                !this.propertyMap[key] ||
                this.propertyMap[key].exactMatchRead === null))
            return true;
        const subPath = path.slice(1);
        for (const property of typeof key !== 'string'
            ? this.properties
            : this.propertyMap[key]
                ? this.propertyMap[key].propertiesRead
                : []) {
            if (property.hasEffectsWhenAccessedAtPath(subPath, options))
                return true;
        }
        return false;
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (path.length === 0)
            return false;
        const key = path[0];
        if (path.length > 1 &&
            (this.hasUnknownDeoptimizedProperty ||
                typeof key !== 'string' ||
                this.deoptimizedPaths[key] ||
                !this.propertyMap[key] ||
                this.propertyMap[key].exactMatchRead === null))
            return true;
        const subPath = path.slice(1);
        for (const property of typeof key !== 'string'
            ? this.properties
            : path.length > 1
                ? this.propertyMap[key].propertiesRead
                : this.propertyMap[key]
                    ? this.propertyMap[key].propertiesSet
                    : []) {
            if (property.hasEffectsWhenAssignedAtPath(subPath, options))
                return true;
        }
        return false;
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        const key = path[0];
        if (path.length === 0 ||
            this.hasUnknownDeoptimizedProperty ||
            typeof key !== 'string' ||
            this.deoptimizedPaths[key] ||
            (this.propertyMap[key]
                ? !this.propertyMap[key].exactMatchRead
                : path.length > 1 || !objectMembers[key]))
            return true;
        const subPath = path.slice(1);
        for (const property of this.propertyMap[key]
            ? this.propertyMap[key].propertiesRead
            : []) {
            if (property.hasEffectsWhenCalledAtPath(subPath, callOptions, options))
                return true;
        }
        if (path.length === 1 && objectMembers[key])
            return hasMemberEffectWhenCalled(objectMembers, key, this.included, callOptions, options);
        return false;
    }
    initialise() {
        this.included = false;
        this.hasUnknownDeoptimizedProperty = false;
        this.deoptimizedPaths = Object.create(null);
        this.propertyMap = null;
        this.expressionsToBeDeoptimized = Object.create(null);
    }
    render(code, options, { renderedParentType } = BLANK) {
        super.render(code, options);
        if (renderedParentType === ExpressionStatement) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
    buildPropertyMap() {
        this.propertyMap = Object.create(null);
        this.unmatchablePropertiesRead = [];
        this.unmatchablePropertiesWrite = [];
        for (let index = this.properties.length - 1; index >= 0; index--) {
            const property = this.properties[index];
            if (property instanceof SpreadElement) {
                this.unmatchablePropertiesRead.push(property);
                continue;
            }
            const isWrite = property.kind !== 'get';
            const isRead = property.kind !== 'set';
            let key;
            if (property.computed) {
                const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
                if (keyValue === UNKNOWN_VALUE) {
                    if (isRead) {
                        this.unmatchablePropertiesRead.push(property);
                    }
                    else {
                        this.unmatchablePropertiesWrite.push(property);
                    }
                    continue;
                }
                key = String(keyValue);
            }
            else if (property.key instanceof Identifier$1) {
                key = property.key.name;
            }
            else {
                key = String(property.key.value);
            }
            const propertyMapProperty = this.propertyMap[key];
            if (!propertyMapProperty) {
                this.propertyMap[key] = {
                    exactMatchRead: isRead ? property : null,
                    exactMatchWrite: isWrite ? property : null,
                    propertiesRead: isRead ? [property, ...this.unmatchablePropertiesRead] : [],
                    propertiesSet: isWrite && !isRead ? [property, ...this.unmatchablePropertiesWrite] : []
                };
                continue;
            }
            if (isRead && propertyMapProperty.exactMatchRead === null) {
                propertyMapProperty.exactMatchRead = property;
                propertyMapProperty.propertiesRead.push(property, ...this.unmatchablePropertiesRead);
            }
            if (isWrite && !isRead && propertyMapProperty.exactMatchWrite === null) {
                propertyMapProperty.exactMatchWrite = property;
                propertyMapProperty.propertiesSet.push(property, ...this.unmatchablePropertiesWrite);
            }
        }
    }
    deoptimizeAllProperties() {
        this.hasUnknownDeoptimizedProperty = true;
        for (const property of this.properties) {
            property.deoptimizePath(UNKNOWN_PATH);
        }
        for (const key of Object.keys(this.expressionsToBeDeoptimized)) {
            for (const expression of this.expressionsToBeDeoptimized[key]) {
                expression.deoptimizeCache();
            }
        }
    }
}

class ObjectPattern extends NodeBase {
    addExportedVariables(variables) {
        for (const property of this.properties) {
            if (property.type === Property) {
                property.value.addExportedVariables(variables);
            }
            else {
                property.argument.addExportedVariables(variables);
            }
        }
    }
    declare(kind, init) {
        for (const property of this.properties) {
            property.declare(kind, init);
        }
    }
    deoptimizePath(path) {
        if (path.length === 0) {
            for (const property of this.properties) {
                property.deoptimizePath(path);
            }
        }
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (path.length > 0)
            return true;
        for (const property of this.properties) {
            if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options))
                return true;
        }
        return false;
    }
}

class Program$1 extends NodeBase {
    hasEffects(options) {
        for (const node of this.body) {
            if (node.hasEffects(options))
                return true;
        }
        return false;
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
            if (includeAllChildrenRecursively || node.shouldBeIncluded()) {
                node.include(includeAllChildrenRecursively);
            }
        }
    }
    render(code, options) {
        if (this.body.length) {
            renderStatementList(this.body, code, this.start, this.end, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class Property$1 extends NodeBase {
    constructor() {
        super(...arguments);
        this.declarationInit = null;
    }
    bind() {
        super.bind();
        if (this.kind === 'get' && this.returnExpression === null)
            this.updateReturnExpression();
        if (this.declarationInit !== null) {
            this.declarationInit.deoptimizePath([UNKNOWN_KEY, UNKNOWN_KEY]);
        }
    }
    declare(kind, init) {
        this.declarationInit = init;
        this.value.declare(kind, UNKNOWN_EXPRESSION);
    }
    deoptimizeCache() {
        // As getter properties directly receive their values from function expressions that always
        // have a fixed return value, there is no known situation where a getter is deoptimized.
        throw new Error('Unexpected deoptimization');
    }
    deoptimizePath(path) {
        if (this.kind === 'get') {
            if (path.length > 0) {
                if (this.returnExpression === null)
                    this.updateReturnExpression();
                this.returnExpression.deoptimizePath(path);
            }
        }
        else if (this.kind !== 'set') {
            this.value.deoptimizePath(path);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.kind === 'set') {
            return UNKNOWN_VALUE;
        }
        if (this.kind === 'get') {
            if (this.returnExpression === null)
                this.updateReturnExpression();
            return this.returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
        }
        return this.value.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {
        if (this.kind === 'set') {
            return UNKNOWN_EXPRESSION;
        }
        if (this.kind === 'get') {
            if (this.returnExpression === null)
                this.updateReturnExpression();
            return this.returnExpression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
        }
        return this.value.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);
    }
    hasEffects(options) {
        return this.key.hasEffects(options) || this.value.hasEffects(options);
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        if (this.kind === 'get') {
            return (this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, options.getHasEffectsWhenCalledOptions()) ||
                (path.length > 0 &&
                    this.returnExpression.hasEffectsWhenAccessedAtPath(path, options)));
        }
        return this.value.hasEffectsWhenAccessedAtPath(path, options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        if (this.kind === 'get') {
            return (path.length === 0 ||
                this.returnExpression.hasEffectsWhenAssignedAtPath(path, options));
        }
        if (this.kind === 'set') {
            return (path.length > 0 ||
                this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, options.getHasEffectsWhenCalledOptions()));
        }
        return this.value.hasEffectsWhenAssignedAtPath(path, options);
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        if (this.kind === 'get') {
            return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, options);
        }
        return this.value.hasEffectsWhenCalledAtPath(path, callOptions, options);
    }
    initialise() {
        this.included = false;
        this.returnExpression = null;
        this.accessorCallOptions = CallOptions.create({
            callIdentifier: this,
            withNew: false
        });
    }
    render(code, options) {
        if (!this.shorthand) {
            this.key.render(code, options);
        }
        this.value.render(code, options, { isShorthandProperty: this.shorthand });
    }
    updateReturnExpression() {
        this.returnExpression = UNKNOWN_EXPRESSION;
        this.returnExpression = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, EMPTY_IMMUTABLE_TRACKER, this);
    }
}

class RestElement extends NodeBase {
    constructor() {
        super(...arguments);
        this.declarationInit = null;
    }
    addExportedVariables(variables) {
        this.argument.addExportedVariables(variables);
    }
    bind() {
        super.bind();
        if (this.declarationInit !== null) {
            this.declarationInit.deoptimizePath([UNKNOWN_KEY, UNKNOWN_KEY]);
        }
    }
    declare(kind, init) {
        this.argument.declare(kind, UNKNOWN_EXPRESSION);
        this.declarationInit = init;
    }
    deoptimizePath(path) {
        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options);
    }
}

class ReturnStatement$1 extends NodeBase {
    hasEffects(options) {
        return (!options.ignoreReturnAwaitYield() ||
            (this.argument !== null && this.argument.hasEffects(options)));
    }
    initialise() {
        this.included = false;
        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options);
            if (this.argument.start === this.start + 6 /* 'return'.length */) {
                code.prependLeft(this.start + 6, ' ');
            }
        }
    }
}

class SequenceExpression extends NodeBase {
    deoptimizePath(path) {
        if (path.length > 0)
            this.expressions[this.expressions.length - 1].deoptimizePath(path);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
    }
    hasEffects(options) {
        for (const expression of this.expressions) {
            if (expression.hasEffects(options))
                return true;
        }
        return false;
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return (path.length > 0 &&
            this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, options));
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return (path.length === 0 ||
            this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, options));
    }
    hasEffectsWhenCalledAtPath(path, callOptions, options) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, options);
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        for (let i = 0; i < this.expressions.length - 1; i++) {
            const node = this.expressions[i];
            if (includeAllChildrenRecursively || node.shouldBeIncluded())
                node.include(includeAllChildrenRecursively);
        }
        this.expressions[this.expressions.length - 1].include(includeAllChildrenRecursively);
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {
        let firstStart = 0, lastEnd, includedNodes = 0;
        for (const { node, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
            if (!node.included) {
                treeshakeNode(node, code, start, end);
                continue;
            }
            includedNodes++;
            if (firstStart === 0)
                firstStart = start;
            lastEnd = end;
            if (node === this.expressions[this.expressions.length - 1] && includedNodes === 1) {
                node.render(code, options, {
                    isCalleeOfRenderedParent: renderedParentType
                        ? isCalleeOfRenderedParent
                        : this.parent.callee === this,
                    renderedParentType: renderedParentType || this.parent.type
                });
            }
            else {
                node.render(code, options);
            }
        }
        // Round brackets are part of the actual parent and should be re-added in case the parent changed
        if (includedNodes > 1 && renderedParentType) {
            code.prependRight(firstStart, '(');
            code.appendLeft(lastEnd, ')');
        }
    }
}

class SwitchCase extends NodeBase {
    include(includeAllChildrenRecursively) {
        this.included = true;
        if (this.test)
            this.test.include(includeAllChildrenRecursively);
        for (const node of this.consequent) {
            if (includeAllChildrenRecursively || node.shouldBeIncluded())
                node.include(includeAllChildrenRecursively);
        }
    }
    render(code, options) {
        if (this.consequent.length) {
            this.test && this.test.render(code, options);
            const testEnd = this.test
                ? this.test.end
                : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;
            const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;
            renderStatementList(this.consequent, code, consequentStart, this.end, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class SwitchStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(options) {
        return super.hasEffects(options.setIgnoreBreakStatements());
    }
}

class TaggedTemplateExpression extends NodeBase {
    bind() {
        super.bind();
        if (this.tag.type === Identifier) {
            const variable = this.scope.findVariable(this.tag.name);
            if (variable.isNamespace) {
                this.context.error({
                    code: 'CANNOT_CALL_NAMESPACE',
                    message: `Cannot call a namespace ('${this.tag.name}')`
                }, this.start);
            }
            if (this.tag.name === 'eval') {
                this.context.warn({
                    code: 'EVAL',
                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
                    url: 'https://rollupjs.org/guide/en#avoiding-eval'
                }, this.start);
            }
        }
    }
    hasEffects(options) {
        return (super.hasEffects(options) ||
            this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, options.getHasEffectsWhenCalledOptions()));
    }
    initialise() {
        this.included = false;
        this.callOptions = CallOptions.create({
            callIdentifier: this,
            withNew: false
        });
    }
}

class TemplateElement extends NodeBase {
    hasEffects(_options) {
        return false;
    }
}

class TemplateLiteral extends NodeBase {
    getLiteralValueAtPath(path) {
        if (path.length > 0 || this.quasis.length !== 1) {
            return UNKNOWN_VALUE;
        }
        return this.quasis[0].value.cooked;
    }
    render(code, options) {
        code.indentExclusionRanges.push([this.start, this.end]);
        super.render(code, options);
    }
}

class ModuleScope extends ChildScope {
    constructor(parent, context) {
        super(parent);
        this.context = context;
        this.variables.this = new LocalVariable('this', null, UNDEFINED_EXPRESSION, context);
    }
    addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {
        return (this.variables.default = new ExportDefaultVariable(name, exportDefaultDeclaration, context));
    }
    addNamespaceMemberAccess(_name, variable) {
        if (variable instanceof GlobalVariable) {
            this.accessedOutsideVariables[variable.name] = variable;
        }
    }
    deconflict(forbiddenNames) {
        // all module level variables are already deconflicted when deconflicting the chunk
        for (const scope of this.children)
            scope.deconflict(forbiddenNames);
    }
    findLexicalBoundary() {
        return this;
    }
    findVariable(name) {
        const knownVariable = this.variables[name] || this.accessedOutsideVariables[name];
        if (knownVariable) {
            return knownVariable;
        }
        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
        if (variable instanceof GlobalVariable) {
            this.accessedOutsideVariables[name] = variable;
        }
        return variable;
    }
}

class ThisExpression extends NodeBase {
    bind() {
        super.bind();
        this.variable = this.scope.findVariable('this');
    }
    hasEffectsWhenAccessedAtPath(path, options) {
        return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, options);
    }
    hasEffectsWhenAssignedAtPath(path, options) {
        return this.variable.hasEffectsWhenAssignedAtPath(path, options);
    }
    initialise() {
        this.included = false;
        this.variable = null;
        this.alias =
            this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
        if (this.alias === 'undefined') {
            this.context.warn({
                code: 'THIS_IS_UNDEFINED',
                message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
                url: `https://rollupjs.org/guide/en#error-this-is-undefined`
            }, this.start);
        }
    }
    render(code, _options) {
        if (this.alias !== null) {
            code.overwrite(this.start, this.end, this.alias, {
                contentOnly: false,
                storeName: true
            });
        }
    }
}

class ThrowStatement extends NodeBase {
    hasEffects(_options) {
        return true;
    }
}

const unaryOperators = {
    '!': value => !value,
    '+': value => +value,
    '-': value => -value,
    delete: () => UNKNOWN_VALUE,
    typeof: value => typeof value,
    void: () => undefined,
    '~': value => ~value
};
class UnaryExpression extends NodeBase {
    bind() {
        super.bind();
        if (this.operator === 'delete') {
            this.argument.deoptimizePath(EMPTY_PATH);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UNKNOWN_VALUE;
        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (argumentValue === UNKNOWN_VALUE)
            return UNKNOWN_VALUE;
        return unaryOperators[this.operator](argumentValue);
    }
    hasEffects(options) {
        return (this.argument.hasEffects(options) ||
            (this.operator === 'delete' &&
                this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options)));
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        if (this.operator === 'void') {
            return path.length > 0;
        }
        return path.length > 1;
    }
}

class UnknownNode extends NodeBase {
    hasEffects(_options) {
        return true;
    }
    include() {
        super.include(true);
    }
}

class UpdateExpression extends NodeBase {
    bind() {
        super.bind();
        this.argument.deoptimizePath(EMPTY_PATH);
        if (this.argument instanceof Identifier$1) {
            const variable = this.scope.findVariable(this.argument.name);
            variable.isReassigned = true;
        }
    }
    hasEffects(options) {
        return (this.argument.hasEffects(options) ||
            this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, options));
    }
    hasEffectsWhenAccessedAtPath(path, _options) {
        return path.length > 1;
    }
    render(code, options) {
        this.argument.render(code, options);
        const variable = this.argument.variable;
        if (options.format === 'system' && variable && variable.exportName) {
            const name = variable.getName();
            if (this.prefix) {
                code.overwrite(this.start, this.end, `exports('${variable.exportName}', ${this.operator}${name})`);
            }
            else {
                let op;
                switch (this.operator) {
                    case '++':
                        op = `${name} + 1`;
                        break;
                    case '--':
                        op = `${name} - 1`;
                        break;
                }
                code.overwrite(this.start, this.end, `(exports('${variable.exportName}', ${op}), ${name}${this.operator})`);
            }
        }
    }
}

function isReassignedExportsMember(variable) {
    return variable.renderBaseName !== null && variable.exportName !== null && variable.isReassigned;
}
function areAllDeclarationsIncludedAndNotExported(declarations) {
    for (const declarator of declarations) {
        if (!declarator.included) {
            return false;
        }
        if (declarator.id.type === Identifier) {
            if (declarator.id.variable.exportName)
                return false;
        }
        else {
            const exportedVariables = [];
            declarator.id.addExportedVariables(exportedVariables);
            if (exportedVariables.length > 0)
                return false;
        }
    }
    return true;
}
class VariableDeclaration$1 extends NodeBase {
    deoptimizePath(_path) {
        for (const declarator of this.declarations) {
            declarator.deoptimizePath(EMPTY_PATH);
        }
    }
    hasEffectsWhenAssignedAtPath(_path, _options) {
        return false;
    }
    include(includeAllChildrenRecursively) {
        this.included = true;
        for (const declarator of this.declarations) {
            if (includeAllChildrenRecursively || declarator.shouldBeIncluded())
                declarator.include(includeAllChildrenRecursively);
        }
    }
    includeWithAllDeclaredVariables(includeAllChildrenRecursively) {
        this.included = true;
        for (const declarator of this.declarations) {
            declarator.include(includeAllChildrenRecursively);
        }
    }
    initialise() {
        this.included = false;
        for (const declarator of this.declarations) {
            declarator.declareDeclarator(this.kind);
        }
    }
    render(code, options, nodeRenderOptions = BLANK) {
        if (areAllDeclarationsIncludedAndNotExported(this.declarations)) {
            for (const declarator of this.declarations) {
                declarator.render(code, options);
            }
            if (!nodeRenderOptions.isNoStatement &&
                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
                code.appendLeft(this.end, ';');
            }
        }
        else {
            this.renderReplacedDeclarations(code, options, nodeRenderOptions);
        }
    }
    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, addSemicolon, systemPatternExports) {
        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
            code.remove(this.end - 1, this.end);
        }
        if (addSemicolon) {
            separatorString += ';';
        }
        if (lastSeparatorPos !== null) {
            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
                actualContentEnd--;
                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
                    actualContentEnd--;
                }
            }
            if (actualContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.remove(actualContentEnd, renderedContentEnd);
            }
        }
        else {
            code.appendLeft(renderedContentEnd, separatorString);
        }
        if (systemPatternExports.length > 0) {
            code.appendLeft(renderedContentEnd, ' ' + getSystemExportStatement(systemPatternExports));
        }
    }
    renderReplacedDeclarations(code, options, { start = this.start, end = this.end, isNoStatement }) {
        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
        let actualContentEnd, renderedContentEnd;
        if (/\n\s*$/.test(code.slice(this.start, separatedNodes[0].start))) {
            renderedContentEnd = this.start + this.kind.length;
        }
        else {
            renderedContentEnd = separatedNodes[0].start;
        }
        let lastSeparatorPos = renderedContentEnd - 1;
        code.remove(this.start, lastSeparatorPos);
        let isInDeclaration = false;
        let hasRenderedContent = false;
        let separatorString = '', leadingString, nextSeparatorString;
        const systemPatternExports = [];
        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
            if (!node.included ||
                (node.id instanceof Identifier$1 &&
                    isReassignedExportsMember(node.id.variable) &&
                    node.init === null)) {
                code.remove(start, end);
                continue;
            }
            leadingString = '';
            nextSeparatorString = '';
            if (node.id instanceof Identifier$1 &&
                isReassignedExportsMember(node.id.variable)) {
                if (hasRenderedContent) {
                    separatorString += ';';
                }
                isInDeclaration = false;
            }
            else {
                if (options.format === 'system' && node.init !== null) {
                    if (node.id.type !== Identifier) {
                        node.id.addExportedVariables(systemPatternExports);
                    }
                    else if (node.id.variable.exportName) {
                        code.prependLeft(code.original.indexOf('=', node.id.end) + 1, ` exports('${node.id.variable.safeExportName ||
                            node.id.variable.exportName}',`);
                        nextSeparatorString += ')';
                    }
                }
                if (isInDeclaration) {
                    separatorString += ',';
                }
                else {
                    if (hasRenderedContent) {
                        separatorString += ';';
                    }
                    leadingString += `${this.kind} `;
                    isInDeclaration = true;
                }
            }
            if (renderedContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.appendLeft(renderedContentEnd, leadingString);
            }
            node.render(code, options);
            actualContentEnd = contentEnd;
            renderedContentEnd = end;
            hasRenderedContent = true;
            lastSeparatorPos = separator;
            separatorString = nextSeparatorString;
        }
        if (hasRenderedContent) {
            this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, !isNoStatement, systemPatternExports);
        }
        else {
            code.remove(start, end);
        }
    }
}

class VariableDeclarator extends NodeBase {
    declareDeclarator(kind) {
        this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
    }
    deoptimizePath(path) {
        this.id.deoptimizePath(path);
    }
    render(code, options) {
        // This can happen for hoisted variables in dead branches
        if (this.init !== null && !this.init.included) {
            code.remove(this.id.end, this.end);
            this.id.render(code, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class WhileStatement extends NodeBase {
    hasEffects(options) {
        return (this.test.hasEffects(options) || this.body.hasEffects(options.setIgnoreBreakStatements()));
    }
}

class YieldExpression extends NodeBase {
    bind() {
        super.bind();
        if (this.argument !== null) {
            this.argument.deoptimizePath(UNKNOWN_PATH);
        }
    }
    hasEffects(options) {
        return (!options.ignoreReturnAwaitYield() ||
            (this.argument !== null && this.argument.hasEffects(options)));
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options);
            if (this.argument.start === this.start + 5 /* 'yield'.length */) {
                code.prependLeft(this.start + 5, ' ');
            }
        }
    }
}

const nodeConstructors = {
    ArrayExpression,
    ArrayPattern,
    ArrowFunctionExpression,
    AssignmentExpression,
    AssignmentPattern,
    AwaitExpression,
    BinaryExpression,
    BlockStatement: BlockStatement$1,
    BreakStatement,
    CallExpression: CallExpression$1,
    CatchClause,
    ClassBody,
    ClassDeclaration,
    ClassExpression,
    ConditionalExpression,
    DoWhileStatement,
    EmptyStatement,
    ExportAllDeclaration: ExportAllDeclaration$1,
    ExportDefaultDeclaration,
    ExportNamedDeclaration,
    ExpressionStatement: ExpressionStatement$1,
    ForInStatement,
    ForOfStatement,
    ForStatement,
    FunctionDeclaration,
    FunctionExpression: FunctionExpression$1,
    Identifier: Identifier$1,
    IfStatement,
    Import,
    ImportDeclaration,
    LabeledStatement,
    Literal,
    LogicalExpression,
    MemberExpression,
    MetaProperty,
    MethodDefinition,
    NewExpression,
    ObjectExpression,
    ObjectPattern,
    Program: Program$1,
    Property: Property$1,
    RestElement,
    ReturnStatement: ReturnStatement$1,
    SequenceExpression,
    SpreadElement,
    SwitchCase,
    SwitchStatement,
    TaggedTemplateExpression,
    TemplateElement,
    TemplateLiteral,
    ThisExpression,
    ThrowStatement,
    TryStatement: NodeBase,
    UnaryExpression,
    UnknownNode,
    UpdateExpression,
    VariableDeclaration: VariableDeclaration$1,
    VariableDeclarator,
    WhileStatement,
    YieldExpression
};

function getOriginalLocation(sourcemapChain, location) {
    const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);
    while (filteredSourcemapChain.length > 0) {
        const sourcemap = filteredSourcemapChain.pop();
        const line = sourcemap.mappings[location.line - 1];
        let locationFound = false;
        if (line !== undefined) {
            for (const segment of line) {
                if (segment[0] >= location.column) {
                    if (segment.length < 4)
                        break;
                    location = {
                        column: segment[3],
                        line: segment[2] + 1,
                        name: sourcemap.names[segment[4]],
                        source: sourcemap.sources[segment[1]]
                    };
                    locationFound = true;
                    break;
                }
            }
        }
        if (!locationFound) {
            throw new Error("Can't resolve original location of error.");
        }
    }
    return location;
}

// AST walker module for Mozilla Parser API compatible trees

function skipThrough(node, st, c) { c(node, st); }
function ignore(_node, _st, _c) {}

// Node walkers.

var base$1 = {};

base$1.Program = base$1.BlockStatement = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
    {
    var stmt = list[i];

    c(stmt, st, "Statement");
  }
};
base$1.Statement = skipThrough;
base$1.EmptyStatement = ignore;
base$1.ExpressionStatement = base$1.ParenthesizedExpression =
  function (node, st, c) { return c(node.expression, st, "Expression"); };
base$1.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) { c(node.alternate, st, "Statement"); }
};
base$1.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
base$1.BreakStatement = base$1.ContinueStatement = ignore;
base$1.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) {
    var cs = list[i];

    if (cs.test) { c(cs.test, st, "Expression"); }
    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)
      {
      var cons = list$1[i$1];

      c(cons, st, "Statement");
    }
  }
};
base$1.SwitchCase = function (node, st, c) {
  if (node.test) { c(node.test, st, "Expression"); }
  for (var i = 0, list = node.consequent; i < list.length; i += 1)
    {
    var cons = list[i];

    c(cons, st, "Statement");
  }
};
base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {
  if (node.argument) { c(node.argument, st, "Expression"); }
};
base$1.ThrowStatement = base$1.SpreadElement =
  function (node, st, c) { return c(node.argument, st, "Expression"); };
base$1.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) { c(node.handler, st); }
  if (node.finalizer) { c(node.finalizer, st, "Statement"); }
};
base$1.CatchClause = function (node, st, c) {
  if (node.param) { c(node.param, st, "Pattern"); }
  c(node.body, st, "Statement");
};
base$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.ForStatement = function (node, st, c) {
  if (node.init) { c(node.init, st, "ForInit"); }
  if (node.test) { c(node.test, st, "Expression"); }
  if (node.update) { c(node.update, st, "Expression"); }
  c(node.body, st, "Statement");
};
base$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base$1.ForInit = function (node, st, c) {
  if (node.type === "VariableDeclaration") { c(node, st); }
  else { c(node, st, "Expression"); }
};
base$1.DebuggerStatement = ignore;

base$1.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
base$1.VariableDeclaration = function (node, st, c) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1)
    {
    var decl = list[i];

    c(decl, st);
  }
};
base$1.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) { c(node.init, st, "Expression"); }
};

base$1.Function = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};

base$1.Pattern = function (node, st, c) {
  if (node.type === "Identifier")
    { c(node, st, "VariablePattern"); }
  else if (node.type === "MemberExpression")
    { c(node, st, "MemberPattern"); }
  else
    { c(node, st); }
};
base$1.VariablePattern = ignore;
base$1.MemberPattern = skipThrough;
base$1.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
base$1.ArrayPattern = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];

    if (elt) { c(elt, st, "Pattern"); }
  }
};
base$1.ObjectPattern = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];

    if (prop.type === "Property") {
      if (prop.computed) { c(prop.key, st, "Expression"); }
      c(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c(prop.argument, st, "Pattern");
    }
  }
};

base$1.Expression = skipThrough;
base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
base$1.ArrayExpression = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];

    if (elt) { c(elt, st, "Expression"); }
  }
};
base$1.ObjectExpression = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1)
    {
    var prop = list[i];

    c(prop, st);
  }
};
base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
base$1.SequenceExpression = function (node, st, c) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1)
    {
    var expr = list[i];

    c(expr, st, "Expression");
  }
};
base$1.TemplateLiteral = function (node, st, c) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1)
    {
    var quasi = list[i];

    c(quasi, st);
  }

  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
    {
    var expr = list$1[i$1];

    c(expr, st, "Expression");
  }
};
base$1.TemplateElement = ignore;
base$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base$1.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base$1.NewExpression = base$1.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments)
    { for (var i = 0, list = node.arguments; i < list.length; i += 1)
      {
        var arg = list[i];

        c(arg, st, "Expression");
      } }
};
base$1.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) { c(node.property, st, "Expression"); }
};
base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration)
    { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
  if (node.source) { c(node.source, st, "Expression"); }
};
base$1.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
base$1.ImportDeclaration = function (node, st, c) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1)
    {
    var spec = list[i];

    c(spec, st);
  }
  c(node.source, st, "Expression");
};
base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.Literal = ignore;

base$1.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
base$1.Class = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  if (node.superClass) { c(node.superClass, st, "Expression"); }
  c(node.body, st);
};
base$1.ClassBody = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
    {
    var elt = list[i];

    c(elt, st);
  }
};
base$1.MethodDefinition = base$1.Property = function (node, st, c) {
  if (node.computed) { c(node.key, st, "Expression"); }
  c(node.value, st, "Expression");
};

// @ts-ignore
function handlePureAnnotationsOfNode(node, state, type = node.type) {
    let commentNode = state.commentNodes[state.commentIndex];
    while (commentNode && node.start >= commentNode.end) {
        markPureNode(node, commentNode);
        commentNode = state.commentNodes[++state.commentIndex];
    }
    if (commentNode && commentNode.end <= node.end) {
        base$1[type](node, state, handlePureAnnotationsOfNode);
    }
}
function markPureNode(node, comment) {
    if (node.annotations) {
        node.annotations.push(comment);
    }
    else {
        node.annotations = [comment];
    }
    if (node.type === 'ExpressionStatement') {
        node = node.expression;
    }
    if (node.type === 'CallExpression' || node.type === 'NewExpression') {
        node.annotatedPure = true;
    }
}
const pureCommentRegex = /[@#]__PURE__/;
const isPureComment = (comment) => pureCommentRegex.test(comment.text);
function markPureCallExpressions(comments, esTreeAst) {
    handlePureAnnotationsOfNode(esTreeAst, {
        commentIndex: 0,
        commentNodes: comments.filter(isPureComment)
    });
}

// this looks ridiculous, but it prevents sourcemap tooling from mistaking
// this for an actual sourceMappingURL
let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
const SOURCEMAPPING_URL_RE = new RegExp(`^#\\s+${SOURCEMAPPING_URL}=.+\\n?`);

const NOOP = () => { };
let getStartTime = () => 0;
let getElapsedTime = () => 0;
let getMemory = () => 0;
let timers = {};
const normalizeHrTime = (time) => time[0] * 1e3 + time[1] / 1e6;
function setTimeHelpers() {
    if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {
        getStartTime = process.hrtime.bind(process);
        getElapsedTime = (previous) => normalizeHrTime(process.hrtime(previous));
    }
    else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        getStartTime = performance.now.bind(performance);
        getElapsedTime = (previous) => performance.now() - previous;
    }
    if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {
        getMemory = () => process.memoryUsage().heapUsed;
    }
}
function getPersistedLabel(label, level) {
    switch (level) {
        case 1:
            return `# ${label}`;
        case 2:
            return `## ${label}`;
        case 3:
            return label;
        default:
            return `${'  '.repeat(level - 4)}- ${label}`;
    }
}
function timeStartImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    if (!timers.hasOwnProperty(label)) {
        timers[label] = {
            memory: 0,
            startMemory: undefined,
            startTime: undefined,
            time: 0,
            totalMemory: 0
        };
    }
    const currentMemory = getMemory();
    timers[label].startTime = getStartTime();
    timers[label].startMemory = currentMemory;
}
function timeEndImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    if (timers.hasOwnProperty(label)) {
        const currentMemory = getMemory();
        timers[label].time += getElapsedTime(timers[label].startTime);
        timers[label].totalMemory = Math.max(timers[label].totalMemory, currentMemory);
        timers[label].memory += currentMemory - timers[label].startMemory;
    }
}
function getTimings() {
    const newTimings = {};
    Object.keys(timers).forEach(label => {
        newTimings[label] = [timers[label].time, timers[label].memory, timers[label].totalMemory];
    });
    return newTimings;
}
let timeStart = NOOP, timeEnd = NOOP;
const TIMED_PLUGIN_HOOKS = {
    load: true,
    ongenerate: true,
    onwrite: true,
    resolveDynamicImport: true,
    resolveId: true,
    transform: true,
    transformBundle: true
};
function getPluginWithTimers(plugin, index) {
    const timedPlugin = {};
    for (const hook of Object.keys(plugin)) {
        if (TIMED_PLUGIN_HOOKS[hook] === true) {
            let timerLabel = `plugin ${index}`;
            if (plugin.name) {
                timerLabel += ` (${plugin.name})`;
            }
            timerLabel += ` - ${hook}`;
            timedPlugin[hook] = function () {
                timeStart(timerLabel, 4);
                const result = plugin[hook].apply(this === timedPlugin ? plugin : this, arguments);
                timeEnd(timerLabel, 4);
                if (result && typeof result.then === 'function') {
                    timeStart(`${timerLabel} (async)`, 4);
                    result.then(() => timeEnd(`${timerLabel} (async)`, 4));
                }
                return result;
            };
        }
        else {
            timedPlugin[hook] = plugin[hook];
        }
    }
    return timedPlugin;
}
function initialiseTimers(inputOptions) {
    if (inputOptions.perf) {
        timers = {};
        setTimeHelpers();
        timeStart = timeStartImpl;
        timeEnd = timeEndImpl;
        inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
    }
    else {
        timeStart = NOOP;
        timeEnd = NOOP;
    }
}

const defaultAcornOptions = {
    ecmaVersion: 2019,
    preserveParens: false,
    sourceType: 'module'
};
function tryParse(module, Parser, acornOptions) {
    try {
        return Parser.parse(module.code, Object.assign({}, defaultAcornOptions, acornOptions, { onComment: (block, text, start, end) => module.comments.push({ block, text, start, end }) }));
    }
    catch (err) {
        let message = err.message.replace(/ \(\d+:\d+\)$/, '');
        if (module.id.endsWith('.json')) {
            message += ' (Note that you need rollup-plugin-json to import JSON files)';
        }
        else if (!module.id.endsWith('.js')) {
            message += ' (Note that you need plugins to import files that are not JavaScript)';
        }
        module.error({
            code: 'PARSE_ERROR',
            message
        }, err.pos);
    }
}
function handleMissingExport(exportName, importingModule, importedModule, importerStart) {
    importingModule.error({
        code: 'MISSING_EXPORT',
        message: `'${exportName}' is not exported by ${relativeId(importedModule)}`,
        url: `https://rollupjs.org/guide/en#error-name-is-not-exported-by-module-`
    }, importerStart);
}
const MISSING_EXPORT_SHIM_DESCRIPTION = {
    identifier: null,
    localName: MISSING_EXPORT_SHIM_VARIABLE
};
class Module {
    constructor(graph, id, moduleSideEffects, isEntry) {
        this.chunkAlias = null;
        this.comments = [];
        this.dependencies = [];
        this.dynamicallyImportedBy = [];
        this.dynamicDependencies = [];
        this.dynamicImports = [];
        this.entryPointsHash = new Uint8Array(10);
        this.execIndex = Infinity;
        this.exportAllModules = null;
        this.exportAllSources = [];
        this.exports = Object.create(null);
        this.exportsAll = Object.create(null);
        this.exportShimVariable = new ExportShimVariable(this);
        this.facadeChunk = null;
        this.importDescriptions = Object.create(null);
        this.importMetas = [];
        this.imports = new Set();
        this.isExecuted = false;
        this.isUserDefinedEntryPoint = false;
        this.manualChunkAlias = null;
        this.reexports = Object.create(null);
        this.sources = [];
        this.usesTopLevelAwait = false;
        this.namespaceVariable = undefined;
        this.id = id;
        this.graph = graph;
        this.excludeFromSourcemap = /\0/.test(id);
        this.context = graph.getModuleContext(id);
        this.moduleSideEffects = moduleSideEffects;
        this.isEntryPoint = isEntry;
    }
    basename() {
        const base = basename(this.id);
        const ext = extname(this.id);
        return makeLegal(ext ? base.slice(0, -ext.length) : base);
    }
    bindReferences() {
        this.ast.bind();
    }
    error(props, pos) {
        if (pos !== undefined) {
            props.pos = pos;
            let location = locate(this.code, pos, { offsetLine: 1 });
            try {
                location = getOriginalLocation(this.sourcemapChain, location);
            }
            catch (e) {
                this.warn({
                    code: 'SOURCEMAP_ERROR',
                    loc: {
                        column: location.column,
                        file: this.id,
                        line: location.line
                    },
                    message: `Error when using sourcemap for reporting an error: ${e.message}`,
                    pos
                }, undefined);
            }
            props.loc = {
                column: location.column,
                file: this.id,
                line: location.line
            };
            props.frame = getCodeFrame(this.originalCode, location.line, location.column);
        }
        error(props);
    }
    getAllExports() {
        const allExports = Object.assign(Object.create(null), this.exports, this.reexports);
        this.exportAllModules.forEach(module => {
            if (module.isExternal) {
                allExports[`*${module.id}`] = true;
                return;
            }
            for (const name of module.getAllExports()) {
                if (name !== 'default')
                    allExports[name] = true;
            }
        });
        return Object.keys(allExports);
    }
    getDynamicImportExpressions() {
        return this.dynamicImports.map(({ node }) => {
            const importArgument = node.parent.arguments[0];
            if (importArgument instanceof TemplateLiteral) {
                if (importArgument.expressions.length === 0 && importArgument.quasis.length === 1) {
                    return importArgument.quasis[0].value.cooked;
                }
            }
            else if (importArgument instanceof Literal) {
                if (typeof importArgument.value === 'string') {
                    return importArgument.value;
                }
            }
            else {
                return importArgument;
            }
            return undefined;
        });
    }
    getExports() {
        return Object.keys(this.exports);
    }
    getOrCreateNamespace() {
        return (this.namespaceVariable || (this.namespaceVariable = new NamespaceVariable(this.astContext)));
    }
    getReexports() {
        if (this.transitiveReexports) {
            return this.transitiveReexports;
        }
        // to avoid infinite recursion when using circular `export * from X`
        this.transitiveReexports = [];
        const reexports = new Set();
        for (const name in this.reexports) {
            reexports.add(name);
        }
        for (const module of this.exportAllModules) {
            if (module instanceof ExternalModule) {
                reexports.add(`*${module.id}`);
            }
            else {
                for (const name of module.getExports().concat(module.getReexports())) {
                    if (name !== 'default')
                        reexports.add(name);
                }
            }
        }
        return (this.transitiveReexports = Array.from(reexports));
    }
    getRenderedExports() {
        // only direct exports are counted here, not reexports at all
        const renderedExports = [];
        const removedExports = [];
        for (const exportName in this.exports) {
            const variable = this.getVariableForExportName(exportName);
            (variable && variable.included ? renderedExports : removedExports).push(exportName);
        }
        return { renderedExports, removedExports };
    }
    getTransitiveDependencies() {
        return this.dependencies.concat(this.getReexports().map(exportName => this.getVariableForExportName(exportName).module));
    }
    getVariableForExportName(name, isExportAllSearch) {
        if (name[0] === '*') {
            if (name.length === 1) {
                return this.getOrCreateNamespace();
            }
            else {
                // export * from 'external'
                const module = this.graph.moduleById.get(name.slice(1));
                return module.getVariableForExportName('*');
            }
        }
        // export { foo } from './other'
        const reexportDeclaration = this.reexports[name];
        if (reexportDeclaration) {
            const declaration = reexportDeclaration.module.getVariableForExportName(reexportDeclaration.localName);
            if (!declaration) {
                handleMissingExport(reexportDeclaration.localName, this, reexportDeclaration.module.id, reexportDeclaration.start);
            }
            return declaration;
        }
        const exportDeclaration = this.exports[name];
        if (exportDeclaration) {
            if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
                return this.exportShimVariable;
            }
            const name = exportDeclaration.localName;
            return this.traceVariable(name) || this.graph.scope.findVariable(name);
        }
        if (name !== 'default') {
            for (let i = 0; i < this.exportAllModules.length; i += 1) {
                const module = this.exportAllModules[i];
                const declaration = module.getVariableForExportName(name, true);
                if (declaration)
                    return declaration;
            }
        }
        // we don't want to create shims when we are just
        // probing export * modules for exports
        if (this.graph.shimMissingExports && !isExportAllSearch) {
            this.shimMissingExport(name);
            return this.exportShimVariable;
        }
        return undefined;
    }
    include() {
        if (this.ast.shouldBeIncluded())
            this.ast.include(false);
    }
    includeAllExports() {
        if (!this.isExecuted) {
            this.graph.needsTreeshakingPass = true;
            markModuleAndImpureDependenciesAsExecuted(this);
        }
        for (const exportName of this.getExports()) {
            const variable = this.getVariableForExportName(exportName);
            variable.deoptimizePath(UNKNOWN_PATH);
            if (!variable.included) {
                variable.include();
                this.graph.needsTreeshakingPass = true;
            }
        }
        for (const name of this.getReexports()) {
            const variable = this.getVariableForExportName(name);
            if (variable.isExternal) {
                variable.reexported = variable.module.reexported = true;
            }
            else if (!variable.included) {
                variable.include();
                variable.deoptimizePath(UNKNOWN_PATH);
                this.graph.needsTreeshakingPass = true;
            }
        }
    }
    includeAllInBundle() {
        this.ast.include(true);
    }
    isIncluded() {
        return this.ast.included || (this.namespaceVariable && this.namespaceVariable.included);
    }
    linkDependencies() {
        for (const source of this.sources) {
            const id = this.resolvedIds[source].id;
            if (id) {
                const module = this.graph.moduleById.get(id);
                this.dependencies.push(module);
            }
        }
        for (const { resolution } of this.dynamicImports) {
            if (resolution instanceof Module || resolution instanceof ExternalModule) {
                this.dynamicDependencies.push(resolution);
            }
        }
        this.addModulesToSpecifiers(this.importDescriptions);
        this.addModulesToSpecifiers(this.reexports);
        this.exportAllModules = this.exportAllSources.map(source => {
            const id = this.resolvedIds[source].id;
            return this.graph.moduleById.get(id);
        });
    }
    render(options) {
        const magicString = this.magicString.clone();
        this.ast.render(magicString, options);
        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
        return magicString;
    }
    setSource({ ast, code, customTransformCache, moduleSideEffects, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies }) {
        this.code = code;
        this.originalCode = originalCode;
        this.originalSourcemap = originalSourcemap;
        this.sourcemapChain = sourcemapChain;
        this.transformDependencies = transformDependencies;
        this.customTransformCache = customTransformCache;
        if (typeof moduleSideEffects === 'boolean') {
            this.moduleSideEffects = moduleSideEffects;
        }
        timeStart('generate ast', 3);
        this.esTreeAst = ast || tryParse(this, this.graph.acornParser, this.graph.acornOptions);
        markPureCallExpressions(this.comments, this.esTreeAst);
        timeEnd('generate ast', 3);
        this.resolvedIds = resolvedIds || Object.create(null);
        // By default, `id` is the file name. Custom resolvers and loaders
        // can change that, but it makes sense to use it for the source file name
        const fileName = this.id;
        this.magicString = new MagicString(code, {
            filename: (this.excludeFromSourcemap ? null : fileName),
            indentExclusionRanges: []
        });
        this.removeExistingSourceMap();
        timeStart('analyse ast', 3);
        this.astContext = {
            addDynamicImport: this.addDynamicImport.bind(this),
            addExport: this.addExport.bind(this),
            addImport: this.addImport.bind(this),
            addImportMeta: this.addImportMeta.bind(this),
            annotations: (this.graph.treeshake && this.graph.treeshakingOptions.annotations),
            code,
            deoptimizationTracker: this.graph.deoptimizationTracker,
            error: this.error.bind(this),
            fileName,
            getAssetFileName: this.graph.pluginDriver.getAssetFileName,
            getChunkFileName: this.graph.moduleLoader.getChunkFileName.bind(this.graph.moduleLoader),
            getExports: this.getExports.bind(this),
            getModuleExecIndex: () => this.execIndex,
            getModuleName: this.basename.bind(this),
            getReexports: this.getReexports.bind(this),
            importDescriptions: this.importDescriptions,
            includeDynamicImport: this.includeDynamicImport.bind(this),
            includeVariable: this.includeVariable.bind(this),
            isCrossChunkImport: importDescription => importDescription.module.chunk !== this.chunk,
            magicString: this.magicString,
            module: this,
            moduleContext: this.context,
            nodeConstructors,
            preserveModules: this.graph.preserveModules,
            propertyReadSideEffects: (!this.graph.treeshake ||
                this.graph.treeshakingOptions.propertyReadSideEffects),
            traceExport: this.getVariableForExportName.bind(this),
            traceVariable: this.traceVariable.bind(this),
            treeshake: this.graph.treeshake,
            usesTopLevelAwait: false,
            warn: this.warn.bind(this)
        };
        this.scope = new ModuleScope(this.graph.scope, this.astContext);
        this.ast = new Program$1(this.esTreeAst, { type: 'Module', context: this.astContext }, this.scope);
        timeEnd('analyse ast', 3);
    }
    toJSON() {
        return {
            ast: this.esTreeAst,
            code: this.code,
            customTransformCache: this.customTransformCache,
            dependencies: this.dependencies.map(module => module.id),
            id: this.id,
            moduleSideEffects: this.moduleSideEffects,
            originalCode: this.originalCode,
            originalSourcemap: this.originalSourcemap,
            resolvedIds: this.resolvedIds,
            sourcemapChain: this.sourcemapChain,
            transformAssets: this.transformAssets,
            transformDependencies: this.transformDependencies
        };
    }
    traceVariable(name) {
        if (name in this.scope.variables) {
            return this.scope.variables[name];
        }
        if (name in this.importDescriptions) {
            const importDeclaration = this.importDescriptions[name];
            const otherModule = importDeclaration.module;
            if (!otherModule.isExternal && importDeclaration.name === '*') {
                return otherModule.getOrCreateNamespace();
            }
            const declaration = otherModule.getVariableForExportName(importDeclaration.name);
            if (!declaration) {
                handleMissingExport(importDeclaration.name, this, otherModule.id, importDeclaration.start);
            }
            return declaration;
        }
        return null;
    }
    warn(warning, pos) {
        if (pos !== undefined) {
            warning.pos = pos;
            const { line, column } = locate(this.code, pos, { offsetLine: 1 }); // TODO trace sourcemaps, cf. error()
            warning.loc = { file: this.id, line, column };
            warning.frame = getCodeFrame(this.code, line, column);
        }
        warning.id = this.id;
        this.graph.warn(warning);
    }
    addDynamicImport(node) {
        this.dynamicImports.push({ node, resolution: undefined });
    }
    addExport(node) {
        const source = node.source && node.source.value;
        // export { name } from './other'
        if (source) {
            if (this.sources.indexOf(source) === -1)
                this.sources.push(source);
            if (node.type === ExportAllDeclaration) {
                // Store `export * from '...'` statements in an array of delegates.
                // When an unknown import is encountered, we see if one of them can satisfy it.
                this.exportAllSources.push(source);
            }
            else {
                for (const specifier of node.specifiers) {
                    const name = specifier.exported.name;
                    if (this.exports[name] || this.reexports[name]) {
                        this.error({
                            code: 'DUPLICATE_EXPORT',
                            message: `A module cannot have multiple exports with the same name ('${name}')`
                        }, specifier.start);
                    }
                    this.reexports[name] = {
                        localName: specifier.local.name,
                        module: null,
                        source,
                        start: specifier.start
                    };
                }
            }
        }
        else if (node instanceof ExportDefaultDeclaration) {
            // export default function foo () {}
            // export default foo;
            // export default 42;
            if (this.exports.default) {
                this.error({
                    code: 'DUPLICATE_EXPORT',
                    message: `A module can only have one default export`
                }, node.start);
            }
            this.exports.default = {
                identifier: node.variable.getAssignedVariableName(),
                localName: 'default'
            };
        }
        else if (node.declaration) {
            // export var { foo, bar } = ...
            // export var foo = 42;
            // export var a = 1, b = 2, c = 3;
            // export function foo () {}
            const declaration = node.declaration;
            if (declaration.type === VariableDeclaration) {
                for (const decl of declaration.declarations) {
                    for (const localName of extractAssignedNames(decl.id)) {
                        this.exports[localName] = { identifier: null, localName };
                    }
                }
            }
            else {
                // export function foo () {}
                const localName = declaration.id.name;
                this.exports[localName] = { identifier: null, localName };
            }
        }
        else {
            // export { foo, bar, baz }
            for (const specifier of node.specifiers) {
                const localName = specifier.local.name;
                const exportedName = specifier.exported.name;
                if (this.exports[exportedName] || this.reexports[exportedName]) {
                    this.error({
                        code: 'DUPLICATE_EXPORT',
                        message: `A module cannot have multiple exports with the same name ('${exportedName}')`
                    }, specifier.start);
                }
                this.exports[exportedName] = { identifier: null, localName };
            }
        }
    }
    addImport(node) {
        const source = node.source.value;
        if (this.sources.indexOf(source) === -1)
            this.sources.push(source);
        for (const specifier of node.specifiers) {
            const localName = specifier.local.name;
            if (this.importDescriptions[localName]) {
                this.error({
                    code: 'DUPLICATE_IMPORT',
                    message: `Duplicated import '${localName}'`
                }, specifier.start);
            }
            const isDefault = specifier.type === ImportDefaultSpecifier;
            const isNamespace = specifier.type === ImportNamespaceSpecifier;
            const name = isDefault
                ? 'default'
                : isNamespace
                    ? '*'
                    : specifier.imported.name;
            this.importDescriptions[localName] = { source, start: specifier.start, name, module: null };
        }
    }
    addImportMeta(node) {
        this.importMetas.push(node);
    }
    addModulesToSpecifiers(specifiers) {
        for (const name of Object.keys(specifiers)) {
            const specifier = specifiers[name];
            const id = this.resolvedIds[specifier.source].id;
            specifier.module = this.graph.moduleById.get(id);
        }
    }
    includeDynamicImport(node) {
        const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;
        if (resolution instanceof Module) {
            resolution.dynamicallyImportedBy.push(this);
            resolution.includeAllExports();
        }
    }
    includeVariable(variable) {
        const variableModule = variable.module;
        if (!variable.included) {
            variable.include();
            this.graph.needsTreeshakingPass = true;
        }
        if (variableModule && variableModule !== this) {
            this.imports.add(variable);
        }
    }
    removeExistingSourceMap() {
        for (const comment of this.comments) {
            if (!comment.block && SOURCEMAPPING_URL_RE.test(comment.text)) {
                this.magicString.remove(comment.start, comment.end);
            }
        }
    }
    shimMissingExport(name) {
        if (!this.exports[name]) {
            this.graph.warn({
                code: 'SHIMMED_EXPORT',
                exporter: relativeId(this.id),
                exportName: name,
                message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
            });
            this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;
        }
    }
}

class Source {
    constructor(filename, content) {
        this.isOriginal = true;
        this.filename = filename;
        this.content = content;
    }
    traceSegment(line, column, name) {
        return { line, column, name, source: this };
    }
}
class Link {
    constructor(map, sources) {
        this.sources = sources;
        this.names = map.names;
        this.mappings = map.mappings;
    }
    traceMappings() {
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const mappings = [];
        for (const line of this.mappings) {
            const tracedLine = [];
            for (const segment of line) {
                const source = this.sources[segment[1]];
                if (!source)
                    continue;
                const traced = source.traceSegment(segment[2], segment[3], this.names[segment[4]]);
                if (traced) {
                    // newer sources are more likely to be used, so search backwards.
                    let sourceIndex = sources.lastIndexOf(traced.source.filename);
                    if (sourceIndex === -1) {
                        sourceIndex = sources.length;
                        sources.push(traced.source.filename);
                        sourcesContent[sourceIndex] = traced.source.content;
                    }
                    else if (sourcesContent[sourceIndex] == null) {
                        sourcesContent[sourceIndex] = traced.source.content;
                    }
                    else if (traced.source.content != null &&
                        sourcesContent[sourceIndex] !== traced.source.content) {
                        error({
                            message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`
                        });
                    }
                    const tracedSegment = [
                        segment[0],
                        sourceIndex,
                        traced.line,
                        traced.column
                    ];
                    if (traced.name) {
                        let nameIndex = names.indexOf(traced.name);
                        if (nameIndex === -1) {
                            nameIndex = names.length;
                            names.push(traced.name);
                        }
                        tracedSegment[4] = nameIndex;
                    }
                    tracedLine.push(tracedSegment);
                }
            }
            mappings.push(tracedLine);
        }
        return { sources, sourcesContent, names, mappings };
    }
    traceSegment(line, column, name) {
        const segments = this.mappings[line];
        if (!segments)
            return null;
        // binary search through segments for the given column
        let i = 0;
        let j = segments.length - 1;
        while (i <= j) {
            const m = (i + j) >> 1;
            const segment = segments[m];
            if (segment[0] === column) {
                const source = this.sources[segment[1]];
                if (!source)
                    return null;
                return source.traceSegment(segment[2], segment[3], this.names[segment[4]] || name);
            }
            if (segment[0] > column) {
                j = m - 1;
            }
            else {
                i = m + 1;
            }
        }
        return null;
    }
}
// TODO TypeScript: Fix <any> typecasts
function collapseSourcemaps(bundle, file, map, modules, bundleSourcemapChain, excludeContent) {
    function linkMap(source, map) {
        if (map.missing) {
            bundle.graph.warn({
                code: 'SOURCEMAP_BROKEN',
                message: `Sourcemap is likely to be incorrect: a plugin${map.plugin ? ` ('${map.plugin}')` : ``} was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
                plugin: map.plugin,
                url: `https://rollupjs.org/guide/en#warning-sourcemap-is-likely-to-be-incorrect`
            });
            map = {
                mappings: '',
                names: []
            };
        }
        return new Link(map, [source]);
    }
    const moduleSources = modules
        .filter(module => !module.excludeFromSourcemap)
        .map(module => {
        let sourcemapChain = module.sourcemapChain;
        let source;
        const originalSourcemap = module.originalSourcemap;
        if (!originalSourcemap) {
            source = new Source(module.id, module.originalCode);
        }
        else {
            const sources = originalSourcemap.sources;
            const sourcesContent = originalSourcemap.sourcesContent || [];
            if (sources == null || (sources.length <= 1 && sources[0] == null)) {
                source = new Source(module.id, sourcesContent[0]);
                sourcemapChain = [originalSourcemap].concat(sourcemapChain);
            }
            else {
                // TODO indiscriminately treating IDs and sources as normal paths is probably bad.
                const directory = dirname(module.id) || '.';
                const sourceRoot = originalSourcemap.sourceRoot || '.';
                const baseSources = sources.map((source, i) => new Source(resolve$1(directory, sourceRoot, source), sourcesContent[i]));
                source = new Link(originalSourcemap, baseSources);
            }
        }
        source = sourcemapChain.reduce(linkMap, source);
        return source;
    });
    let source = new Link(map, moduleSources);
    source = bundleSourcemapChain.reduce(linkMap, source);
    let { sources, sourcesContent, names, mappings } = source.traceMappings();
    if (file) {
        const directory = dirname(file);
        sources = sources.map((source) => relative(directory, source));
        file = basename(file);
    }
    sourcesContent = (excludeContent ? null : sourcesContent);
    return new SourceMap({ file, sources, sourcesContent, names, mappings });
}

const DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
    amd: deconflictImportsOther,
    cjs: deconflictImportsOther,
    es: deconflictImportsEsm,
    iife: deconflictImportsOther,
    system: deconflictImportsEsm,
    umd: deconflictImportsOther
};
function deconflictChunk(modules, dependencies, imports, usedNames, format, interop, preserveModules) {
    const { forbiddenNames, formatGlobals } = RESERVED_NAMES_BY_FORMAT[format];
    Object.assign(usedNames, forbiddenNames);
    Object.assign(usedNames, formatGlobals);
    addUsedGlobalNames(usedNames, modules);
    deconflictTopLevelVariables(usedNames, modules);
    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependencies, interop, preserveModules);
    for (const module of modules) {
        module.scope.deconflict(forbiddenNames);
    }
}
function addUsedGlobalNames(usedNames, modules) {
    const accessedGlobals = Object.assign({}, ...modules.map(module => module.scope.accessedOutsideVariables));
    for (const name of Object.keys(accessedGlobals)) {
        const variable = accessedGlobals[name];
        if (variable.included) {
            usedNames[name] = true;
        }
    }
}
function deconflictImportsEsm(usedNames, imports, _dependencies, interop) {
    for (const variable of imports) {
        const module = variable.module;
        const name = variable.name;
        let proposedName;
        if (module instanceof ExternalModule && (name === '*' || name === 'default')) {
            if (name === 'default' && interop && module.exportsNamespace) {
                proposedName = module.variableName + '__default';
            }
            else {
                proposedName = module.variableName;
            }
        }
        else {
            proposedName = name;
        }
        variable.setRenderNames(null, getSafeName(proposedName, usedNames));
    }
}
function deconflictImportsOther(usedNames, imports, dependencies, interop, preserveModules) {
    for (const chunkOrExternalModule of dependencies) {
        chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.variableName, usedNames);
    }
    for (const variable of imports) {
        const module = variable.module;
        if (module instanceof ExternalModule) {
            const name = variable.name;
            if (name === 'default' && interop && (module.exportsNamespace || module.exportsNames)) {
                variable.setRenderNames(null, module.variableName + '__default');
            }
            else if (name === '*' || name === 'default') {
                variable.setRenderNames(null, module.variableName);
            }
            else {
                variable.setRenderNames(module.variableName, null);
            }
        }
        else {
            const chunk = module.chunk;
            if (chunk.exportMode === 'default' || (preserveModules && variable.isNamespace)) {
                variable.setRenderNames(null, chunk.variableName);
            }
            else {
                variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));
            }
        }
    }
}
function deconflictTopLevelVariables(usedNames, modules) {
    for (const module of modules) {
        const moduleVariables = module.scope.variables;
        for (const name of Object.keys(moduleVariables)) {
            const variable = moduleVariables[name];
            if (variable.included &&
                // this will only happen for exports in some formats
                !(variable.renderBaseName ||
                    (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {
                variable.setRenderNames(null, getSafeName(variable.name, usedNames));
            }
        }
        const namespace = module.getOrCreateNamespace();
        if (namespace.included) {
            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
        }
    }
}

const compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;
function sortByExecutionOrder(units) {
    units.sort(compareExecIndex);
}
function analyseModuleExecution(entryModules) {
    let nextExecIndex = 0;
    const cyclePaths = [];
    const analysedModules = {};
    const orderedModules = [];
    const dynamicImports = [];
    const parents = {};
    const analyseModule = (module) => {
        if (analysedModules[module.id])
            return;
        if (module instanceof ExternalModule) {
            module.execIndex = nextExecIndex++;
            analysedModules[module.id] = true;
            return;
        }
        for (const dependency of module.dependencies) {
            if (dependency.id in parents) {
                if (!analysedModules[dependency.id]) {
                    cyclePaths.push(getCyclePath(dependency.id, module.id, parents));
                }
                continue;
            }
            parents[dependency.id] = module.id;
            analyseModule(dependency);
        }
        for (const { resolution } of module.dynamicImports) {
            if (resolution instanceof Module && dynamicImports.indexOf(resolution) === -1) {
                dynamicImports.push(resolution);
            }
        }
        module.execIndex = nextExecIndex++;
        analysedModules[module.id] = true;
        orderedModules.push(module);
    };
    for (const curEntry of entryModules) {
        if (!parents[curEntry.id]) {
            parents[curEntry.id] = null;
            analyseModule(curEntry);
        }
    }
    for (const curEntry of dynamicImports) {
        if (!parents[curEntry.id]) {
            parents[curEntry.id] = null;
            analyseModule(curEntry);
        }
    }
    return { orderedModules, cyclePaths };
}
function getCyclePath(id, parentId, parents) {
    const path = [relativeId(id)];
    let curId = parentId;
    while (curId !== id) {
        path.push(relativeId(curId));
        curId = parents[curId];
        if (!curId)
            break;
    }
    path.push(path[0]);
    path.reverse();
    return path;
}

function guessIndentString(code) {
    const lines = code.split('\n');
    const tabbed = lines.filter(line => /^\t+/.test(line));
    const spaced = lines.filter(line => /^ {2,}/.test(line));
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    const min = spaced.reduce((previous, current) => {
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getIndentString(modules, options) {
    if (options.indent !== true)
        return options.indent || '';
    for (let i = 0; i < modules.length; i++) {
        const indent = guessIndentString(modules[i].originalCode);
        if (indent !== null)
            return indent;
    }
    return '\t';
}

function renderChunk({ graph, chunk, renderChunk, code, sourcemapChain, options }) {
    const renderChunkReducer = (code, result, plugin) => {
        if (result == null)
            return code;
        if (typeof result === 'string')
            result = {
                code: result,
                map: undefined
            };
        const map = typeof result.map === 'string' ? JSON.parse(result.map) : result.map;
        if (map && typeof map.mappings === 'string')
            map.mappings = decode(map.mappings);
        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
        if (map !== null)
            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
        return result.code;
    };
    let inTransformBundle = false;
    let inRenderChunk = true;
    return graph.pluginDriver
        .hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer)
        .then(code => {
        inRenderChunk = false;
        return graph.pluginDriver.hookReduceArg0('transformChunk', [code, options, chunk], renderChunkReducer);
    })
        .then(code => {
        inTransformBundle = true;
        return graph.pluginDriver.hookReduceArg0('transformBundle', [code, options, chunk], renderChunkReducer);
    })
        .catch(err => {
        if (inRenderChunk)
            throw err;
        error(err, {
            code: inTransformBundle ? 'BAD_BUNDLE_TRANSFORMER' : 'BAD_CHUNK_TRANSFORMER',
            message: `Error transforming ${(inTransformBundle ? 'bundle' : 'chunk') +
                (err.plugin ? ` with '${err.plugin}' plugin` : '')}: ${err.message}`,
            plugin: err.plugin
        });
    });
}

function renderNamePattern(pattern, patternName, getReplacement) {
    if (!isPlainName(pattern))
        error({
            code: 'INVALID_PATTERN',
            message: `Invalid output pattern "${pattern}" for ${patternName}, cannot be an absolute or relative URL or path.`
        });
    return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
        const replacement = getReplacement(type);
        if (replacement === undefined)
            error({
                code: 'INVALID_PATTERN_REPLACEMENT',
                message: `"${type}" is not a valid substitution name in output option ${patternName} pattern.`
            });
        if (!isPlainName(replacement))
            error({
                code: 'INVALID_PATTERN_REPLACEMENT',
                message: `Invalid replacement "${replacement}" for "${type}" in ${patternName} pattern, must be a plain path name.`
            });
        return replacement;
    });
}
function makeUnique(name, existingNames) {
    if (name in existingNames === false)
        return name;
    const ext = extname(name);
    name = name.substr(0, name.length - ext.length);
    let uniqueName, uniqueIndex = 1;
    while (existingNames[(uniqueName = name + ++uniqueIndex + ext)])
        ;
    return uniqueName;
}

function sanitizeFileName(name) {
    return name.replace(/[\0?*]/g, '_');
}

function getGlobalName(module, globals, graph, hasExports) {
    let globalName;
    if (typeof globals === 'function') {
        globalName = globals(module.id);
    }
    else if (globals) {
        globalName = globals[module.id];
    }
    if (globalName) {
        return globalName;
    }
    if (hasExports) {
        graph.warn({
            code: 'MISSING_GLOBAL_NAME',
            guess: module.variableName,
            message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,
            source: module.id
        });
        return module.variableName;
    }
}
function isChunkRendered(chunk) {
    return !chunk.isEmpty || chunk.entryModules.length > 0 || chunk.manualChunkAlias !== null;
}
class Chunk$1 {
    constructor(graph, orderedModules) {
        this.entryModules = [];
        this.exportMode = 'named';
        this.facadeModule = null;
        this.hasDynamicImport = false;
        this.id = undefined;
        this.indentString = undefined;
        this.manualChunkAlias = null;
        this.usedModules = undefined;
        this.dependencies = undefined;
        this.dynamicDependencies = undefined;
        this.exportNames = Object.create(null);
        this.exports = new Set();
        this.imports = new Set();
        this.needsExportsShim = false;
        this.renderedDeclarations = undefined;
        this.renderedHash = undefined;
        this.renderedModuleSources = undefined;
        this.renderedSource = null;
        this.renderedSourceLength = undefined;
        this.sortedExportNames = null;
        this.graph = graph;
        this.orderedModules = orderedModules;
        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
        this.isEmpty = true;
        for (const module of orderedModules) {
            if (this.isEmpty && module.isIncluded()) {
                this.isEmpty = false;
            }
            if (module.manualChunkAlias) {
                this.manualChunkAlias = module.manualChunkAlias;
            }
            module.chunk = this;
            if (module.isEntryPoint ||
                module.dynamicallyImportedBy.some(module => orderedModules.indexOf(module) === -1)) {
                this.entryModules.push(module);
            }
        }
        const entryModule = this.entryModules[0];
        if (entryModule) {
            this.variableName = makeLegal(basename(entryModule.chunkAlias || entryModule.manualChunkAlias || getAliasName(entryModule.id)));
        }
        else {
            this.variableName = '__chunk_' + ++graph.curChunkIndex;
        }
    }
    generateEntryExportsOrMarkAsTainted() {
        const exportVariableMaps = this.entryModules.map(module => ({
            map: this.getVariableExportNamesForModule(module),
            module
        }));
        for (const { map } of exportVariableMaps) {
            for (const exposedVariable of map.keys()) {
                this.exports.add(exposedVariable);
            }
        }
        checkNextEntryModule: for (const { map, module } of exportVariableMaps) {
            if (!this.graph.preserveModules) {
                if (this.manualChunkAlias &&
                    module.chunkAlias &&
                    this.manualChunkAlias !== module.chunkAlias) {
                    continue checkNextEntryModule;
                }
                for (const exposedVariable of this.exports) {
                    if (!map.has(exposedVariable)) {
                        continue checkNextEntryModule;
                    }
                }
            }
            this.facadeModule = module;
            for (const [variable, exportNames] of map) {
                for (const exportName of exportNames) {
                    this.exportNames[exportName] = variable;
                }
            }
            return;
        }
    }
    generateId(pattern, patternName, addons, options, existingNames) {
        this.id = makeUnique(renderNamePattern(pattern, patternName, type => {
            switch (type) {
                case 'format':
                    return options.format === 'es' ? 'esm' : options.format;
                case 'hash':
                    return this.computeContentHashWithDependencies(addons, options);
                case 'name':
                    return this.getChunkName();
            }
            return undefined;
        }), existingNames);
    }
    generateIdPreserveModules(preserveModulesRelativeDir, existingNames) {
        const sanitizedId = sanitizeFileName(this.orderedModules[0].id);
        this.id = makeUnique(normalize(isAbsolute(this.orderedModules[0].id)
            ? relative(preserveModulesRelativeDir, sanitizedId)
            : '_virtual/' + basename(sanitizedId)), existingNames);
    }
    generateInternalExports(options) {
        if (this.facadeModule !== null)
            return;
        const mangle = options.format === 'system' || options.format === 'es' || options.compact;
        let i = 0, safeExportName;
        this.exportNames = Object.create(null);
        this.sortedExportNames = null;
        if (mangle) {
            for (const variable of this.exports) {
                do {
                    safeExportName = toBase64(++i);
                    // skip past leading number identifiers
                    if (safeExportName.charCodeAt(0) === 49 /* '1' */) {
                        i += 9 * Math.pow(64, (safeExportName.length - 1));
                        safeExportName = toBase64(i);
                    }
                } while (RESERVED_NAMES[safeExportName]);
                this.exportNames[safeExportName] = variable;
            }
        }
        else {
            for (const variable of this.exports) {
                i = 0;
                safeExportName = variable.name;
                while (this.exportNames[safeExportName]) {
                    safeExportName = variable.name + '$' + ++i;
                }
                this.exportNames[safeExportName] = variable;
            }
        }
    }
    getChunkName() {
        return this.chunkName || (this.chunkName = this.computeChunkName());
    }
    getDynamicImportIds() {
        return this.dynamicDependencies.map(chunk => chunk.id).filter(Boolean);
    }
    getExportNames() {
        return (this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportNames).sort()));
    }
    getImportIds() {
        return this.dependencies.map(chunk => chunk.id);
    }
    getRenderedHash() {
        if (this.renderedHash)
            return this.renderedHash;
        if (!this.renderedSource)
            return '';
        const hash = _256();
        hash.update(this.renderedSource.toString());
        hash.update(this.getExportNames()
            .map(exportName => {
            const variable = this.exportNames[exportName];
            return `${relativeId(variable.module.id).replace(/\\/g, '/')}:${variable.name}:${exportName}`;
        })
            .join(','));
        return (this.renderedHash = hash.digest('hex'));
    }
    getRenderedSourceLength() {
        if (this.renderedSourceLength !== undefined)
            return this.renderedSourceLength;
        return (this.renderedSourceLength = this.renderedSource.length());
    }
    getVariableExportName(variable) {
        if (this.graph.preserveModules && variable instanceof NamespaceVariable) {
            return '*';
        }
        for (const exportName of Object.keys(this.exportNames)) {
            if (this.exportNames[exportName] === variable)
                return exportName;
        }
    }
    link() {
        const dependencies = new Set();
        const dynamicDependencies = new Set();
        for (const module of this.orderedModules) {
            this.addChunksFromDependencies(module.getTransitiveDependencies(), dependencies);
            this.addChunksFromDependencies(module.dynamicDependencies, dynamicDependencies);
            this.setUpModuleImports(module);
        }
        this.dependencies = Array.from(dependencies);
        this.dynamicDependencies = Array.from(dynamicDependencies);
    }
    /*
     * Performs a full merge of another chunk into this chunk
     * chunkList allows updating references in other chunks for the merged chunk to this chunk
     * A new facade will be added to chunkList if tainting exports of either as an entry point
     */
    merge(chunk, chunkList, options, inputBase) {
        if (this.facadeModule !== null || chunk.facadeModule !== null)
            throw new Error('Internal error: Code splitting chunk merges not supported for facades');
        for (const module of chunk.orderedModules) {
            module.chunk = this;
            this.orderedModules.push(module);
        }
        for (const variable of chunk.imports) {
            if (!this.imports.has(variable) && variable.module.chunk !== this) {
                this.imports.add(variable);
            }
        }
        // NB detect when exported variables are orphaned by the merge itself
        // (involves reverse tracing dependents)
        for (const variable of chunk.exports) {
            if (!this.exports.has(variable)) {
                this.exports.add(variable);
            }
        }
        const thisOldExportNames = this.exportNames;
        // regenerate internal names
        this.generateInternalExports(options);
        const updateRenderedDeclaration = (dep, oldExportNames) => {
            if (dep.imports) {
                for (const impt of dep.imports) {
                    impt.imported = this.getVariableExportName(oldExportNames[impt.imported]);
                }
            }
            if (dep.reexports) {
                for (const reexport of dep.reexports) {
                    reexport.imported = this.getVariableExportName(oldExportNames[reexport.imported]);
                }
            }
        };
        const mergeRenderedDeclaration = (into, from) => {
            if (from.imports) {
                if (!into.imports) {
                    into.imports = from.imports;
                }
                else {
                    into.imports = into.imports.concat(from.imports);
                }
            }
            if (from.reexports) {
                if (!into.reexports) {
                    into.reexports = from.reexports;
                }
                else {
                    into.reexports = into.reexports.concat(from.reexports);
                }
            }
            if (!into.exportsNames && from.exportsNames) {
                into.exportsNames = true;
            }
            if (!into.exportsDefault && from.exportsDefault) {
                into.exportsDefault = true;
            }
            into.name = this.variableName;
        };
        // go through the other chunks and update their dependencies
        // also update their import and reexport names in the process
        for (const c of chunkList) {
            let includedDeclaration = undefined;
            for (let i = 0; i < c.dependencies.length; i++) {
                const dep = c.dependencies[i];
                if ((dep === chunk || dep === this) && includedDeclaration) {
                    const duplicateDeclaration = c.renderedDeclarations.dependencies[i];
                    updateRenderedDeclaration(duplicateDeclaration, dep === chunk ? chunk.exportNames : thisOldExportNames);
                    mergeRenderedDeclaration(includedDeclaration, duplicateDeclaration);
                    c.renderedDeclarations.dependencies.splice(i, 1);
                    c.dependencies.splice(i--, 1);
                }
                else if (dep === chunk) {
                    c.dependencies[i] = this;
                    includedDeclaration = c.renderedDeclarations.dependencies[i];
                    updateRenderedDeclaration(includedDeclaration, chunk.exportNames);
                }
                else if (dep === this) {
                    includedDeclaration = c.renderedDeclarations.dependencies[i];
                    updateRenderedDeclaration(includedDeclaration, thisOldExportNames);
                }
            }
        }
        // re-render the merged chunk
        this.preRender(options, inputBase);
    }
    // prerender allows chunk hashes and names to be generated before finalizing
    preRender(options, inputBase) {
        timeStart('render modules', 3);
        const magicString = new Bundle({ separator: options.compact ? '' : '\n\n' });
        this.usedModules = [];
        this.indentString = options.compact ? '' : getIndentString(this.orderedModules, options);
        const n = options.compact ? '' : '\n';
        const _ = options.compact ? '' : ' ';
        const renderOptions = {
            compact: options.compact,
            dynamicImportFunction: options.dynamicImportFunction,
            format: options.format,
            freeze: options.freeze !== false,
            indent: this.indentString,
            namespaceToStringTag: options.namespaceToStringTag === true,
            varOrConst: options.preferConst ? 'const' : 'var'
        };
        // Make sure the direct dependencies of a chunk are present to maintain execution order
        for (const { module } of this.imports) {
            const chunkOrExternal = (module instanceof Module ? module.chunk : module);
            if (this.dependencies.indexOf(chunkOrExternal) === -1) {
                this.dependencies.push(chunkOrExternal);
            }
        }
        // for static and dynamic entry points, inline the execution list to avoid loading latency
        if (!this.graph.preserveModules && this.facadeModule !== null) {
            for (const dep of this.dependencies) {
                if (dep instanceof Chunk$1)
                    this.inlineChunkDependencies(dep, true);
            }
        }
        // prune empty dependency chunks, inlining their side-effect dependencies
        for (let i = 0; i < this.dependencies.length; i++) {
            const dep = this.dependencies[i];
            if (dep instanceof Chunk$1 && dep.isEmpty) {
                this.dependencies.splice(i--, 1);
                this.inlineChunkDependencies(dep, false);
            }
        }
        sortByExecutionOrder(this.dependencies);
        this.setIdentifierRenderResolutions(options);
        this.prepareDynamicImports();
        let hoistedSource = '';
        this.renderedModules = Object.create(null);
        this.renderedModuleSources = [];
        for (let i = 0; i < this.orderedModules.length; i++) {
            const module = this.orderedModules[i];
            const source = module.render(renderOptions);
            source.trim();
            if (options.compact && source.lastLine().indexOf('//') !== -1)
                source.append('\n');
            this.renderedModuleSources.push(source);
            const { renderedExports, removedExports } = module.getRenderedExports();
            this.renderedModules[module.id] = {
                originalLength: module.originalCode.length,
                removedExports,
                renderedExports,
                renderedLength: source.length()
            };
            const namespace = module.getOrCreateNamespace();
            if (namespace.included || !source.isEmpty()) {
                magicString.addSource(source);
                this.usedModules.push(module);
                if (namespace.included && !this.graph.preserveModules) {
                    const rendered = namespace.renderBlock(renderOptions);
                    if (namespace.renderFirst())
                        hoistedSource += n + rendered;
                    else
                        magicString.addSource(new MagicString(rendered));
                }
            }
        }
        if (hoistedSource)
            magicString.prepend(hoistedSource + n + n);
        if (this.needsExportsShim) {
            magicString.prepend(`${n}${renderOptions.varOrConst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
        }
        if (options.compact) {
            this.renderedSource = magicString;
        }
        else {
            this.renderedSource = magicString.trim();
        }
        this.renderedSourceLength = undefined;
        this.renderedHash = undefined;
        if (this.getExportNames().length === 0 && this.getImportIds().length === 0 && this.isEmpty) {
            this.graph.warn({
                code: 'EMPTY_BUNDLE',
                message: 'Generated an empty bundle'
            });
        }
        this.setExternalRenderPaths(options, inputBase);
        this.renderedDeclarations = {
            dependencies: this.getChunkDependencyDeclarations(options),
            exports: this.exportMode === 'none' ? [] : this.getChunkExportDeclarations()
        };
        timeEnd('render modules', 3);
    }
    render(options, addons, outputChunk) {
        timeStart('render format', 3);
        if (!this.renderedSource)
            throw new Error('Internal error: Chunk render called before preRender');
        const finalise = finalisers[options.format];
        if (!finalise) {
            error({
                code: 'INVALID_OPTION',
                message: `Invalid format: ${options.format} - valid options are ${Object.keys(finalisers).join(', ')}.`
            });
        }
        if (options.dynamicImportFunction && options.format !== 'es') {
            this.graph.warn({
                code: 'INVALID_OPTION',
                message: '"output.dynamicImportFunction" is ignored for formats other than "esm".'
            });
        }
        // populate ids in the rendered declarations only here
        // as chunk ids known only after prerender
        for (let i = 0; i < this.dependencies.length; i++) {
            const dep = this.dependencies[i];
            if (dep instanceof ExternalModule && !dep.renormalizeRenderPath)
                continue;
            const renderedDependency = this.renderedDeclarations.dependencies[i];
            const depId = dep instanceof ExternalModule ? renderedDependency.id : dep.id;
            let relPath = this.id ? normalize(relative(dirname(this.id), depId)) : depId;
            if (!relPath.startsWith('../'))
                relPath = './' + relPath;
            if (dep instanceof Chunk$1)
                renderedDependency.namedExportsMode = dep.exportMode !== 'default';
            renderedDependency.id = relPath;
        }
        this.finaliseDynamicImports(options.format);
        const needsAmdModule = this.finaliseImportMetas(options);
        const hasExports = this.renderedDeclarations.exports.length !== 0 ||
            this.renderedDeclarations.dependencies.some(dep => (dep.reexports && dep.reexports.length !== 0));
        const usesTopLevelAwait = this.orderedModules.some(module => module.usesTopLevelAwait);
        if (usesTopLevelAwait && options.format !== 'es' && options.format !== 'system') {
            error({
                code: 'INVALID_TLA_FORMAT',
                message: `Module format ${options.format} does not support top-level await. Use the "es" or "system" output formats rather.`
            });
        }
        const magicString = finalise(this.renderedSource, {
            dependencies: this.renderedDeclarations.dependencies,
            dynamicImport: this.hasDynamicImport,
            exports: this.renderedDeclarations.exports,
            hasExports,
            indentString: this.indentString,
            intro: addons.intro,
            isEntryModuleFacade: this.facadeModule !== null && this.facadeModule.isEntryPoint,
            namedExportsMode: this.exportMode !== 'default',
            needsAmdModule,
            outro: addons.outro,
            usesTopLevelAwait,
            varOrConst: options.preferConst ? 'const' : 'var',
            warn: this.graph.warn.bind(this.graph)
        }, options);
        if (addons.banner)
            magicString.prepend(addons.banner);
        if (addons.footer)
            magicString.append(addons.footer);
        const prevCode = magicString.toString();
        timeEnd('render format', 3);
        let map = null;
        const chunkSourcemapChain = [];
        return renderChunk({
            chunk: this,
            code: prevCode,
            graph: this.graph,
            options,
            renderChunk: outputChunk,
            sourcemapChain: chunkSourcemapChain
        }).then((code) => {
            if (options.sourcemap) {
                timeStart('sourcemap', 3);
                let file;
                if (options.file)
                    file = resolve$1(options.sourcemapFile || options.file);
                else if (options.dir)
                    file = resolve$1(options.dir, this.id);
                else
                    file = resolve$1(this.id);
                if (this.graph.pluginDriver.hasLoadersOrTransforms) {
                    const decodedMap = magicString.generateDecodedMap({});
                    map = collapseSourcemaps(this, file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources);
                }
                else {
                    map = magicString.generateMap({ file, includeContent: !options.sourcemapExcludeSources });
                }
                map.sources = map.sources.map(sourcePath => normalize(options.sourcemapPathTransform ? options.sourcemapPathTransform(sourcePath) : sourcePath));
                timeEnd('sourcemap', 3);
            }
            if (options.compact !== true && code[code.length - 1] !== '\n')
                code += '\n';
            return { code, map };
        });
    }
    turnIntoFacade(facadedModule) {
        this.dependencies = [facadedModule.chunk];
        this.dynamicDependencies = [];
        this.facadeModule = facadedModule;
        facadedModule.facadeChunk = this;
        for (const exportName of facadedModule.getAllExports()) {
            const tracedVariable = facadedModule.getVariableForExportName(exportName);
            this.exports.add(tracedVariable);
            this.exportNames[exportName] = tracedVariable;
        }
    }
    visitDependencies(handleDependency) {
        const toBeVisited = [this];
        const visited = new Set();
        for (const current of toBeVisited) {
            handleDependency(current);
            if (current instanceof ExternalModule)
                continue;
            for (const dependency of current.dependencies.concat(current.dynamicDependencies)) {
                if (!visited.has(dependency)) {
                    visited.add(dependency);
                    toBeVisited.push(dependency);
                }
            }
        }
    }
    visitStaticDependenciesUntilCondition(isConditionSatisfied) {
        const seen = new Set();
        function visitDep(dep) {
            if (seen.has(dep))
                return undefined;
            seen.add(dep);
            if (dep instanceof Chunk$1) {
                for (const subDep of dep.dependencies) {
                    if (visitDep(subDep))
                        return true;
                }
            }
            return isConditionSatisfied(dep) === true;
        }
        return visitDep(this);
    }
    addChunksFromDependencies(moduleDependencies, chunkDependencies) {
        for (const depModule of moduleDependencies) {
            if (depModule.chunk === this) {
                continue;
            }
            let dependency;
            if (depModule instanceof Module) {
                dependency = depModule.chunk;
            }
            else {
                if (!(depModule.used || depModule.moduleSideEffects)) {
                    continue;
                }
                dependency = depModule;
            }
            chunkDependencies.add(dependency);
        }
    }
    computeChunkName() {
        if (this.manualChunkAlias) {
            return sanitizeFileName(this.manualChunkAlias);
        }
        if (this.facadeModule !== null) {
            return sanitizeFileName(this.facadeModule.chunkAlias || getAliasName(this.facadeModule.id));
        }
        for (const module of this.orderedModules) {
            if (module.chunkAlias)
                return sanitizeFileName(module.chunkAlias);
        }
        return 'chunk';
    }
    computeContentHashWithDependencies(addons, options) {
        const hash = _256();
        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));
        hash.update(options.format);
        this.visitDependencies(dep => {
            if (dep instanceof ExternalModule)
                hash.update(':' + dep.renderPath);
            else
                hash.update(dep.getRenderedHash());
        });
        return hash.digest('hex').substr(0, 8);
    }
    finaliseDynamicImports(format) {
        for (let i = 0; i < this.orderedModules.length; i++) {
            const module = this.orderedModules[i];
            const code = this.renderedModuleSources[i];
            for (const { node, resolution } of module.dynamicImports) {
                if (!resolution)
                    continue;
                if (resolution instanceof Module) {
                    if (resolution.chunk !== this && isChunkRendered(resolution.chunk)) {
                        const resolutionChunk = resolution.facadeChunk || resolution.chunk;
                        let relPath = normalize(relative(dirname(this.id), resolutionChunk.id));
                        if (!relPath.startsWith('../'))
                            relPath = './' + relPath;
                        node.renderFinalResolution(code, `'${relPath}'`, format);
                    }
                }
                else if (resolution instanceof ExternalModule) {
                    let resolutionId = resolution.id;
                    if (resolution.renormalizeRenderPath) {
                        resolutionId = normalize(relative(dirname(this.id), resolution.renderPath));
                        if (!resolutionId.startsWith('../'))
                            resolutionId = './' + resolutionId;
                    }
                    node.renderFinalResolution(code, `'${resolutionId}'`, format);
                }
                else {
                    node.renderFinalResolution(code, resolution, format);
                }
            }
        }
    }
    finaliseImportMetas(options) {
        let needsAmdModule = false;
        for (let i = 0; i < this.orderedModules.length; i++) {
            const module = this.orderedModules[i];
            const code = this.renderedModuleSources[i];
            for (const importMeta of module.importMetas) {
                if (importMeta.renderFinalMechanism(code, this.id, options.format, this.graph.pluginDriver)) {
                    needsAmdModule = true;
                }
            }
        }
        return needsAmdModule;
    }
    getChunkDependencyDeclarations(options) {
        const reexportDeclarations = new Map();
        for (let exportName of this.getExportNames()) {
            let exportModule;
            let importName;
            let needsLiveBinding = false;
            if (exportName[0] === '*') {
                exportModule = this.graph.moduleById.get(exportName.substr(1));
                importName = exportName = '*';
            }
            else {
                const variable = this.exportNames[exportName];
                const module = variable.module;
                // skip local exports
                if (!module || module.chunk === this)
                    continue;
                if (module instanceof Module) {
                    exportModule = module.chunk;
                    importName = module.chunk.getVariableExportName(variable);
                    needsLiveBinding = variable.isReassigned;
                }
                else {
                    exportModule = module;
                    importName = variable.name;
                    needsLiveBinding = true;
                }
            }
            let exportDeclaration = reexportDeclarations.get(exportModule);
            if (!exportDeclaration)
                reexportDeclarations.set(exportModule, (exportDeclaration = []));
            exportDeclaration.push({ imported: importName, reexported: exportName, needsLiveBinding });
        }
        const renderedImports = new Set();
        const dependencies = [];
        for (const dep of this.dependencies) {
            const imports = [];
            for (const variable of this.imports) {
                const renderedVariable = variable instanceof ExportDefaultVariable ? variable.getOriginalVariable() : variable;
                if ((variable.module instanceof Module
                    ? variable.module.chunk === dep
                    : variable.module === dep) &&
                    !renderedImports.has(renderedVariable)) {
                    renderedImports.add(renderedVariable);
                    const local = variable.getName();
                    const imported = variable.module instanceof ExternalModule
                        ? variable.name
                        : variable.module.chunk.getVariableExportName(variable);
                    imports.push({ local, imported: imported });
                }
            }
            const reexports = reexportDeclarations.get(dep);
            let exportsNames, exportsDefault;
            let namedExportsMode = true;
            if (dep instanceof ExternalModule) {
                exportsNames = dep.exportsNames || dep.exportsNamespace;
                exportsDefault = 'default' in dep.declarations;
            }
            else {
                exportsNames = true;
                // we don't want any interop patterns to trigger
                exportsDefault = false;
                namedExportsMode = dep.exportMode !== 'default';
            }
            let id = undefined;
            let globalName = undefined;
            if (dep instanceof ExternalModule) {
                id = dep.renderPath;
                if (options.format === 'umd' || options.format === 'iife') {
                    globalName = getGlobalName(dep, options.globals, this.graph, exportsNames || exportsDefault);
                }
            }
            dependencies.push({
                exportsDefault,
                exportsNames,
                globalName,
                id,
                imports: imports.length > 0 ? imports : null,
                isChunk: !dep.isExternal,
                name: dep.variableName,
                namedExportsMode,
                reexports
            });
        }
        return dependencies;
    }
    getChunkExportDeclarations() {
        const exports = [];
        for (const exportName of this.getExportNames()) {
            if (exportName[0] === '*')
                continue;
            const variable = this.exportNames[exportName];
            const module = variable.module;
            if (module && module.chunk !== this)
                continue;
            let hoisted = false;
            let uninitialized = false;
            if (variable instanceof LocalVariable) {
                if (variable.init === UNDEFINED_EXPRESSION) {
                    uninitialized = true;
                }
                for (const declaration of variable.declarations) {
                    if (declaration.parent instanceof FunctionDeclaration ||
                        (declaration instanceof ExportDefaultDeclaration &&
                            declaration.declaration instanceof FunctionDeclaration)) {
                        hoisted = true;
                        break;
                    }
                }
            }
            else if (variable instanceof GlobalVariable) {
                hoisted = true;
            }
            const localName = variable.getName();
            exports.push({
                exported: exportName === '*' ? localName : exportName,
                hoisted,
                local: localName,
                uninitialized
            });
        }
        return exports;
    }
    getVariableExportNamesForModule(module) {
        const exportNamesByVariable = new Map();
        for (const exportName of module.getAllExports()) {
            const tracedVariable = module.getVariableForExportName(exportName);
            if (!tracedVariable || !(tracedVariable.included || tracedVariable.isExternal)) {
                continue;
            }
            const existingExportNames = exportNamesByVariable.get(tracedVariable);
            if (existingExportNames) {
                existingExportNames.push(exportName);
            }
            else {
                exportNamesByVariable.set(tracedVariable, [exportName]);
            }
            const exportingModule = tracedVariable.module;
            if (exportingModule && exportingModule.chunk && exportingModule.chunk !== this) {
                exportingModule.chunk.exports.add(tracedVariable);
            }
        }
        return exportNamesByVariable;
    }
    inlineChunkDependencies(chunk, deep) {
        for (const dep of chunk.dependencies) {
            if (dep instanceof ExternalModule) {
                if (this.dependencies.indexOf(dep) === -1)
                    this.dependencies.push(dep);
            }
            else {
                if (dep === this || this.dependencies.indexOf(dep) !== -1)
                    continue;
                if (!dep.isEmpty)
                    this.dependencies.push(dep);
                if (deep)
                    this.inlineChunkDependencies(dep, true);
            }
        }
    }
    prepareDynamicImports() {
        for (const module of this.orderedModules) {
            for (const { node, resolution } of module.dynamicImports) {
                if (!resolution)
                    continue;
                if (resolution instanceof Module) {
                    if (resolution.chunk === this) {
                        const namespace = resolution.getOrCreateNamespace();
                        node.setResolution(false, namespace.getName());
                    }
                    else {
                        node.setResolution(false);
                    }
                }
                else if (resolution instanceof ExternalModule) {
                    node.setResolution(false);
                }
                else {
                    node.setResolution(false);
                }
            }
        }
    }
    setExternalRenderPaths(options, inputBase) {
        for (const dependency of this.dependencies.concat(this.dynamicDependencies)) {
            if (dependency instanceof ExternalModule) {
                dependency.setRenderPath(options, inputBase);
            }
        }
    }
    setIdentifierRenderResolutions(options) {
        for (const exportName of this.getExportNames()) {
            const exportVariable = this.exportNames[exportName];
            if (exportVariable) {
                if (exportVariable instanceof ExportShimVariable) {
                    this.needsExportsShim = true;
                }
                exportVariable.exportName = exportName;
                if (options.format !== 'es' &&
                    options.format !== 'system' &&
                    exportVariable.isReassigned &&
                    !exportVariable.isId &&
                    !(exportVariable instanceof ExportDefaultVariable && exportVariable.hasId)) {
                    exportVariable.setRenderNames('exports', exportName);
                }
                else {
                    exportVariable.setRenderNames(null, null);
                }
            }
        }
        const usedNames = Object.create(null);
        if (this.needsExportsShim) {
            usedNames[MISSING_EXPORT_SHIM_VARIABLE] = true;
        }
        deconflictChunk(this.orderedModules, this.dependencies, this.imports, usedNames, options.format, options.interop !== false, this.graph.preserveModules);
    }
    setUpModuleImports(module) {
        for (const variable of module.imports) {
            if (variable.module.chunk !== this) {
                this.imports.add(variable);
                if (variable.module instanceof Module) {
                    variable.module.chunk.exports.add(variable);
                }
            }
        }
        if (module.getOrCreateNamespace().included) {
            for (const reexportName of Object.keys(module.reexports)) {
                const reexport = module.reexports[reexportName];
                const variable = reexport.module.getVariableForExportName(reexport.localName);
                if (variable.module.chunk !== this) {
                    this.imports.add(variable);
                    if (variable.module instanceof Module) {
                        variable.module.chunk.exports.add(variable);
                    }
                }
            }
        }
        for (const { node, resolution } of module.dynamicImports) {
            if (node.included) {
                this.hasDynamicImport = true;
                if (resolution instanceof Module && resolution.chunk === this)
                    resolution.getOrCreateNamespace().include();
            }
        }
    }
}

/*
 * Given a chunk list, perform optimizations on that chunk list
 * to reduce the mumber of chunks. Mutates the chunks array.
 *
 * Manual chunks (with chunk.chunkAlias already set) are preserved
 * Entry points are carefully preserved as well
 *
 */
function optimizeChunks(chunks, options, CHUNK_GROUPING_SIZE, inputBase) {
    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
        const mainChunk = chunks[chunkIndex];
        const execGroup = [];
        mainChunk.visitStaticDependenciesUntilCondition(dep => {
            if (dep instanceof Chunk$1) {
                execGroup.push(dep);
            }
        });
        if (execGroup.length < 2) {
            continue;
        }
        let execGroupIndex = 1;
        let seekingFirstMergeCandidate = true;
        let lastChunk = undefined, chunk = execGroup[0], nextChunk = execGroup[1];
        const isMergeCandidate = (chunk) => {
            if (chunk.facadeModule !== null || chunk.manualChunkAlias !== null) {
                return false;
            }
            if (!nextChunk || nextChunk.facadeModule !== null) {
                return false;
            }
            if (chunk.getRenderedSourceLength() > CHUNK_GROUPING_SIZE) {
                return false;
            }
            // if (!chunk.isPure()) continue;
            return true;
        };
        do {
            if (seekingFirstMergeCandidate) {
                if (isMergeCandidate(chunk)) {
                    seekingFirstMergeCandidate = false;
                }
                continue;
            }
            let remainingSize = CHUNK_GROUPING_SIZE - lastChunk.getRenderedSourceLength() - chunk.getRenderedSourceLength();
            if (remainingSize <= 0) {
                if (!isMergeCandidate(chunk)) {
                    seekingFirstMergeCandidate = true;
                }
                continue;
            }
            // if (!chunk.isPure()) continue;
            const chunkDependencies = new Set();
            chunk.visitStaticDependenciesUntilCondition(dep => chunkDependencies.add(dep));
            const ignoreSizeChunks = new Set([chunk, lastChunk]);
            if (lastChunk.visitStaticDependenciesUntilCondition(dep => {
                if (dep === chunk || dep === lastChunk) {
                    return false;
                }
                if (chunkDependencies.has(dep)) {
                    return false;
                }
                if (dep instanceof ExternalModule) {
                    return true;
                }
                remainingSize -= dep.getRenderedSourceLength();
                if (remainingSize <= 0) {
                    return true;
                }
                ignoreSizeChunks.add(dep);
            })) {
                if (!isMergeCandidate(chunk)) {
                    seekingFirstMergeCandidate = true;
                }
                continue;
            }
            if (chunk.visitStaticDependenciesUntilCondition(dep => {
                if (ignoreSizeChunks.has(dep)) {
                    return false;
                }
                if (dep instanceof ExternalModule) {
                    return true;
                }
                remainingSize -= dep.getRenderedSourceLength();
                if (remainingSize <= 0) {
                    return true;
                }
            })) {
                if (!isMergeCandidate(chunk)) {
                    seekingFirstMergeCandidate = true;
                }
                continue;
            }
            // within the size limit -> merge!
            const optimizedChunkIndex = chunks.indexOf(chunk);
            if (optimizedChunkIndex <= chunkIndex)
                chunkIndex--;
            chunks.splice(optimizedChunkIndex, 1);
            lastChunk.merge(chunk, chunks, options, inputBase);
            execGroup.splice(--execGroupIndex, 1);
            chunk = lastChunk;
            // keep going to see if we can merge this with the next again
            if (nextChunk && !isMergeCandidate(nextChunk)) {
                seekingFirstMergeCandidate = true;
            }
        } while (((lastChunk = chunk), (chunk = nextChunk), (nextChunk = execGroup[++execGroupIndex]), chunk));
    }
    return chunks;
}

const tt = acorn__default.tokTypes;
const isIdentifierStart = acorn__default.isIdentifierStart;
var acornBigint = function (Parser) {
    return class extends Parser {
        parseLiteral(value) {
            const node = super.parseLiteral(value);
            if (node.raw.charCodeAt(node.raw.length - 1) == 110)
                node.bigint = this.getNumberInput(node.start, node.end);
            return node;
        }
        readRadixNumber(radix) {
            let start = this.pos;
            this.pos += 2; // 0x
            let val = this.readInt(radix);
            if (val === null)
                this.raise(this.start + 2, `Expected number in radix ${radix}`);
            if (this.input.charCodeAt(this.pos) == 110) {
                let str = this.getNumberInput(start, this.pos);
                val = typeof BigInt !== "undefined" ? BigInt(str) : null;
                ++this.pos;
            }
            else if (isIdentifierStart(this.fullCharCodeAtPos()))
                this.raise(this.pos, "Identifier directly after number");
            return this.finishToken(tt.num, val);
        }
        readNumber(startsWithDot) {
            let start = this.pos;
            // Not an int
            if (startsWithDot)
                return super.readNumber(startsWithDot);
            // Legacy octal
            if (this.input.charCodeAt(start) === 48 && this.input.charCodeAt(start + 1) !== 110) {
                return super.readNumber(startsWithDot);
            }
            if (this.readInt(10) === null)
                this.raise(start, "Invalid number");
            // Not a BigInt, reset and parse again
            if (this.input.charCodeAt(this.pos) != 110) {
                this.pos = start;
                return super.readNumber(startsWithDot);
            }
            let str = this.getNumberInput(start, this.pos);
            let val = typeof BigInt !== "undefined" ? BigInt(str) : null;
            ++this.pos;
            return this.finishToken(tt.num, val);
        }
        // This is basically a hook for acorn-numeric-separator
        getNumberInput(start, end) {
            if (super.getNumberInput)
                return super.getNumberInput(start, end);
            return this.input.slice(start, end);
        }
    };
};

/* eslint-disable no-underscore-dangle */
const DynamicImportKey = 'Import';
// NOTE: This allows `yield import()` to parse correctly.
tokTypes._import.startsExpr = true;
function parseDynamicImport() {
    const node = this.startNode();
    this.next();
    if (this.type !== tokTypes.parenL) {
        this.unexpected();
    }
    return this.finishNode(node, DynamicImportKey);
}
function parenAfter() {
    return /^(\s|\/\/.*|\/\*[^]*?\*\/)*\(/.test(this.input.slice(this.pos));
}
function dynamicImport(Parser) {
    return class extends Parser {
        parseStatement(context, topLevel, exports) {
            if (this.type === tokTypes._import && parenAfter.call(this)) {
                return this.parseExpressionStatement(this.startNode(), this.parseExpression());
            }
            return super.parseStatement(context, topLevel, exports);
        }
        parseExprAtom(refDestructuringErrors) {
            if (this.type === tokTypes._import) {
                return parseDynamicImport.call(this);
            }
            return super.parseExprAtom(refDestructuringErrors);
        }
    };
}

const tt$1 = acorn__default.tokTypes;
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const nextTokenIsDot = parser => {
    skipWhiteSpace.lastIndex = parser.pos;
    let skip = skipWhiteSpace.exec(parser.input);
    let next = parser.pos + skip[0].length;
    return parser.input.slice(next, next + 1) === ".";
};
var acornImportMeta = function (Parser) {
    return class extends Parser {
        parseExprAtom(refDestructuringErrors) {
            if (this.type !== tt$1._import || !nextTokenIsDot(this))
                return super.parseExprAtom(refDestructuringErrors);
            if (!this.options.allowImportExportEverywhere && !this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
            let node = this.startNode();
            node.meta = this.parseIdent(true);
            this.expect(tt$1.dot);
            node.property = this.parseIdent(true);
            if (node.property.name !== "meta") {
                this.raiseRecoverable(node.property.start, "The only valid meta property for import is import.meta");
            }
            if (this.containsEsc) {
                this.raiseRecoverable(node.property.start, "\"meta\" in import.meta must not contain escape sequences");
            }
            return this.finishNode(node, "MetaProperty");
        }
        parseStatement(context, topLevel, exports) {
            if (this.type !== tt$1._import || !nextTokenIsDot(this)) {
                return super.parseStatement(context, topLevel, exports);
            }
            let node = this.startNode();
            let expr = this.parseExpression();
            return this.parseExpressionStatement(node, expr);
        }
    };
};

class UndefinedVariable extends Variable {
    constructor() {
        super('undefined');
    }
    getLiteralValueAtPath() {
        return undefined;
    }
}

class GlobalScope extends Scope {
    constructor() {
        super();
        this.variables.undefined = new UndefinedVariable();
    }
    findVariable(name) {
        if (!this.variables[name])
            return (this.variables[name] = new GlobalVariable(name));
        return this.variables[name];
    }
}

const getNewTrackedPaths = () => ({
    paths: Object.create(null),
    tracked: false,
    unknownPath: null
});
class EntityPathTracker {
    constructor() {
        this.entityPaths = new Map();
    }
    track(entity, path) {
        let trackedPaths = this.entityPaths.get(entity);
        if (!trackedPaths) {
            trackedPaths = getNewTrackedPaths();
            this.entityPaths.set(entity, trackedPaths);
        }
        let pathIndex = 0, trackedSubPaths;
        while (pathIndex < path.length) {
            const key = path[pathIndex];
            if (typeof key === 'string') {
                trackedSubPaths = trackedPaths.paths[key];
                if (!trackedSubPaths) {
                    trackedSubPaths = getNewTrackedPaths();
                    trackedPaths.paths[key] = trackedSubPaths;
                }
            }
            else {
                trackedSubPaths = trackedPaths.unknownPath;
                if (!trackedSubPaths) {
                    trackedSubPaths = getNewTrackedPaths();
                    trackedPaths.unknownPath = trackedSubPaths;
                }
            }
            trackedPaths = trackedSubPaths;
            pathIndex++;
        }
        const found = trackedPaths.tracked;
        trackedPaths.tracked = true;
        return found;
    }
}

function addWithNewReferenceId(item, idMap, hashBase) {
    let referenceId;
    do {
        const hash = _256();
        if (referenceId) {
            hash.update(referenceId);
        }
        else {
            hash.update(hashBase);
        }
        referenceId = hash.digest('hex').substr(0, 8);
    } while (idMap.has(referenceId));
    idMap.set(referenceId, item);
    return referenceId;
}

function getAssetFileName(asset, existingNames, assetFileNames) {
    if (asset.source === undefined)
        error(errNoAssetSourceSet(asset));
    if (asset.fileName)
        return asset.fileName;
    return makeUnique(renderNamePattern(assetFileNames, 'assetFileNames', name => {
        switch (name) {
            case 'hash':
                const hash = _256();
                hash.update(name);
                hash.update(':');
                hash.update(asset.source);
                return hash.digest('hex').substr(0, 8);
            case 'name':
                return asset.name.substr(0, asset.name.length - extname(asset.name).length);
            case 'extname':
                return extname(asset.name);
            case 'ext':
                return extname(asset.name).substr(1);
        }
        return undefined;
    }), existingNames);
}
function createAssetPluginHooks(assetsByReferenceId, outputBundle, assetFileNames) {
    return {
        emitAsset(name, source) {
            if (typeof name !== 'string' || !isPlainName(name))
                error(errInvalidAssetName(name));
            const asset = { name, source: source, fileName: undefined };
            if (outputBundle && source !== undefined)
                finaliseAsset(asset, outputBundle, assetFileNames);
            return addWithNewReferenceId(asset, assetsByReferenceId, name);
        },
        setAssetSource(assetReferenceId, source) {
            const asset = assetsByReferenceId.get(assetReferenceId);
            if (!asset)
                return error(errAssetReferenceIdNotFoundForSetSource(assetReferenceId));
            if (asset.source !== undefined)
                return error(errAssetSourceAlreadySet(asset));
            if (typeof source !== 'string' && !source)
                return error(errAssetSourceMissingForSetSource(asset));
            asset.source = source;
            if (outputBundle)
                finaliseAsset(asset, outputBundle, assetFileNames);
        },
        getAssetFileName(assetReferenceId) {
            const asset = assetsByReferenceId.get(assetReferenceId);
            if (!asset)
                return error(errAssetReferenceIdNotFoundForFilename(assetReferenceId));
            if ((asset).fileName === undefined)
                return error(errAssetNotFinalisedForFileName(asset));
            return (asset).fileName;
        }
    };
}
function finaliseAsset(asset, outputBundle, assetFileNames) {
    const fileName = getAssetFileName(asset, outputBundle, assetFileNames);
    asset.fileName = fileName;
    outputBundle[fileName] = {
        fileName,
        isAsset: true,
        source: asset.source
    };
}
function createTransformEmitAsset(assetsByReferenceId, emitAsset) {
    const assets = [];
    return {
        assets,
        emitAsset: (name, source) => {
            const assetReferenceId = emitAsset(name, source);
            const asset = assetsByReferenceId.get(assetReferenceId);
            assets.push({
                fileName: undefined,
                name: asset.name,
                source: asset.source
            });
            return assetReferenceId;
        }
    };
}

var BuildPhase;
(function (BuildPhase) {
    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
})(BuildPhase || (BuildPhase = {}));

function mkdirpath(path) {
    const dir = dirname(path);
    try {
        readdirSync(dir);
    }
    catch (err) {
        mkdirpath(dir);
        try {
            mkdirSync(dir);
        }
        catch (err2) {
            if (err2.code !== 'EEXIST') {
                throw err2;
            }
        }
    }
}
function writeFile(dest, data) {
    return new Promise((fulfil, reject) => {
        mkdirpath(dest);
        writeFile$1(dest, data, err => {
            if (err) {
                reject(err);
            }
            else {
                fulfil();
            }
        });
    });
}

function getRollupDefaultPlugin(preserveSymlinks) {
    return {
        name: 'Rollup Core',
        resolveId: createResolveId(preserveSymlinks),
        load(id) {
            return readFileSync(id, 'utf-8');
        },
        resolveFileUrl({ relativePath, format }) {
            return relativeUrlMechanisms[format](relativePath);
        },
        resolveImportMeta(prop, { chunkId, format }) {
            const mechanism = importMetaMechanisms[format] && importMetaMechanisms[format](prop, chunkId);
            if (mechanism) {
                return mechanism;
            }
        }
    };
}
function findFile(file, preserveSymlinks) {
    try {
        const stats = lstatSync(file);
        if (!preserveSymlinks && stats.isSymbolicLink())
            return findFile(realpathSync(file), preserveSymlinks);
        if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {
            // check case
            const name = basename(file);
            const files = readdirSync(dirname(file));
            if (files.indexOf(name) !== -1)
                return file;
        }
    }
    catch (err) {
        // suppress
    }
}
function addJsExtensionIfNecessary(file, preserveSymlinks) {
    let found = findFile(file, preserveSymlinks);
    if (found)
        return found;
    found = findFile(file + '.mjs', preserveSymlinks);
    if (found)
        return found;
    found = findFile(file + '.js', preserveSymlinks);
    return found;
}
function createResolveId(preserveSymlinks) {
    return function (source, importer) {
        if (typeof process === 'undefined') {
            error({
                code: 'MISSING_PROCESS',
                message: `It looks like you're using Rollup in a non-Node.js environment. This means you must supply a plugin with custom resolveId and load functions`,
                url: 'https://rollupjs.org/guide/en#a-simple-example'
            });
        }
        // external modules (non-entry modules that start with neither '.' or '/')
        // are skipped at this stage.
        if (importer !== undefined && !isAbsolute(source) && source[0] !== '.')
            return null;
        // `resolve` processes paths from right to left, prepending them until an
        // absolute path is created. Absolute importees therefore shortcircuit the
        // resolve call and require no special handing on our part.
        // See https://nodejs.org/api/path.html#path_path_resolve_paths
        return addJsExtensionIfNecessary(resolve$1(importer ? dirname(importer) : resolve$1(), source), preserveSymlinks);
    };
}
const getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;
const getUrlFromDocument = (chunkId) => `(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
const getGenericImportMetaMechanism = (getUrl) => (prop, chunkId) => {
    const urlMechanism = getUrl(chunkId);
    return prop === null ? `({ url: ${urlMechanism} })` : prop === 'url' ? urlMechanism : 'undefined';
};
const importMetaMechanisms = {
    amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
    iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
    system: prop => (prop === null ? `module.meta` : `module.meta.${prop}`),
    umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`)
};
const getRelativeUrlFromDocument = (relativePath) => getResolveUrl(`(document.currentScript && document.currentScript.src || document.baseURI) + '/../${relativePath}'`);
const relativeUrlMechanisms = {
    amd: relativePath => getResolveUrl(`module.uri + '/../${relativePath}', document.baseURI`),
    cjs: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
    es: relativePath => getResolveUrl(`'${relativePath}', import.meta.url`),
    iife: relativePath => getRelativeUrlFromDocument(relativePath),
    system: relativePath => getResolveUrl(`'${relativePath}', module.meta.url`),
    umd: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`
};

const deprecatedHookNames = {
    ongenerate: 'generateBundle',
    onwrite: 'generateBundle',
    transformBundle: 'renderChunk',
    transformChunk: 'renderChunk'
};
function createPluginDriver(graph, options, pluginCache, watcher) {
    const plugins = [
        ...(options.plugins || []),
        getRollupDefaultPlugin(options.preserveSymlinks)
    ];
    const { emitAsset, getAssetFileName, setAssetSource } = createAssetPluginHooks(graph.assetsById);
    const existingPluginKeys = {};
    let hasLoadersOrTransforms = false;
    const pluginContexts = plugins.map((plugin, pidx) => {
        let cacheable = true;
        if (typeof plugin.cacheKey !== 'string') {
            if (typeof plugin.name !== 'string' || existingPluginKeys[plugin.name]) {
                cacheable = false;
            }
            else {
                existingPluginKeys[plugin.name] = true;
            }
        }
        if (!hasLoadersOrTransforms &&
            (plugin.load || plugin.transform || plugin.transformBundle || plugin.transformChunk))
            hasLoadersOrTransforms = true;
        let cacheInstance;
        if (!pluginCache) {
            cacheInstance = noCache;
        }
        else if (cacheable) {
            const cacheKey = plugin.cacheKey || plugin.name;
            cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(null)));
        }
        else {
            cacheInstance = uncacheablePlugin(plugin.name);
        }
        let watcherDeprecationWarningShown = false;
        function deprecatedWatchListener(event, handler) {
            if (!watcherDeprecationWarningShown) {
                context.warn({
                    code: 'PLUGIN_WATCHER_DEPRECATED',
                    message: `this.watcher usage is deprecated in plugins. Use the watchChange plugin hook and this.addWatchFile() instead.`
                });
                watcherDeprecationWarningShown = true;
            }
            return watcher.on(event, handler);
        }
        const context = {
            addWatchFile(id) {
                if (graph.phase >= BuildPhase.GENERATE)
                    this.error(errInvalidRollupPhaseForAddWatchFile());
                graph.watchFiles[id] = true;
            },
            cache: cacheInstance,
            emitAsset,
            emitChunk(id, options) {
                if (graph.phase > BuildPhase.LOAD_AND_PARSE)
                    this.error(errInvalidRollupPhaseForEmitChunk());
                return graph.moduleLoader.addEntryModuleAndGetReferenceId({
                    alias: (options && options.name) || null,
                    unresolvedId: id
                });
            },
            error(err) {
                if (typeof err === 'string')
                    err = { message: err };
                if (err.code)
                    err.pluginCode = err.code;
                err.code = 'PLUGIN_ERROR';
                err.plugin = plugin.name || `Plugin at position ${pidx + 1}`;
                return error(err);
            },
            isExternal(id, parentId, isResolved = false) {
                return graph.moduleLoader.isExternal(id, parentId, isResolved);
            },
            getAssetFileName: getAssetFileName,
            getChunkFileName(chunkReferenceId) {
                return graph.moduleLoader.getChunkFileName(chunkReferenceId);
            },
            getModuleInfo(moduleId) {
                const foundModule = graph.moduleById.get(moduleId);
                if (foundModule == null) {
                    throw new Error(`Unable to find module ${moduleId}`);
                }
                return {
                    hasModuleSideEffects: foundModule.moduleSideEffects,
                    id: foundModule.id,
                    importedIds: foundModule instanceof ExternalModule
                        ? []
                        : foundModule.sources.map(id => foundModule.resolvedIds[id].id),
                    isEntry: foundModule instanceof Module && foundModule.isEntryPoint,
                    isExternal: foundModule instanceof ExternalModule
                };
            },
            meta: {
                rollupVersion: version
            },
            get moduleIds() {
                return graph.moduleById.keys();
            },
            parse: graph.contextParse,
            resolveId(source, importer) {
                return graph.moduleLoader
                    .resolveId(source, importer)
                    .then(resolveId => resolveId && resolveId.id);
            },
            resolve(source, importer, options) {
                return graph.moduleLoader.resolveId(source, importer, options && options.skipSelf ? pidx : null);
            },
            setAssetSource,
            warn(warning) {
                if (typeof warning === 'string')
                    warning = { message: warning };
                if (warning.code)
                    warning.pluginCode = warning.code;
                warning.code = 'PLUGIN_WARNING';
                warning.plugin = plugin.name || `Plugin at position ${pidx + 1}`;
                graph.warn(warning);
            },
            watcher: watcher
                ? Object.assign({}, watcher, { addListener: deprecatedWatchListener, on: deprecatedWatchListener })
                : undefined
        };
        return context;
    });
    function runHookSync(hookName, args, pluginIndex, permitValues = false, hookContext) {
        const plugin = plugins[pluginIndex];
        let context = pluginContexts[pluginIndex];
        const hook = plugin[hookName];
        if (!hook)
            return undefined;
        const deprecatedHookNewName = deprecatedHookNames[hookName];
        if (deprecatedHookNewName)
            context.warn(hookDeprecationWarning(hookName, deprecatedHookNewName, plugin, pluginIndex));
        if (hookContext) {
            context = hookContext(context, plugin);
            if (!context || context === pluginContexts[pluginIndex])
                throw new Error('Internal Rollup error: hookContext must return a new context object.');
        }
        try {
            // permit values allows values to be returned instead of a functional hook
            if (typeof hook !== 'function') {
                if (permitValues)
                    return hook;
                error({
                    code: 'INVALID_PLUGIN_HOOK',
                    message: `Error running plugin hook ${hookName} for ${plugin.name ||
                        `Plugin at position ${pluginIndex + 1}`}, expected a function hook.`
                });
            }
            return hook.apply(context, args);
        }
        catch (err) {
            if (typeof err === 'string')
                err = { message: err };
            if (err.code !== 'PLUGIN_ERROR') {
                if (err.code)
                    err.pluginCode = err.code;
                err.code = 'PLUGIN_ERROR';
            }
            err.plugin = plugin.name || `Plugin at position ${pluginIndex + 1}`;
            err.hook = hookName;
            error(err);
        }
        return undefined;
    }
    function runHook(hookName, args, pluginIndex, permitValues = false, hookContext) {
        const plugin = plugins[pluginIndex];
        let context = pluginContexts[pluginIndex];
        const hook = plugin[hookName];
        if (!hook)
            return undefined;
        const deprecatedHookNewName = deprecatedHookNames[hookName];
        if (deprecatedHookNewName)
            context.warn(hookDeprecationWarning(hookName, deprecatedHookNewName, plugin, pluginIndex));
        if (hookContext) {
            context = hookContext(context, plugin);
            if (!context || context === pluginContexts[pluginIndex])
                throw new Error('Internal Rollup error: hookContext must return a new context object.');
        }
        return Promise.resolve()
            .then(() => {
            // permit values allows values to be returned instead of a functional hook
            if (typeof hook !== 'function') {
                if (permitValues)
                    return hook;
                error({
                    code: 'INVALID_PLUGIN_HOOK',
                    message: `Error running plugin hook ${hookName} for ${plugin.name ||
                        `Plugin at position ${pluginIndex + 1}`}, expected a function hook.`
                });
            }
            return hook.apply(context, args);
        })
            .catch(err => {
            if (typeof err === 'string')
                err = { message: err };
            if (err.code !== 'PLUGIN_ERROR') {
                if (err.code)
                    err.pluginCode = err.code;
                err.code = 'PLUGIN_ERROR';
            }
            err.plugin = plugin.name || `Plugin at position ${pluginIndex + 1}`;
            err.hook = hookName;
            error(err);
        });
    }
    const pluginDriver = {
        emitAsset,
        getAssetFileName: getAssetFileName,
        hasLoadersOrTransforms,
        // chains, ignores returns
        hookSeq(name, args, hookContext) {
            let promise = Promise.resolve();
            for (let i = 0; i < plugins.length; i++)
                promise = promise.then(() => runHook(name, args, i, false, hookContext));
            return promise;
        },
        // chains, ignores returns
        hookSeqSync(name, args, hookContext) {
            for (let i = 0; i < plugins.length; i++)
                runHookSync(name, args, i, false, hookContext);
        },
        // chains, first non-null result stops and returns
        hookFirst(name, args, hookContext, skip) {
            let promise = Promise.resolve();
            for (let i = 0; i < plugins.length; i++) {
                if (skip === i)
                    continue;
                promise = promise.then((result) => {
                    if (result != null)
                        return result;
                    return runHook(name, args, i, false, hookContext);
                });
            }
            return promise;
        },
        // chains synchronously, first non-null result stops and returns
        hookFirstSync(name, args, hookContext) {
            for (let i = 0; i < plugins.length; i++) {
                const result = runHookSync(name, args, i, false, hookContext);
                if (result != null)
                    return result;
            }
            return null;
        },
        // parallel, ignores returns
        hookParallel(name, args, hookContext) {
            const promises = [];
            for (let i = 0; i < plugins.length; i++) {
                const hookPromise = runHook(name, args, i, false, hookContext);
                if (!hookPromise)
                    continue;
                promises.push(hookPromise);
            }
            return Promise.all(promises).then(() => { });
        },
        // chains, reduces returns of type R, to type T, handling the reduced value as the first hook argument
        hookReduceArg0(name, [arg0, ...args], reduce, hookContext) {
            let promise = Promise.resolve(arg0);
            for (let i = 0; i < plugins.length; i++) {
                promise = promise.then(arg0 => {
                    const hookPromise = runHook(name, [arg0, ...args], i, false, hookContext);
                    if (!hookPromise)
                        return arg0;
                    return hookPromise.then((result) => reduce.call(pluginContexts[i], arg0, result, plugins[i]));
                });
            }
            return promise;
        },
        // chains synchronously, reduces returns of type R, to type T, handling the reduced value as the first hook argument
        hookReduceArg0Sync(name, [arg0, ...args], reduce, hookContext) {
            for (let i = 0; i < plugins.length; i++) {
                const result = runHookSync(name, [arg0, ...args], i, false, hookContext);
                arg0 = reduce.call(pluginContexts[i], arg0, result, plugins[i]);
            }
            return arg0;
        },
        // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.
        hookReduceValue(name, initial, args, reduce, hookContext) {
            let promise = Promise.resolve(initial);
            for (let i = 0; i < plugins.length; i++) {
                promise = promise.then(value => {
                    const hookPromise = runHook(name, args, i, true, hookContext);
                    if (!hookPromise)
                        return value;
                    return hookPromise.then((result) => reduce.call(pluginContexts[i], value, result, plugins[i]));
                });
            }
            return promise;
        }
    };
    return pluginDriver;
}
function createPluginCache(cache) {
    return {
        has(id) {
            const item = cache[id];
            if (!item)
                return false;
            item[0] = 0;
            return true;
        },
        get(id) {
            const item = cache[id];
            if (!item)
                return undefined;
            item[0] = 0;
            return item[1];
        },
        set(id, value) {
            cache[id] = [0, value];
        },
        delete(id) {
            return delete cache[id];
        }
    };
}
function trackPluginCache(pluginCache) {
    const result = { used: false, cache: undefined };
    result.cache = {
        has(id) {
            result.used = true;
            return pluginCache.has(id);
        },
        get(id) {
            result.used = true;
            return pluginCache.get(id);
        },
        set(id, value) {
            result.used = true;
            return pluginCache.set(id, value);
        },
        delete(id) {
            result.used = true;
            return pluginCache.delete(id);
        }
    };
    return result;
}
const noCache = {
    has() {
        return false;
    },
    get() {
        return undefined;
    },
    set() { },
    delete() {
        return false;
    }
};
function uncacheablePluginError(pluginName) {
    if (!pluginName)
        error({
            code: 'ANONYMOUS_PLUGIN_CACHE',
            message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'
        });
    else
        error({
            code: 'DUPLICATE_PLUGIN_NAME',
            message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
        });
}
const uncacheablePlugin = pluginName => ({
    has() {
        uncacheablePluginError(pluginName);
        return false;
    },
    get() {
        uncacheablePluginError(pluginName);
        return undefined;
    },
    set() {
        uncacheablePluginError(pluginName);
    },
    delete() {
        uncacheablePluginError(pluginName);
        return false;
    }
});
function hookDeprecationWarning(name, newName, plugin, pluginIndex) {
    return {
        code: name.toUpperCase() + '_HOOK_DEPRECATED',
        message: `The ${name} hook used by plugin ${plugin.name ||
            `at position ${pluginIndex + 1}`} is deprecated. The ${newName} hook should be used instead.`
    };
}

function transform(graph, source, module) {
    const id = module.id;
    const sourcemapChain = [];
    const originalSourcemap = typeof source.map === 'string' ? JSON.parse(source.map) : source.map;
    if (originalSourcemap && typeof originalSourcemap.mappings === 'string')
        originalSourcemap.mappings = decode(originalSourcemap.mappings);
    const baseEmitAsset = graph.pluginDriver.emitAsset;
    const originalCode = source.code;
    let ast = source.ast;
    let transformDependencies;
    let assets;
    let customTransformCache = false;
    let moduleSideEffects = null;
    let trackedPluginCache;
    let curPlugin;
    const curSource = source.code;
    function transformReducer(code, result, plugin) {
        // track which plugins use the custom this.cache to opt-out of transform caching
        if (!customTransformCache && trackedPluginCache.used)
            customTransformCache = true;
        if (customTransformCache) {
            if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {
                for (const dep of result.dependencies) {
                    const depId = resolve$1(dirname(id), dep);
                    if (!graph.watchFiles[depId])
                        graph.watchFiles[depId] = true;
                }
            }
        }
        else {
            // assets emitted by transform are transformDependencies
            if (assets.length)
                module.transformAssets = assets;
            if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {
                // not great, but a useful way to track this without assuming WeakMap
                if (!curPlugin.warnedTransformDependencies)
                    this.warn({
                        code: 'TRANSFORM_DEPENDENCIES_DEPRECATED',
                        message: `Returning "dependencies" from plugin transform hook is deprecated for using this.addWatchFile() instead.`
                    });
                curPlugin.warnedTransformDependencies = true;
                if (!transformDependencies)
                    transformDependencies = [];
                for (const dep of result.dependencies)
                    transformDependencies.push(resolve$1(dirname(id), dep));
            }
        }
        if (typeof result === 'string') {
            result = {
                ast: undefined,
                code: result,
                map: undefined
            };
        }
        else if (result && typeof result === 'object') {
            if (typeof result.map === 'string') {
                result.map = JSON.parse(result.map);
            }
            if (typeof result.moduleSideEffects === 'boolean') {
                moduleSideEffects = result.moduleSideEffects;
            }
        }
        else {
            return code;
        }
        if (result.map && typeof result.map.mappings === 'string') {
            result.map.mappings = decode(result.map.mappings);
        }
        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
        if (result.map !== null) {
            sourcemapChain.push(result.map || { missing: true, plugin: plugin.name });
        }
        ast = result.ast;
        return result.code;
    }
    let setAssetSourceErr;
    return graph.pluginDriver
        .hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {
        curPlugin = plugin;
        if (curPlugin.cacheKey)
            customTransformCache = true;
        else
            trackedPluginCache = trackPluginCache(pluginContext.cache);
        let emitAsset;
        ({ assets, emitAsset } = createTransformEmitAsset(graph.assetsById, baseEmitAsset));
        return Object.assign({}, pluginContext, { cache: trackedPluginCache ? trackedPluginCache.cache : pluginContext.cache, warn(warning, pos) {
                if (typeof warning === 'string')
                    warning = { message: warning };
                if (pos)
                    augmentCodeLocation(warning, pos, curSource, id);
                warning.id = id;
                warning.hook = 'transform';
                pluginContext.warn(warning);
            },
            error(err, pos) {
                if (typeof err === 'string')
                    err = { message: err };
                if (pos)
                    augmentCodeLocation(err, pos, curSource, id);
                err.id = id;
                err.hook = 'transform';
                return pluginContext.error(err);
            },
            emitAsset,
            addWatchFile(id) {
                if (!transformDependencies)
                    transformDependencies = [];
                transformDependencies.push(id);
                pluginContext.addWatchFile(id);
            },
            setAssetSource(assetReferenceId, source) {
                pluginContext.setAssetSource(assetReferenceId, source);
                if (!customTransformCache && !setAssetSourceErr) {
                    try {
                        this.error({
                            code: 'INVALID_SETASSETSOURCE',
                            message: `setAssetSource cannot be called in transform for caching reasons. Use emitAsset with a source, or call setAssetSource in another hook.`
                        });
                    }
                    catch (err) {
                        setAssetSourceErr = err;
                    }
                }
            } });
    })
        .catch(err => {
        if (typeof err === 'string')
            err = { message: err };
        if (err.code !== 'PLUGIN_ERROR') {
            if (err.code)
                err.pluginCode = err.code;
            err.code = 'PLUGIN_ERROR';
        }
        err.id = id;
        error(err);
    })
        .then(code => {
        if (!customTransformCache && setAssetSourceErr)
            throw setAssetSourceErr;
        return {
            ast: ast,
            code,
            customTransformCache,
            moduleSideEffects,
            originalCode,
            originalSourcemap,
            sourcemapChain,
            transformDependencies
        };
    });
}

function normalizeRelativeExternalId(importer, source) {
    return isRelative(source) ? resolve$1(importer, '..', source) : source;
}
function getIdMatcher(option) {
    if (option === true) {
        return () => true;
    }
    else if (typeof option === 'function') {
        return (id, ...args) => (!id.startsWith('\0') && option(id, ...args)) || false;
    }
    else if (option) {
        const ids = new Set(Array.isArray(option) ? option : option ? [option] : []);
        return id => ids.has(id);
    }
    else {
        return () => false;
    }
}
function getHasModuleSideEffects(moduleSideEffectsOption, pureExternalModules, graph) {
    if (typeof moduleSideEffectsOption === 'boolean') {
        return () => moduleSideEffectsOption;
    }
    if (moduleSideEffectsOption === 'no-external') {
        return (_id, external) => !external;
    }
    if (typeof moduleSideEffectsOption === 'function') {
        return (id, external) => !id.startsWith('\0') ? moduleSideEffectsOption(id, external) !== false : true;
    }
    if (Array.isArray(moduleSideEffectsOption)) {
        const ids = new Set(moduleSideEffectsOption);
        return id => ids.has(id);
    }
    if (moduleSideEffectsOption) {
        graph.warn(errInvalidOption('treeshake.moduleSideEffects', 'please use one of false, "no-external", a function or an array'));
    }
    const isPureExternalModule = getIdMatcher(pureExternalModules);
    return (id, external) => !(external && isPureExternalModule(id));
}
class ModuleLoader {
    constructor(graph, modulesById, pluginDriver, external, getManualChunk, moduleSideEffects, pureExternalModules) {
        this.entriesByReferenceId = new Map();
        this.entryModules = [];
        this.latestLoadModulesPromise = Promise.resolve();
        this.manualChunkModules = {};
        this.loadEntryModule = ({ alias, unresolvedId }, isEntry) => this.pluginDriver
            .hookFirst('resolveId', [unresolvedId, undefined])
            .then((resolveIdResult) => {
            if (resolveIdResult === false ||
                (resolveIdResult && typeof resolveIdResult === 'object' && resolveIdResult.external)) {
                return error(errEntryCannotBeExternal(unresolvedId));
            }
            const id = resolveIdResult && typeof resolveIdResult === 'object'
                ? resolveIdResult.id
                : resolveIdResult;
            if (typeof id === 'string') {
                return this.fetchModule(id, undefined, true, isEntry).then(module => {
                    if (alias !== null) {
                        if (module.chunkAlias !== null && module.chunkAlias !== alias) {
                            return error(errCannotAssignModuleToChunk(module.id, alias, module.chunkAlias));
                        }
                        module.chunkAlias = alias;
                    }
                    return module;
                });
            }
            return error(errUnresolvedEntry(unresolvedId));
        });
        this.graph = graph;
        this.modulesById = modulesById;
        this.pluginDriver = pluginDriver;
        this.isExternal = getIdMatcher(external);
        this.hasModuleSideEffects = getHasModuleSideEffects(moduleSideEffects, pureExternalModules, graph);
        this.getManualChunk =
            typeof getManualChunk === 'function' ? getManualChunk : () => null;
    }
    addEntryModuleAndGetReferenceId(unresolvedEntryModule) {
        const entryRecord = {
            module: null,
            name: unresolvedEntryModule.unresolvedId
        };
        const referenceId = addWithNewReferenceId(entryRecord, this.entriesByReferenceId, unresolvedEntryModule.unresolvedId);
        this.addEntryModules([unresolvedEntryModule], false)
            .then(({ newEntryModules: [module] }) => {
            entryRecord.module = module;
        })
            .catch(() => {
            // Avoid unhandled Promise rejection as the error will be thrown later
            // once module loading has finished
        });
        return referenceId;
    }
    addEntryModules(unresolvedEntryModules, isUserDefined) {
        const loadNewEntryModulesPromise = Promise.all(unresolvedEntryModules.map(unresolvedEntryModule => this.loadEntryModule(unresolvedEntryModule, true))).then(entryModules => {
            for (const entryModule of entryModules) {
                entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;
                const existingEntryModule = this.entryModules.find(module => module.id === entryModule.id);
                if (!existingEntryModule) {
                    this.entryModules.push(entryModule);
                }
            }
            return entryModules;
        });
        return this.awaitLoadModulesPromise(loadNewEntryModulesPromise).then(newEntryModules => ({
            entryModules: this.entryModules,
            manualChunkModulesByAlias: this.manualChunkModules,
            newEntryModules
        }));
    }
    addManualChunks(manualChunks) {
        const unresolvedManualChunks = [];
        for (const alias of Object.keys(manualChunks)) {
            const manualChunkIds = manualChunks[alias];
            for (const unresolvedId of manualChunkIds) {
                unresolvedManualChunks.push({ alias: null, unresolvedId, manualChunkAlias: alias });
            }
        }
        const loadNewManualChunkModulesPromise = Promise.all(unresolvedManualChunks.map(unresolvedManualChunk => this.loadEntryModule(unresolvedManualChunk, false))).then(manualChunkModules => {
            for (let index = 0; index < manualChunkModules.length; index++) {
                this.addToManualChunk(unresolvedManualChunks[index].manualChunkAlias, manualChunkModules[index]);
            }
        });
        return this.awaitLoadModulesPromise(loadNewManualChunkModulesPromise);
    }
    getChunkFileName(referenceId) {
        const entryRecord = this.entriesByReferenceId.get(referenceId);
        if (!entryRecord)
            return error(errChunkReferenceIdNotFoundForFilename(referenceId));
        const fileName = entryRecord.module &&
            (entryRecord.module.facadeChunk
                ? entryRecord.module.facadeChunk.id
                : entryRecord.module.chunk.id);
        if (!fileName)
            return error(errChunkNotGeneratedForFileName(entryRecord));
        return fileName;
    }
    resolveId(source, importer, skip) {
        return Promise.resolve(this.isExternal(source, importer, false)
            ? { id: source, external: true }
            : this.pluginDriver.hookFirst('resolveId', [source, importer], null, skip)).then((result) => this.normalizeResolveIdResult(result, importer, source));
    }
    addToManualChunk(alias, module) {
        if (module.manualChunkAlias !== null && module.manualChunkAlias !== alias) {
            error(errCannotAssignModuleToChunk(module.id, alias, module.manualChunkAlias));
        }
        module.manualChunkAlias = alias;
        if (!this.manualChunkModules[alias]) {
            this.manualChunkModules[alias] = [];
        }
        this.manualChunkModules[alias].push(module);
    }
    awaitLoadModulesPromise(loadNewModulesPromise) {
        this.latestLoadModulesPromise = Promise.all([
            loadNewModulesPromise,
            this.latestLoadModulesPromise
        ]);
        const getCombinedPromise = () => {
            const startingPromise = this.latestLoadModulesPromise;
            return startingPromise.then(() => {
                if (this.latestLoadModulesPromise !== startingPromise) {
                    return getCombinedPromise();
                }
            });
        };
        return getCombinedPromise().then(() => loadNewModulesPromise);
    }
    fetchAllDependencies(module) {
        const fetchDynamicImportsPromise = Promise.all(module.getDynamicImportExpressions().map((specifier, index) => this.resolveDynamicImport(specifier, module.id).then(resolvedId => {
            if (resolvedId === null)
                return;
            const dynamicImport = module.dynamicImports[index];
            if (typeof resolvedId === 'string') {
                dynamicImport.resolution = resolvedId;
                return;
            }
            return this.fetchResolvedDependency(relativeId(resolvedId.id), module.id, resolvedId).then(module => {
                dynamicImport.resolution = module;
            });
        })));
        fetchDynamicImportsPromise.catch(() => { });
        return Promise.all(module.sources.map(source => this.resolveAndFetchDependency(module, source))).then(() => fetchDynamicImportsPromise);
    }
    fetchModule(id, importer, moduleSideEffects, isEntry) {
        const existingModule = this.modulesById.get(id);
        if (existingModule) {
            if (existingModule instanceof ExternalModule)
                throw new Error(`Cannot fetch external module ${id}`);
            existingModule.isEntryPoint = existingModule.isEntryPoint || isEntry;
            return Promise.resolve(existingModule);
        }
        const module = new Module(this.graph, id, moduleSideEffects, isEntry);
        this.modulesById.set(id, module);
        const manualChunkAlias = this.getManualChunk(id);
        if (typeof manualChunkAlias === 'string') {
            this.addToManualChunk(manualChunkAlias, module);
        }
        timeStart('load modules', 3);
        return Promise.resolve(this.pluginDriver.hookFirst('load', [id]))
            .catch((err) => {
            timeEnd('load modules', 3);
            let msg = `Could not load ${id}`;
            if (importer)
                msg += ` (imported by ${importer})`;
            msg += `: ${err.message}`;
            err.message = msg;
            throw err;
        })
            .then(source => {
            timeEnd('load modules', 3);
            if (typeof source === 'string')
                return { code: source };
            if (source && typeof source === 'object' && typeof source.code === 'string')
                return source;
            return error(errBadLoader(id));
        })
            .then(sourceDescription => {
            const cachedModule = this.graph.cachedModules.get(id);
            if (cachedModule &&
                !cachedModule.customTransformCache &&
                cachedModule.originalCode === sourceDescription.code) {
                // re-emit transform assets
                if (cachedModule.transformAssets) {
                    for (const asset of cachedModule.transformAssets)
                        this.pluginDriver.emitAsset(asset.name, asset.source);
                }
                return cachedModule;
            }
            if (typeof sourceDescription.moduleSideEffects === 'boolean') {
                module.moduleSideEffects = sourceDescription.moduleSideEffects;
            }
            return transform(this.graph, sourceDescription, module);
        })
            .then((source) => {
            module.setSource(source);
            this.modulesById.set(id, module);
            return this.fetchAllDependencies(module).then(() => {
                for (const name in module.exports) {
                    if (name !== 'default') {
                        module.exportsAll[name] = module.id;
                    }
                }
                module.exportAllSources.forEach(source => {
                    const id = module.resolvedIds[source].id;
                    const exportAllModule = this.modulesById.get(id);
                    if (exportAllModule instanceof ExternalModule)
                        return;
                    for (const name in exportAllModule.exportsAll) {
                        if (name in module.exportsAll) {
                            this.graph.warn(errNamespaceConflict(name, module, exportAllModule));
                        }
                        else {
                            module.exportsAll[name] = exportAllModule.exportsAll[name];
                        }
                    }
                });
                return module;
            });
        });
    }
    fetchResolvedDependency(source, importer, resolvedId) {
        if (resolvedId.external) {
            if (!this.modulesById.has(resolvedId.id)) {
                this.modulesById.set(resolvedId.id, new ExternalModule(this.graph, resolvedId.id, resolvedId.moduleSideEffects));
            }
            const externalModule = this.modulesById.get(resolvedId.id);
            if (!(externalModule instanceof ExternalModule)) {
                return error(errInternalIdCannotBeExternal(source, importer));
            }
            return Promise.resolve(externalModule);
        }
        else {
            return this.fetchModule(resolvedId.id, importer, resolvedId.moduleSideEffects, false);
        }
    }
    handleMissingImports(resolvedId, source, importer) {
        if (resolvedId === null) {
            if (isRelative(source)) {
                error(errUnresolvedImport(source, importer));
            }
            this.graph.warn(errUnresolvedImportTreatedAsExternal(source, importer));
            return { id: source, external: true, moduleSideEffects: true };
        }
        return resolvedId;
    }
    normalizeResolveIdResult(resolveIdResult, importer, source) {
        let id = '';
        let external = false;
        let moduleSideEffects = null;
        if (resolveIdResult) {
            if (typeof resolveIdResult === 'object') {
                id = resolveIdResult.id;
                if (resolveIdResult.external) {
                    external = true;
                }
                if (typeof resolveIdResult.moduleSideEffects === 'boolean') {
                    moduleSideEffects = resolveIdResult.moduleSideEffects;
                }
            }
            else {
                id = resolveIdResult;
                if (this.isExternal(id, importer, true)) {
                    external = true;
                }
            }
            if (external) {
                id = normalizeRelativeExternalId(importer, id);
            }
        }
        else {
            id = normalizeRelativeExternalId(importer, source);
            if (resolveIdResult !== false && !this.isExternal(id, importer, true)) {
                return null;
            }
            external = true;
        }
        return {
            external,
            id,
            moduleSideEffects: typeof moduleSideEffects === 'boolean'
                ? moduleSideEffects
                : this.hasModuleSideEffects(id, external)
        };
    }
    resolveAndFetchDependency(module, source) {
        return Promise.resolve(module.resolvedIds[source] ||
            this.resolveId(source, module.id).then(resolvedId => this.handleMissingImports(resolvedId, source, module.id))).then(resolvedId => {
            module.resolvedIds[source] = resolvedId;
            return this.fetchResolvedDependency(source, module.id, resolvedId);
        });
    }
    resolveDynamicImport(specifier, importer) {
        // TODO we only should expose the acorn AST here
        return this.pluginDriver
            .hookFirst('resolveDynamicImport', [specifier, importer])
            .then((resolution) => {
            if (typeof specifier !== 'string') {
                if (typeof resolution === 'string') {
                    return resolution;
                }
                if (!resolution) {
                    return null;
                }
                return Object.assign({ external: false, moduleSideEffects: true }, resolution);
            }
            if (resolution == null) {
                return this.resolveId(specifier, importer).then(resolvedId => this.handleMissingImports(resolvedId, specifier, importer));
            }
            return this.handleMissingImports(this.normalizeResolveIdResult(resolution, importer, specifier), specifier, importer);
        });
    }
}

const CHAR_CODE_A = 97;
const CHAR_CODE_0 = 48;
function intToHex(num) {
    if (num < 10)
        return String.fromCharCode(CHAR_CODE_0 + num);
    else
        return String.fromCharCode(CHAR_CODE_A + (num - 10));
}
function Uint8ArrayToHexString(buffer) {
    let str = '';
    // hex conversion - 2 chars per 8 bit component
    for (let i = 0; i < buffer.length; i++) {
        const num = buffer[i];
        // big endian conversion, but whatever
        str += intToHex(num >> 4);
        str += intToHex(num & 0xf);
    }
    return str;
}
function Uint8ArrayXor(to, from) {
    for (let i = 0; i < to.length; i++)
        to[i] = to[i] ^ from[i];
    return to;
}
function randomUint8Array(len) {
    const buffer = new Uint8Array(len);
    for (let i = 0; i < buffer.length; i++)
        buffer[i] = Math.random() * (2 << 8);
    return buffer;
}

function assignChunkColouringHashes(entryModules, manualChunkModules) {
    let currentEntry, currentEntryHash;
    let modulesVisitedForCurrentEntry;
    const handledEntryPoints = new Set();
    const dynamicImports = [];
    const addCurrentEntryColourToModule = (module) => {
        if (currentEntry.manualChunkAlias) {
            module.manualChunkAlias = currentEntry.manualChunkAlias;
            module.entryPointsHash = currentEntryHash;
        }
        else {
            Uint8ArrayXor(module.entryPointsHash, currentEntryHash);
        }
        for (const dependency of module.dependencies) {
            if (dependency instanceof ExternalModule ||
                modulesVisitedForCurrentEntry.has(dependency.id)) {
                continue;
            }
            modulesVisitedForCurrentEntry.add(dependency.id);
            if (!handledEntryPoints.has(dependency.id) && !dependency.manualChunkAlias) {
                addCurrentEntryColourToModule(dependency);
            }
        }
        for (const { resolution } of module.dynamicImports) {
            if (resolution instanceof Module &&
                resolution.dynamicallyImportedBy.length > 0 &&
                !resolution.manualChunkAlias) {
                dynamicImports.push(resolution);
            }
        }
    };
    if (manualChunkModules) {
        for (const chunkName of Object.keys(manualChunkModules)) {
            currentEntryHash = randomUint8Array(10);
            for (currentEntry of manualChunkModules[chunkName]) {
                modulesVisitedForCurrentEntry = new Set(currentEntry.id);
                addCurrentEntryColourToModule(currentEntry);
            }
        }
    }
    for (currentEntry of entryModules) {
        handledEntryPoints.add(currentEntry.id);
        currentEntryHash = randomUint8Array(10);
        modulesVisitedForCurrentEntry = new Set(currentEntry.id);
        if (!currentEntry.manualChunkAlias) {
            addCurrentEntryColourToModule(currentEntry);
        }
    }
    for (currentEntry of dynamicImports) {
        if (handledEntryPoints.has(currentEntry.id)) {
            continue;
        }
        handledEntryPoints.add(currentEntry.id);
        currentEntryHash = randomUint8Array(10);
        modulesVisitedForCurrentEntry = new Set(currentEntry.id);
        addCurrentEntryColourToModule(currentEntry);
    }
}

function makeOnwarn() {
    const warned = Object.create(null);
    return (warning) => {
        const str = warning.toString();
        if (str in warned)
            return;
        console.error(str);
        warned[str] = true;
    };
}
function normalizeEntryModules(entryModules) {
    if (typeof entryModules === 'string') {
        return [{ alias: null, unresolvedId: entryModules }];
    }
    if (Array.isArray(entryModules)) {
        return entryModules.map(unresolvedId => ({ alias: null, unresolvedId }));
    }
    return Object.keys(entryModules).map(alias => ({
        alias,
        unresolvedId: entryModules[alias]
    }));
}
class Graph {
    constructor(options, watcher) {
        this.assetsById = new Map();
        this.curChunkIndex = 0;
        this.moduleById = new Map();
        this.needsTreeshakingPass = false;
        this.phase = BuildPhase.LOAD_AND_PARSE;
        this.watchFiles = Object.create(null);
        this.externalModules = [];
        this.modules = [];
        this.curChunkIndex = 0;
        this.deoptimizationTracker = new EntityPathTracker();
        this.cachedModules = new Map();
        if (options.cache) {
            if (options.cache.modules)
                for (const module of options.cache.modules)
                    this.cachedModules.set(module.id, module);
        }
        if (options.cache !== false) {
            this.pluginCache = (options.cache && options.cache.plugins) || Object.create(null);
            // increment access counter
            for (const name in this.pluginCache) {
                const cache = this.pluginCache[name];
                for (const key of Object.keys(cache))
                    cache[key][0]++;
            }
        }
        this.preserveModules = options.preserveModules;
        this.cacheExpiry = options.experimentalCacheExpiry;
        this.treeshake = options.treeshake !== false;
        if (this.treeshake) {
            this.treeshakingOptions = options.treeshake
                ? {
                    annotations: options.treeshake.annotations !== false,
                    moduleSideEffects: options.treeshake.moduleSideEffects,
                    propertyReadSideEffects: options.treeshake.propertyReadSideEffects !== false,
                    pureExternalModules: options.treeshake.pureExternalModules
                }
                : {
                    annotations: true,
                    moduleSideEffects: true,
                    propertyReadSideEffects: true,
                    pureExternalModules: false
                };
        }
        this.contextParse = (code, options = {}) => this.acornParser.parse(code, Object.assign({}, defaultAcornOptions, options, this.acornOptions));
        this.pluginDriver = createPluginDriver(this, options, this.pluginCache, watcher);
        if (watcher) {
            const handleChange = (id) => this.pluginDriver.hookSeqSync('watchChange', [id]);
            watcher.on('change', handleChange);
            watcher.once('restart', () => {
                watcher.removeListener('change', handleChange);
            });
        }
        this.shimMissingExports = options.shimMissingExports;
        this.scope = new GlobalScope();
        this.context = String(options.context);
        const optionsModuleContext = options.moduleContext;
        if (typeof optionsModuleContext === 'function') {
            this.getModuleContext = id => optionsModuleContext(id) || this.context;
        }
        else if (typeof optionsModuleContext === 'object') {
            const moduleContext = new Map();
            for (const key in optionsModuleContext) {
                moduleContext.set(resolve$1(key), optionsModuleContext[key]);
            }
            this.getModuleContext = id => moduleContext.get(id) || this.context;
        }
        else {
            this.getModuleContext = () => this.context;
        }
        this.onwarn = options.onwarn || makeOnwarn();
        this.acornOptions = options.acorn || {};
        const acornPluginsToInject = [];
        acornPluginsToInject.push(dynamicImport);
        acornPluginsToInject.push(acornImportMeta);
        acornPluginsToInject.push(acornBigint);
        if (options.experimentalTopLevelAwait) {
            this.acornOptions.allowAwaitOutsideFunction = true;
        }
        const acornInjectPlugins = options.acornInjectPlugins;
        acornPluginsToInject.push(...(Array.isArray(acornInjectPlugins)
            ? acornInjectPlugins
            : acornInjectPlugins
                ? [acornInjectPlugins]
                : []));
        this.acornParser = Parser$1.extend(...acornPluginsToInject);
        this.moduleLoader = new ModuleLoader(this, this.moduleById, this.pluginDriver, options.external, (typeof options.manualChunks === 'function' && options.manualChunks), (this.treeshake
            ? this.treeshakingOptions.moduleSideEffects
            : null), (this.treeshake ? this.treeshakingOptions.pureExternalModules : false));
    }
    build(entryModules, manualChunks, inlineDynamicImports) {
        // Phase 1 – discovery. We load the entry module and find which
        // modules it imports, and import those, until we have all
        // of the entry module's dependencies
        timeStart('parse modules', 2);
        return Promise.all([
            this.moduleLoader.addEntryModules(normalizeEntryModules(entryModules), true),
            (manualChunks &&
                typeof manualChunks === 'object' &&
                this.moduleLoader.addManualChunks(manualChunks))
        ]).then(([{ entryModules, manualChunkModulesByAlias }]) => {
            if (entryModules.length === 0) {
                throw new Error('You must supply options.input to rollup');
            }
            for (const module of this.moduleById.values()) {
                if (module instanceof Module) {
                    this.modules.push(module);
                    this.watchFiles[module.id] = true;
                }
                else {
                    this.externalModules.push(module);
                }
            }
            timeEnd('parse modules', 2);
            this.phase = BuildPhase.ANALYSE;
            // Phase 2 - linking. We populate the module dependency links and
            // determine the topological execution order for the bundle
            timeStart('analyse dependency graph', 2);
            this.link(entryModules);
            timeEnd('analyse dependency graph', 2);
            // Phase 3 – marking. We include all statements that should be included
            timeStart('mark included statements', 2);
            if (inlineDynamicImports) {
                if (entryModules.length > 1) {
                    throw new Error('Internal Error: can only inline dynamic imports for single-file builds.');
                }
            }
            for (const module of entryModules) {
                module.includeAllExports();
            }
            this.includeMarked(this.modules);
            // check for unused external imports
            for (const externalModule of this.externalModules)
                externalModule.warnUnusedImports();
            timeEnd('mark included statements', 2);
            // Phase 4 – we construct the chunks, working out the optimal chunking using
            // entry point graph colouring, before generating the import and export facades
            timeStart('generate chunks', 2);
            if (!this.preserveModules && !inlineDynamicImports) {
                assignChunkColouringHashes(entryModules, manualChunkModulesByAlias);
            }
            // TODO: there is one special edge case unhandled here and that is that any module
            //       exposed as an unresolvable export * (to a graph external export *,
            //       either as a namespace import reexported or top-level export *)
            //       should be made to be its own entry point module before chunking
            let chunks = [];
            if (this.preserveModules) {
                for (const module of this.modules) {
                    const chunk = new Chunk$1(this, [module]);
                    if (module.isEntryPoint || !chunk.isEmpty) {
                        chunk.entryModules = [module];
                    }
                    chunks.push(chunk);
                }
            }
            else {
                const chunkModules = {};
                for (const module of this.modules) {
                    const entryPointsHashStr = Uint8ArrayToHexString(module.entryPointsHash);
                    const curChunk = chunkModules[entryPointsHashStr];
                    if (curChunk) {
                        curChunk.push(module);
                    }
                    else {
                        chunkModules[entryPointsHashStr] = [module];
                    }
                }
                for (const entryHashSum in chunkModules) {
                    const chunkModulesOrdered = chunkModules[entryHashSum];
                    sortByExecutionOrder(chunkModulesOrdered);
                    const chunk = new Chunk$1(this, chunkModulesOrdered);
                    chunks.push(chunk);
                }
            }
            // for each chunk module, set up its imports to other
            // chunks, if those variables are included after treeshaking
            for (const chunk of chunks) {
                chunk.link();
            }
            // filter out empty dependencies
            chunks = chunks.filter(isChunkRendered);
            // then go over and ensure all entry chunks export their variables
            for (const chunk of chunks) {
                if (this.preserveModules || chunk.entryModules.length > 0) {
                    chunk.generateEntryExportsOrMarkAsTainted();
                }
            }
            // create entry point facades for entry module chunks that have tainted exports
            const facades = [];
            if (!this.preserveModules) {
                for (const chunk of chunks) {
                    for (const entryModule of chunk.entryModules) {
                        if (chunk.facadeModule !== entryModule) {
                            const entryPointFacade = new Chunk$1(this, []);
                            entryPointFacade.turnIntoFacade(entryModule);
                            facades.push(entryPointFacade);
                        }
                    }
                }
            }
            timeEnd('generate chunks', 2);
            this.phase = BuildPhase.GENERATE;
            return chunks.concat(facades);
        });
    }
    finaliseAssets(assetFileNames) {
        const outputBundle = Object.create(null);
        this.assetsById.forEach(asset => {
            if (asset.source !== undefined)
                finaliseAsset(asset, outputBundle, assetFileNames);
        });
        return outputBundle;
    }
    getCache() {
        // handle plugin cache eviction
        for (const name in this.pluginCache) {
            const cache = this.pluginCache[name];
            let allDeleted = true;
            for (const key of Object.keys(cache)) {
                if (cache[key][0] >= this.cacheExpiry)
                    delete cache[key];
                else
                    allDeleted = false;
            }
            if (allDeleted)
                delete this.pluginCache[name];
        }
        return {
            modules: this.modules.map(module => module.toJSON()),
            plugins: this.pluginCache
        };
    }
    includeMarked(modules) {
        if (this.treeshake) {
            let treeshakingPass = 1;
            do {
                timeStart(`treeshaking pass ${treeshakingPass}`, 3);
                this.needsTreeshakingPass = false;
                for (const module of modules) {
                    if (module.isExecuted)
                        module.include();
                }
                timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);
            } while (this.needsTreeshakingPass);
        }
        else {
            // Necessary to properly replace namespace imports
            for (const module of modules)
                module.includeAllInBundle();
        }
    }
    warn(warning) {
        warning.toString = () => {
            let str = '';
            if (warning.plugin)
                str += `(${warning.plugin} plugin) `;
            if (warning.loc)
                str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
            str += warning.message;
            return str;
        };
        this.onwarn(warning);
    }
    link(entryModules) {
        for (const module of this.modules) {
            module.linkDependencies();
        }
        const { orderedModules, cyclePaths } = analyseModuleExecution(entryModules);
        for (const cyclePath of cyclePaths) {
            this.warn({
                code: 'CIRCULAR_DEPENDENCY',
                importer: cyclePath[0],
                message: `Circular dependency: ${cyclePath.join(' -> ')}`
            });
        }
        this.modules = orderedModules;
        for (const module of this.modules) {
            module.bindReferences();
        }
        this.warnForMissingExports();
    }
    warnForMissingExports() {
        for (const module of this.modules) {
            for (const importName of Object.keys(module.importDescriptions)) {
                const importDescription = module.importDescriptions[importName];
                if (importDescription.name !== '*' &&
                    !importDescription.module.getVariableForExportName(importDescription.name)) {
                    module.warn({
                        code: 'NON_EXISTENT_EXPORT',
                        message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,
                        name: importDescription.name,
                        source: importDescription.module.id
                    }, importDescription.start);
                }
            }
        }
    }
}

function evalIfFn(strOrFn) {
    switch (typeof strOrFn) {
        case 'function':
            return strOrFn();
        case 'string':
            return strOrFn;
        default:
            return '';
    }
}
const concatSep = (out, next) => (next ? `${out}\n${next}` : out);
const concatDblSep = (out, next) => (next ? `${out}\n\n${next}` : out);
function createAddons(graph, options) {
    const pluginDriver = graph.pluginDriver;
    return Promise.all([
        pluginDriver.hookReduceValue('banner', evalIfFn(options.banner), [], concatSep),
        pluginDriver.hookReduceValue('footer', evalIfFn(options.footer), [], concatSep),
        pluginDriver.hookReduceValue('intro', evalIfFn(options.intro), [], concatDblSep),
        pluginDriver.hookReduceValue('outro', evalIfFn(options.outro), [], concatDblSep)
    ])
        .then(([banner, footer, intro, outro]) => {
        if (intro)
            intro += '\n\n';
        if (outro)
            outro = `\n\n${outro}`;
        if (banner.length)
            banner += '\n';
        if (footer.length)
            footer = '\n' + footer;
        return { intro, outro, banner, footer };
    })
        .catch((err) => {
        error({
            code: 'ADDON_ERROR',
            message: `Could not retrieve ${err.hook}. Check configuration of ${err.plugin}.
\tError Message: ${err.message}`
        });
    });
}

function assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons) {
    const usedIds = {};
    const [entryChunks, otherChunks] = chunks.reduce(([entryChunks, otherChunks], chunk) => {
        (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint
            ? entryChunks
            : otherChunks).push(chunk);
        return [entryChunks, otherChunks];
    }, [[], []]);
    // make sure entry chunk names take precedence with regard to deconflicting
    const chunksForNaming = entryChunks.concat(otherChunks);
    for (let i = 0; i < chunksForNaming.length; i++) {
        const chunk = chunksForNaming[i];
        if (outputOptions.file) {
            chunk.id = basename(outputOptions.file);
        }
        else if (inputOptions.preserveModules) {
            chunk.generateIdPreserveModules(inputBase, usedIds);
        }
        else {
            let pattern, patternName;
            if (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint) {
                pattern = outputOptions.entryFileNames || '[name].js';
                patternName = 'output.entryFileNames';
            }
            else {
                pattern = outputOptions.chunkFileNames || '[name]-[hash].js';
                patternName = 'output.chunkFileNames';
            }
            chunk.generateId(pattern, patternName, addons, outputOptions, usedIds);
        }
        usedIds[chunk.id] = true;
    }
}

// ported from https://github.com/substack/node-commondir
function commondir(files) {
    if (files.length === 0)
        return '/';
    if (files.length === 1)
        return dirname(files[0]);
    const commonSegments = files.slice(1).reduce((commonSegments, file) => {
        const pathSegements = file.split(/\/+|\\+/);
        let i;
        for (i = 0; commonSegments[i] === pathSegements[i] &&
            i < Math.min(commonSegments.length, pathSegements.length); i++)
            ;
        return commonSegments.slice(0, i);
    }, files[0].split(/\/+|\\+/));
    // Windows correctly handles paths with forward-slashes
    return commonSegments.length > 1 ? commonSegments.join('/') : '/';
}

function badExports(option, keys) {
    error({
        code: 'INVALID_EXPORT_OPTION',
        message: `'${option}' was specified for output.exports, but entry module has following exports: ${keys.join(', ')}`
    });
}
function getExportMode(chunk, { exports: exportMode, name, format }) {
    const exportKeys = chunk.getExportNames();
    if (exportMode === 'default') {
        if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
            badExports('default', exportKeys);
        }
    }
    else if (exportMode === 'none' && exportKeys.length) {
        badExports('none', exportKeys);
    }
    if (!exportMode || exportMode === 'auto') {
        if (exportKeys.length === 0) {
            exportMode = 'none';
        }
        else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
            exportMode = 'default';
        }
        else {
            if (chunk.facadeModule !== null &&
                chunk.facadeModule.isEntryPoint &&
                format !== 'es' &&
                exportKeys.indexOf('default') !== -1) {
                chunk.graph.warn({
                    code: 'MIXED_EXPORTS',
                    message: `Using named and default exports together. Consumers of your bundle will have to use ${name ||
                        'bundle'}['default'] to access the default export, which may not be what you want. Use \`output.exports: 'named'\` to disable this warning`,
                    url: `https://rollupjs.org/guide/en#output-exports`
                });
            }
            exportMode = 'named';
        }
    }
    if (!/(?:default|named|none)/.test(exportMode)) {
        error({
            code: 'INVALID_EXPORT_OPTION',
            message: `output.exports must be 'default', 'named', 'none', 'auto', or left unspecified (defaults to 'auto')`,
            url: `https://rollupjs.org/guide/en#output-exports`
        });
    }
    return exportMode;
}

const createGetOption = (config, command) => (name, defaultValue) => command[name] !== undefined
    ? command[name]
    : config[name] !== undefined
        ? config[name]
        : defaultValue;
const normalizeObjectOptionValue = (optionValue) => {
    if (!optionValue) {
        return optionValue;
    }
    if (typeof optionValue !== 'object') {
        return {};
    }
    return optionValue;
};
const getObjectOption = (config, command, name) => {
    const commandOption = normalizeObjectOptionValue(command[name]);
    const configOption = normalizeObjectOptionValue(config[name]);
    if (commandOption !== undefined) {
        return commandOption && configOption ? Object.assign({}, configOption, commandOption) : commandOption;
    }
    return configOption;
};
const defaultOnWarn = warning => {
    if (typeof warning === 'string') {
        console.warn(warning);
    }
    else {
        console.warn(warning.message);
    }
};
const getOnWarn = (config, command, defaultOnWarnHandler = defaultOnWarn) => command.silent
    ? () => { }
    : config.onwarn
        ? warning => config.onwarn(warning, defaultOnWarnHandler)
        : defaultOnWarnHandler;
const getExternal = (config, command) => {
    const configExternal = config.external;
    return typeof configExternal === 'function'
        ? (id, ...rest) => configExternal(id, ...rest) || command.external.indexOf(id) !== -1
        : (typeof config.external === 'string'
            ? [configExternal]
            : Array.isArray(configExternal)
                ? configExternal
                : []).concat(command.external);
};
const commandAliases = {
    c: 'config',
    d: 'dir',
    e: 'external',
    f: 'format',
    g: 'globals',
    h: 'help',
    i: 'input',
    m: 'sourcemap',
    n: 'name',
    o: 'file',
    v: 'version',
    w: 'watch'
};
function mergeOptions({ config = {}, command: rawCommandOptions = {}, defaultOnWarnHandler }) {
    const command = getCommandOptions(rawCommandOptions);
    const inputOptions = getInputOptions(config, command, defaultOnWarnHandler);
    if (command.output) {
        Object.assign(command, command.output);
    }
    const output = config.output;
    const normalizedOutputOptions = Array.isArray(output) ? output : output ? [output] : [];
    if (normalizedOutputOptions.length === 0)
        normalizedOutputOptions.push({});
    const outputOptions = normalizedOutputOptions.map(singleOutputOptions => getOutputOptions(singleOutputOptions, command));
    const unknownOptionErrors = [];
    const validInputOptions = Object.keys(inputOptions);
    addUnknownOptionErrors(unknownOptionErrors, Object.keys(config), validInputOptions, 'input option', /^output$/);
    const validOutputOptions = Object.keys(outputOptions[0]);
    addUnknownOptionErrors(unknownOptionErrors, outputOptions.reduce((allKeys, options) => allKeys.concat(Object.keys(options)), []), validOutputOptions, 'output option');
    const validCliOutputOptions = validOutputOptions.filter(option => option !== 'sourcemapPathTransform');
    addUnknownOptionErrors(unknownOptionErrors, Object.keys(command), validInputOptions.concat(validCliOutputOptions, Object.keys(commandAliases), 'config', 'environment', 'silent'), 'CLI flag', /^_|output|(config.*)$/);
    return {
        inputOptions,
        optionError: unknownOptionErrors.length > 0 ? unknownOptionErrors.join('\n') : null,
        outputOptions
    };
}
function addUnknownOptionErrors(errors, options, validOptions, optionType, ignoredKeys = /$./) {
    const unknownOptions = options.filter(key => validOptions.indexOf(key) === -1 && !ignoredKeys.test(key));
    if (unknownOptions.length > 0)
        errors.push(`Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${validOptions.sort().join(', ')}`);
}
function getCommandOptions(rawCommandOptions) {
    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'
        ? rawCommandOptions.external.split(',')
        : [];
    return Object.assign({}, rawCommandOptions, { external, globals: typeof rawCommandOptions.globals === 'string'
            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {
                const [id, variableName] = globalDefinition.split(':');
                globals[id] = variableName;
                if (external.indexOf(id) === -1) {
                    external.push(id);
                }
                return globals;
            }, Object.create(null))
            : undefined });
}
function getInputOptions(config, command = { external: [], globals: undefined }, defaultOnWarnHandler) {
    const getOption = createGetOption(config, command);
    const inputOptions = {
        acorn: config.acorn,
        acornInjectPlugins: config.acornInjectPlugins,
        cache: getOption('cache'),
        chunkGroupingSize: getOption('chunkGroupingSize', 5000),
        context: config.context,
        experimentalCacheExpiry: getOption('experimentalCacheExpiry', 10),
        experimentalOptimizeChunks: getOption('experimentalOptimizeChunks'),
        experimentalTopLevelAwait: getOption('experimentalTopLevelAwait'),
        external: getExternal(config, command),
        inlineDynamicImports: getOption('inlineDynamicImports', false),
        input: getOption('input', []),
        manualChunks: getOption('manualChunks'),
        moduleContext: config.moduleContext,
        onwarn: getOnWarn(config, command, defaultOnWarnHandler),
        perf: getOption('perf', false),
        plugins: config.plugins,
        preserveModules: getOption('preserveModules'),
        preserveSymlinks: getOption('preserveSymlinks'),
        shimMissingExports: getOption('shimMissingExports'),
        treeshake: getObjectOption(config, command, 'treeshake'),
        watch: config.watch
    };
    // support rollup({ cache: prevBuildObject })
    if (inputOptions.cache && inputOptions.cache.cache)
        inputOptions.cache = inputOptions.cache.cache;
    return inputOptions;
}
function getOutputOptions(config, command = {}) {
    const getOption = createGetOption(config, command);
    let format = getOption('format');
    // Handle format aliases
    switch (format) {
        case 'esm':
        case 'module':
            format = 'es';
            break;
        case 'commonjs':
            format = 'cjs';
    }
    return {
        amd: Object.assign({}, config.amd, command.amd),
        assetFileNames: getOption('assetFileNames'),
        banner: getOption('banner'),
        chunkFileNames: getOption('chunkFileNames'),
        compact: getOption('compact', false),
        dir: getOption('dir'),
        dynamicImportFunction: getOption('dynamicImportFunction'),
        entryFileNames: getOption('entryFileNames'),
        esModule: getOption('esModule', true),
        exports: getOption('exports'),
        extend: getOption('extend'),
        file: getOption('file'),
        footer: getOption('footer'),
        format: format === 'esm' ? 'es' : format,
        freeze: getOption('freeze', true),
        globals: getOption('globals'),
        indent: getOption('indent', true),
        interop: getOption('interop', true),
        intro: getOption('intro'),
        name: getOption('name'),
        namespaceToStringTag: getOption('namespaceToStringTag', false),
        noConflict: getOption('noConflict'),
        outro: getOption('outro'),
        paths: getOption('paths'),
        preferConst: getOption('preferConst'),
        sourcemap: getOption('sourcemap'),
        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),
        sourcemapFile: getOption('sourcemapFile'),
        sourcemapPathTransform: getOption('sourcemapPathTransform'),
        strict: getOption('strict', true)
    };
}

function checkOutputOptions(options) {
    if (options.format === 'es6') {
        error({
            message: 'The "es6" output format is deprecated – use "esm" instead',
            url: `https://rollupjs.org/guide/en#output-format`
        });
    }
    if (['amd', 'cjs', 'system', 'es', 'iife', 'umd'].indexOf(options.format) < 0) {
        error({
            message: `You must specify "output.format", which can be one of "amd", "cjs", "system", "esm", "iife" or "umd".`,
            url: `https://rollupjs.org/guide/en#output-format`
        });
    }
}
function getAbsoluteEntryModulePaths(chunks) {
    const absoluteEntryModulePaths = [];
    for (const chunk of chunks) {
        for (const entryModule of chunk.entryModules) {
            if (isAbsolute(entryModule.id)) {
                absoluteEntryModulePaths.push(entryModule.id);
            }
        }
    }
    return absoluteEntryModulePaths;
}
const throwAsyncGenerateError = {
    get() {
        throw new Error(`bundle.generate(...) now returns a Promise instead of a { code, map } object`);
    }
};
function applyOptionHook(inputOptions, plugin) {
    if (plugin.options)
        return plugin.options.call({ meta: { rollupVersion: version } }, inputOptions) || inputOptions;
    return inputOptions;
}
function getInputOptions$1(rawInputOptions) {
    if (!rawInputOptions) {
        throw new Error('You must supply an options object to rollup');
    }
    let { inputOptions, optionError } = mergeOptions({
        config: rawInputOptions
    });
    if (optionError)
        inputOptions.onwarn({ message: optionError, code: 'UNKNOWN_OPTION' });
    const plugins = inputOptions.plugins;
    inputOptions.plugins = Array.isArray(plugins)
        ? plugins.filter(Boolean)
        : plugins
            ? [plugins]
            : [];
    inputOptions = inputOptions.plugins.reduce(applyOptionHook, inputOptions);
    if (inputOptions.inlineDynamicImports) {
        if (inputOptions.preserveModules)
            error({
                code: 'INVALID_OPTION',
                message: `"preserveModules" does not support the "inlineDynamicImports" option.`
            });
        if (inputOptions.manualChunks)
            error({
                code: 'INVALID_OPTION',
                message: '"manualChunks" option is not supported for "inlineDynamicImports".'
            });
        if (inputOptions.experimentalOptimizeChunks)
            error({
                code: 'INVALID_OPTION',
                message: '"experimentalOptimizeChunks" option is not supported for "inlineDynamicImports".'
            });
        if ((inputOptions.input instanceof Array && inputOptions.input.length > 1) ||
            (typeof inputOptions.input === 'object' && Object.keys(inputOptions.input).length > 1))
            error({
                code: 'INVALID_OPTION',
                message: 'Multiple inputs are not supported for "inlineDynamicImports".'
            });
    }
    else if (inputOptions.preserveModules) {
        if (inputOptions.manualChunks)
            error({
                code: 'INVALID_OPTION',
                message: '"preserveModules" does not support the "manualChunks" option.'
            });
        if (inputOptions.experimentalOptimizeChunks)
            error({
                code: 'INVALID_OPTION',
                message: '"preserveModules" does not support the "experimentalOptimizeChunks" option.'
            });
    }
    return inputOptions;
}
let curWatcher;
function setWatcher(watcher) {
    curWatcher = watcher;
}
function rollup(rawInputOptions) {
    try {
        const inputOptions = getInputOptions$1(rawInputOptions);
        initialiseTimers(inputOptions);
        const graph = new Graph(inputOptions, curWatcher);
        curWatcher = undefined;
        // remove the cache option from the memory after graph creation (cache is not used anymore)
        const useCache = rawInputOptions.cache !== false;
        delete inputOptions.cache;
        delete rawInputOptions.cache;
        timeStart('BUILD', 1);
        return graph.pluginDriver
            .hookParallel('buildStart', [inputOptions])
            .then(() => graph.build(inputOptions.input, inputOptions.manualChunks, inputOptions.inlineDynamicImports))
            .then(chunks => graph.pluginDriver.hookParallel('buildEnd', []).then(() => chunks), err => graph.pluginDriver.hookParallel('buildEnd', [err]).then(() => {
            throw err;
        }))
            .then(chunks => {
            timeEnd('BUILD', 1);
            // ensure we only do one optimization pass per build
            let optimized = false;
            function getOutputOptions(rawOutputOptions) {
                return normalizeOutputOptions(inputOptions, rawOutputOptions, chunks.length > 1, graph.pluginDriver);
            }
            function generate(outputOptions, isWrite) {
                timeStart('GENERATE', 1);
                const assetFileNames = outputOptions.assetFileNames || 'assets/[name]-[hash][extname]';
                const outputBundle = graph.finaliseAssets(assetFileNames);
                const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));
                return graph.pluginDriver
                    .hookParallel('renderStart', [])
                    .then(() => createAddons(graph, outputOptions))
                    .then(addons => {
                    // pre-render all chunks
                    for (const chunk of chunks) {
                        if (!inputOptions.preserveModules)
                            chunk.generateInternalExports(outputOptions);
                        if (chunk.facadeModule && chunk.facadeModule.isEntryPoint)
                            chunk.exportMode = getExportMode(chunk, outputOptions);
                    }
                    for (const chunk of chunks) {
                        chunk.preRender(outputOptions, inputBase);
                    }
                    if (!optimized && inputOptions.experimentalOptimizeChunks) {
                        optimizeChunks(chunks, outputOptions, inputOptions.chunkGroupingSize, inputBase);
                        optimized = true;
                    }
                    assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons);
                    // assign to outputBundle
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const facadeModule = chunk.facadeModule;
                        outputBundle[chunk.id] = {
                            code: undefined,
                            dynamicImports: chunk.getDynamicImportIds(),
                            exports: chunk.getExportNames(),
                            facadeModuleId: facadeModule && facadeModule.id,
                            fileName: chunk.id,
                            imports: chunk.getImportIds(),
                            isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,
                            isEntry: facadeModule !== null && facadeModule.isEntryPoint,
                            map: undefined,
                            modules: chunk.renderedModules,
                            get name() {
                                return chunk.getChunkName();
                            }
                        };
                    }
                    return Promise.all(chunks.map(chunk => {
                        const outputChunk = outputBundle[chunk.id];
                        return chunk.render(outputOptions, addons, outputChunk).then(rendered => {
                            outputChunk.code = rendered.code;
                            outputChunk.map = rendered.map;
                            return graph.pluginDriver.hookParallel('ongenerate', [
                                Object.assign({ bundle: outputChunk }, outputOptions),
                                outputChunk
                            ]);
                        });
                    })).then(() => { });
                })
                    .catch(error => graph.pluginDriver.hookParallel('renderError', [error]).then(() => {
                    throw error;
                }))
                    .then(() => {
                    // run generateBundle hook
                    // assets emitted during generateBundle are unique to that specific generate call
                    const assets = new Map(graph.assetsById);
                    const generateAssetPluginHooks = createAssetPluginHooks(assets, outputBundle, assetFileNames);
                    return graph.pluginDriver
                        .hookSeq('generateBundle', [outputOptions, outputBundle, isWrite], context => (Object.assign({}, context, generateAssetPluginHooks)))
                        .then(() => {
                        // throw errors for assets not finalised with a source
                        assets.forEach(asset => {
                            if (asset.fileName === undefined)
                                finaliseAsset(asset, outputBundle, assetFileNames);
                        });
                    });
                })
                    .then(() => {
                    timeEnd('GENERATE', 1);
                    return outputBundle;
                });
            }
            const cache = useCache ? graph.getCache() : undefined;
            const result = {
                cache: cache,
                generate: ((rawOutputOptions) => {
                    const promise = generate(getOutputOptions(rawOutputOptions), false).then(result => createOutput(result));
                    Object.defineProperty(promise, 'code', throwAsyncGenerateError);
                    Object.defineProperty(promise, 'map', throwAsyncGenerateError);
                    return promise;
                }),
                watchFiles: Object.keys(graph.watchFiles),
                write: ((rawOutputOptions) => {
                    const outputOptions = getOutputOptions(rawOutputOptions);
                    if (!outputOptions.dir && !outputOptions.file) {
                        error({
                            code: 'MISSING_OPTION',
                            message: 'You must specify "output.file" or "output.dir" for the build.'
                        });
                    }
                    return generate(outputOptions, true).then(bundle => {
                        let chunkCnt = 0;
                        for (const fileName of Object.keys(bundle)) {
                            const file = bundle[fileName];
                            if (file.isAsset)
                                continue;
                            chunkCnt++;
                            if (chunkCnt > 1)
                                break;
                        }
                        if (chunkCnt > 1) {
                            if (outputOptions.sourcemapFile)
                                error({
                                    code: 'INVALID_OPTION',
                                    message: '"output.sourcemapFile" is only supported for single-file builds.'
                                });
                            if (typeof outputOptions.file === 'string')
                                error({
                                    code: 'INVALID_OPTION',
                                    message: 'When building multiple chunks, the "output.dir" option must be used, not "output.file".' +
                                        (typeof inputOptions.input !== 'string' ||
                                            inputOptions.inlineDynamicImports === true
                                            ? ''
                                            : ' To inline dynamic imports, set the "inlineDynamicImports" option.')
                                });
                        }
                        return Promise.all(Object.keys(bundle).map(chunkId => writeOutputFile(graph, result, bundle[chunkId], outputOptions)))
                            .then(() => graph.pluginDriver.hookParallel('writeBundle', [bundle]))
                            .then(() => createOutput(bundle));
                    });
                })
            };
            if (inputOptions.perf === true)
                result.getTimings = getTimings;
            return result;
        });
    }
    catch (err) {
        return Promise.reject(err);
    }
}
var SortingFileType;
(function (SortingFileType) {
    SortingFileType[SortingFileType["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
    SortingFileType[SortingFileType["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
    SortingFileType[SortingFileType["ASSET"] = 2] = "ASSET";
})(SortingFileType || (SortingFileType = {}));
function getSortingFileType(file) {
    if (file.isAsset) {
        return SortingFileType.ASSET;
    }
    if (file.isEntry) {
        return SortingFileType.ENTRY_CHUNK;
    }
    return SortingFileType.SECONDARY_CHUNK;
}
function createOutput(outputBundle) {
    return {
        output: Object.keys(outputBundle)
            .map(fileName => outputBundle[fileName])
            .sort((outputFileA, outputFileB) => {
            const fileTypeA = getSortingFileType(outputFileA);
            const fileTypeB = getSortingFileType(outputFileB);
            if (fileTypeA === fileTypeB)
                return 0;
            return fileTypeA < fileTypeB ? -1 : 1;
        })
    };
}
function isOutputAsset(file) {
    return file.isAsset === true;
}
function writeOutputFile(graph, build, outputFile, outputOptions) {
    const fileName = resolve$1(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);
    let writeSourceMapPromise;
    let source;
    if (isOutputAsset(outputFile)) {
        source = outputFile.source;
    }
    else {
        source = outputFile.code;
        if (outputOptions.sourcemap && outputFile.map) {
            let url;
            if (outputOptions.sourcemap === 'inline') {
                url = outputFile.map.toUrl();
            }
            else {
                url = `${basename(outputFile.fileName)}.map`;
                writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());
            }
            source += `//# ${SOURCEMAPPING_URL}=${url}\n`;
        }
    }
    return writeFile(fileName, source)
        .then(() => writeSourceMapPromise)
        .then(() => !isOutputAsset(outputFile) &&
        graph.pluginDriver.hookSeq('onwrite', [
            Object.assign({ bundle: build }, outputOptions),
            outputFile
        ]))
        .then(() => { });
}
function normalizeOutputOptions(inputOptions, rawOutputOptions, hasMultipleChunks, pluginDriver) {
    if (!rawOutputOptions) {
        throw new Error('You must supply an options object');
    }
    const mergedOptions = mergeOptions({
        config: {
            output: Object.assign({}, rawOutputOptions, rawOutputOptions.output, inputOptions.output)
        }
    });
    if (mergedOptions.optionError)
        throw new Error(mergedOptions.optionError);
    // now outputOptions is an array, but rollup.rollup API doesn't support arrays
    const mergedOutputOptions = mergedOptions.outputOptions[0];
    const outputOptionsReducer = (outputOptions, result) => result || outputOptions;
    const outputOptions = pluginDriver.hookReduceArg0Sync('outputOptions', [mergedOutputOptions], outputOptionsReducer);
    checkOutputOptions(outputOptions);
    if (typeof outputOptions.file === 'string') {
        if (typeof outputOptions.dir === 'string')
            error({
                code: 'INVALID_OPTION',
                message: 'You must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks.'
            });
        if (inputOptions.preserveModules) {
            error({
                code: 'INVALID_OPTION',
                message: 'You must set "output.dir" instead of "output.file" when using the "preserveModules" option.'
            });
        }
        if (typeof inputOptions.input === 'object' && !Array.isArray(inputOptions.input))
            error({
                code: 'INVALID_OPTION',
                message: 'You must set "output.dir" instead of "output.file" when providing named inputs.'
            });
    }
    if (hasMultipleChunks) {
        if (outputOptions.format === 'umd' || outputOptions.format === 'iife')
            error({
                code: 'INVALID_OPTION',
                message: 'UMD and IIFE output formats are not supported for code-splitting builds.'
            });
        if (typeof outputOptions.file === 'string')
            error({
                code: 'INVALID_OPTION',
                message: 'You must set "output.dir" instead of "output.file" when generating multiple chunks.'
            });
    }
    return outputOptions;
}

var types = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    RANGE: 4,
    REPETITION: 5,
    REFERENCE: 6,
    CHAR: 7,
};

var INTS = function () {
    return [{ type: types.RANGE, from: 48, to: 57 }];
};
var WORDS = function () {
    return [
        { type: types.CHAR, value: 95 },
        { type: types.RANGE, from: 97, to: 122 },
        { type: types.RANGE, from: 65, to: 90 }
    ].concat(INTS());
};
var WHITESPACE$1 = function () {
    return [
        { type: types.CHAR, value: 9 },
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 11 },
        { type: types.CHAR, value: 12 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 32 },
        { type: types.CHAR, value: 160 },
        { type: types.CHAR, value: 5760 },
        { type: types.CHAR, value: 6158 },
        { type: types.CHAR, value: 8192 },
        { type: types.CHAR, value: 8193 },
        { type: types.CHAR, value: 8194 },
        { type: types.CHAR, value: 8195 },
        { type: types.CHAR, value: 8196 },
        { type: types.CHAR, value: 8197 },
        { type: types.CHAR, value: 8198 },
        { type: types.CHAR, value: 8199 },
        { type: types.CHAR, value: 8200 },
        { type: types.CHAR, value: 8201 },
        { type: types.CHAR, value: 8202 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 },
        { type: types.CHAR, value: 8239 },
        { type: types.CHAR, value: 8287 },
        { type: types.CHAR, value: 12288 },
        { type: types.CHAR, value: 65279 }
    ];
};
var NOTANYCHAR = function () {
    return [
        { type: types.CHAR, value: 10 },
        { type: types.CHAR, value: 13 },
        { type: types.CHAR, value: 8232 },
        { type: types.CHAR, value: 8233 },
    ];
};
// Predefined class objects.
var words = function () {
    return { type: types.SET, set: WORDS(), not: false };
};
var notWords = function () {
    return { type: types.SET, set: WORDS(), not: true };
};
var ints = function () {
    return { type: types.SET, set: INTS(), not: false };
};
var notInts = function () {
    return { type: types.SET, set: INTS(), not: true };
};
var whitespace = function () {
    return { type: types.SET, set: WHITESPACE$1(), not: false };
};
var notWhitespace = function () {
    return { type: types.SET, set: WHITESPACE$1(), not: true };
};
var anyChar = function () {
    return { type: types.SET, set: NOTANYCHAR(), not: true };
};
var sets = {
    words: words,
    notWords: notWords,
    ints: ints,
    notInts: notInts,
    whitespace: whitespace,
    notWhitespace: notWhitespace,
    anyChar: anyChar
};

var util = createCommonjsModule(function (module, exports) {
    // All of these are private and only used by randexp.
    // It's assumed that they will always be called with the correct input.
    var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
    var SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };
    /**
     * Finds character representations in str and convert all to
     * their respective characters
     *
     * @param {String} str
     * @return {String}
     */
    exports.strToChars = function (str) {
        /* jshint maxlen: false */
        var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
        str = str.replace(chars_regex, function (s, b, lbs, a16, b16, c8, dctrl, eslsh) {
            if (lbs) {
                return s;
            }
            var code = b ? 8 :
                a16 ? parseInt(a16, 16) :
                    b16 ? parseInt(b16, 16) :
                        c8 ? parseInt(c8, 8) :
                            dctrl ? CTRL.indexOf(dctrl) :
                                SLSH[eslsh];
            var c = String.fromCharCode(code);
            // Escape special regex characters.
            if (/[\[\]{}\^$.|?*+()]/.test(c)) {
                c = '\\' + c;
            }
            return c;
        });
        return str;
    };
    /**
     * turns class into tokens
     * reads str until it encounters a ] not preceeded by a \
     *
     * @param {String} str
     * @param {String} regexpStr
     * @return {Array.<Array.<Object>, Number>}
     */
    exports.tokenizeClass = function (str, regexpStr) {
        /* jshint maxlen: false */
        var tokens = [];
        var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
        var rs, c;
        while ((rs = regexp.exec(str)) != null) {
            if (rs[1]) {
                tokens.push(sets.words());
            }
            else if (rs[2]) {
                tokens.push(sets.ints());
            }
            else if (rs[3]) {
                tokens.push(sets.whitespace());
            }
            else if (rs[4]) {
                tokens.push(sets.notWords());
            }
            else if (rs[5]) {
                tokens.push(sets.notInts());
            }
            else if (rs[6]) {
                tokens.push(sets.notWhitespace());
            }
            else if (rs[7]) {
                tokens.push({
                    type: types.RANGE,
                    from: (rs[8] || rs[9]).charCodeAt(0),
                    to: rs[10].charCodeAt(0),
                });
            }
            else if (c = rs[12]) {
                tokens.push({
                    type: types.CHAR,
                    value: c.charCodeAt(0),
                });
            }
            else {
                return [tokens, regexp.lastIndex];
            }
        }
        exports.error(regexpStr, 'Unterminated character class');
    };
    /**
     * Shortcut to throw errors.
     *
     * @param {String} regexp
     * @param {String} msg
     */
    exports.error = function (regexp, msg) {
        throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
    };
});

var wordBoundary = function () {
    return { type: types.POSITION, value: 'b' };
};
var nonWordBoundary = function () {
    return { type: types.POSITION, value: 'B' };
};
var begin = function () {
    return { type: types.POSITION, value: '^' };
};
var end = function () {
    return { type: types.POSITION, value: '$' };
};
var positions = {
    wordBoundary: wordBoundary,
    nonWordBoundary: nonWordBoundary,
    begin: begin,
    end: end
};

var lib = function (regexpStr) {
    var i = 0, l, c, start = { type: types.ROOT, stack: [] }, 
    // Keep track of last clause/group and stack.
    lastGroup = start, last = start.stack, groupStack = [];
    var repeatErr = function (i) {
        util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));
    };
    // Decode a few escaped characters.
    var str = util.strToChars(regexpStr);
    l = str.length;
    // Iterate through each character in string.
    while (i < l) {
        c = str[i++];
        switch (c) {
            // Handle escaped characters, inclues a few sets.
            case '\\':
                c = str[i++];
                switch (c) {
                    case 'b':
                        last.push(positions.wordBoundary());
                        break;
                    case 'B':
                        last.push(positions.nonWordBoundary());
                        break;
                    case 'w':
                        last.push(sets.words());
                        break;
                    case 'W':
                        last.push(sets.notWords());
                        break;
                    case 'd':
                        last.push(sets.ints());
                        break;
                    case 'D':
                        last.push(sets.notInts());
                        break;
                    case 's':
                        last.push(sets.whitespace());
                        break;
                    case 'S':
                        last.push(sets.notWhitespace());
                        break;
                    default:
                        // Check if c is integer.
                        // In which case it's a reference.
                        if (/\d/.test(c)) {
                            last.push({ type: types.REFERENCE, value: parseInt(c, 10) });
                            // Escaped character.
                        }
                        else {
                            last.push({ type: types.CHAR, value: c.charCodeAt(0) });
                        }
                }
                break;
            // Positionals.
            case '^':
                last.push(positions.begin());
                break;
            case '$':
                last.push(positions.end());
                break;
            // Handle custom sets.
            case '[':
                // Check if this class is 'anti' i.e. [^abc].
                var not;
                if (str[i] === '^') {
                    not = true;
                    i++;
                }
                else {
                    not = false;
                }
                // Get all the characters in class.
                var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
                // Increase index by length of class.
                i += classTokens[1];
                last.push({
                    type: types.SET,
                    set: classTokens[0],
                    not: not,
                });
                break;
            // Class of any character except \n.
            case '.':
                last.push(sets.anyChar());
                break;
            // Push group onto stack.
            case '(':
                // Create group.
                var group = {
                    type: types.GROUP,
                    stack: [],
                    remember: true,
                };
                c = str[i];
                // If if this is a special kind of group.
                if (c === '?') {
                    c = str[i + 1];
                    i += 2;
                    // Match if followed by.
                    if (c === '=') {
                        group.followedBy = true;
                        // Match if not followed by.
                    }
                    else if (c === '!') {
                        group.notFollowedBy = true;
                    }
                    else if (c !== ':') {
                        util.error(regexpStr, 'Invalid group, character \'' + c +
                            '\' after \'?\' at column ' + (i - 1));
                    }
                    group.remember = false;
                }
                // Insert subgroup into current group stack.
                last.push(group);
                // Remember the current group for when the group closes.
                groupStack.push(lastGroup);
                // Make this new group the current group.
                lastGroup = group;
                last = group.stack;
                break;
            // Pop group out of stack.
            case ')':
                if (groupStack.length === 0) {
                    util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));
                }
                lastGroup = groupStack.pop();
                // Check if this group has a PIPE.
                // To get back the correct last stack.
                last = lastGroup.options ?
                    lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
                break;
            // Use pipe character to give more choices.
            case '|':
                // Create array where options are if this is the first PIPE
                // in this clause.
                if (!lastGroup.options) {
                    lastGroup.options = [lastGroup.stack];
                    delete lastGroup.stack;
                }
                // Create a new stack and add to options for rest of clause.
                var stack = [];
                lastGroup.options.push(stack);
                last = stack;
                break;
            // Repetition.
            // For every repetition, remove last element from last stack
            // then insert back a RANGE object.
            // This design is chosen because there could be more than
            // one repetition symbols in a regex i.e. `a?+{2,3}`.
            case '{':
                var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
                if (rs !== null) {
                    if (last.length === 0) {
                        repeatErr(i);
                    }
                    min = parseInt(rs[1], 10);
                    max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
                    i += rs[0].length;
                    last.push({
                        type: types.REPETITION,
                        min: min,
                        max: max,
                        value: last.pop(),
                    });
                }
                else {
                    last.push({
                        type: types.CHAR,
                        value: 123,
                    });
                }
                break;
            case '?':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 0,
                    max: 1,
                    value: last.pop(),
                });
                break;
            case '+':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 1,
                    max: Infinity,
                    value: last.pop(),
                });
                break;
            case '*':
                if (last.length === 0) {
                    repeatErr(i);
                }
                last.push({
                    type: types.REPETITION,
                    min: 0,
                    max: Infinity,
                    value: last.pop(),
                });
                break;
            // Default is a character that is not `\[](){}?+*^$`.
            default:
                last.push({
                    type: types.CHAR,
                    value: c.charCodeAt(0),
                });
        }
    }
    // Check if any groups have not been closed.
    if (groupStack.length !== 0) {
        util.error(regexpStr, 'Unterminated group');
    }
    return start;
};
var types_1 = types;
lib.types = types_1;

var types$1 = lib.types;
var safeRegex = function (re, opts) {
    if (!opts)
        opts = {};
    var replimit = opts.limit === undefined ? 25 : opts.limit;
    if (isRegExp(re))
        re = re.source;
    else if (typeof re !== 'string')
        re = String(re);
    try {
        re = lib(re);
    }
    catch (err) {
        return false;
    }
    var reps = 0;
    return (function walk(node, starHeight) {
        if (node.type === types$1.REPETITION) {
            starHeight++;
            reps++;
            if (starHeight > 1)
                return false;
            if (reps > replimit)
                return false;
        }
        if (node.options) {
            for (var i = 0, len = node.options.length; i < len; i++) {
                var ok = walk({ stack: node.options[i] }, starHeight);
                if (!ok)
                    return false;
            }
        }
        var stack = node.stack || (node.value && node.value.stack);
        if (!stack)
            return true;
        for (var i = 0; i < stack.length; i++) {
            var ok = walk(stack[i], starHeight);
            if (!ok)
                return false;
        }
        return true;
    })(re, 0);
};
function isRegExp(x) {
    return {}.toString.call(x) === '[object RegExp]';
}

/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = function isObject(val) {
    return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

var toString$1 = Object.prototype.toString;
var kindOf = function kindOf(val) {
    if (val === void 0)
        return 'undefined';
    if (val === null)
        return 'null';
    var type = typeof val;
    if (type === 'boolean')
        return 'boolean';
    if (type === 'string')
        return 'string';
    if (type === 'number')
        return 'number';
    if (type === 'symbol')
        return 'symbol';
    if (type === 'function') {
        return isGeneratorFn(val) ? 'generatorfunction' : 'function';
    }
    if (isArray(val))
        return 'array';
    if (isBuffer(val))
        return 'buffer';
    if (isArguments(val))
        return 'arguments';
    if (isDate(val))
        return 'date';
    if (isError(val))
        return 'error';
    if (isRegexp(val))
        return 'regexp';
    switch (ctorName(val)) {
        case 'Symbol': return 'symbol';
        case 'Promise': return 'promise';
        // Set, Map, WeakSet, WeakMap
        case 'WeakMap': return 'weakmap';
        case 'WeakSet': return 'weakset';
        case 'Map': return 'map';
        case 'Set': return 'set';
        // 8-bit typed arrays
        case 'Int8Array': return 'int8array';
        case 'Uint8Array': return 'uint8array';
        case 'Uint8ClampedArray': return 'uint8clampedarray';
        // 16-bit typed arrays
        case 'Int16Array': return 'int16array';
        case 'Uint16Array': return 'uint16array';
        // 32-bit typed arrays
        case 'Int32Array': return 'int32array';
        case 'Uint32Array': return 'uint32array';
        case 'Float32Array': return 'float32array';
        case 'Float64Array': return 'float64array';
    }
    if (isGeneratorObj(val)) {
        return 'generator';
    }
    // Non-plain objects
    type = toString$1.call(val);
    switch (type) {
        case '[object Object]': return 'object';
        // iterators
        case '[object Map Iterator]': return 'mapiterator';
        case '[object Set Iterator]': return 'setiterator';
        case '[object String Iterator]': return 'stringiterator';
        case '[object Array Iterator]': return 'arrayiterator';
    }
    // other
    return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};
function ctorName(val) {
    return val.constructor ? val.constructor.name : null;
}
function isArray(val) {
    if (Array.isArray)
        return Array.isArray(val);
    return val instanceof Array;
}
function isError(val) {
    return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}
function isDate(val) {
    if (val instanceof Date)
        return true;
    return typeof val.toDateString === 'function'
        && typeof val.getDate === 'function'
        && typeof val.setDate === 'function';
}
function isRegexp(val) {
    if (val instanceof RegExp)
        return true;
    return typeof val.flags === 'string'
        && typeof val.ignoreCase === 'boolean'
        && typeof val.multiline === 'boolean'
        && typeof val.global === 'boolean';
}
function isGeneratorFn(name, val) {
    return ctorName(name) === 'GeneratorFunction';
}
function isGeneratorObj(val) {
    return typeof val.throw === 'function'
        && typeof val.return === 'function'
        && typeof val.next === 'function';
}
function isArguments(val) {
    try {
        if (typeof val.length === 'number' && typeof val.callee === 'function') {
            return true;
        }
    }
    catch (err) {
        if (err.message.indexOf('callee') !== -1) {
            return true;
        }
    }
    return false;
}
/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */
function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === 'function') {
        return val.constructor.isBuffer(val);
    }
    return false;
}

// accessor descriptor properties
var accessor = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
};
function isAccessorDescriptor(obj, prop) {
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (has$1(obj, 'value') || has$1(obj, 'writable')) {
        return false;
    }
    if (!has$1(obj, 'get') || typeof obj.get !== 'function') {
        return false;
    }
    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has$1(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
        return false;
    }
    for (var key in obj) {
        if (!accessor.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === accessor[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
function has$1(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
/**
 * Expose `isAccessorDescriptor`
 */
var isAccessorDescriptor_1 = isAccessorDescriptor;

var isDataDescriptor = function isDataDescriptor(obj, prop) {
    // data descriptor properties
    var data = {
        configurable: 'boolean',
        enumerable: 'boolean',
        writable: 'boolean'
    };
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (!('value' in obj) && !('writable' in obj)) {
        return false;
    }
    for (var key in obj) {
        if (key === 'value')
            continue;
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === data[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
};

var isDescriptor = function isDescriptor(obj, key) {
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if ('get' in obj) {
        return isAccessorDescriptor_1(obj, key);
    }
    return isDataDescriptor(obj, key);
};

var define = (typeof Reflect !== 'undefined' && Reflect.defineProperty)
    ? Reflect.defineProperty
    : Object.defineProperty;
var defineProperty = function defineProperty(obj, key, val) {
    if (!isobject(obj) && typeof obj !== 'function' && !Array.isArray(obj)) {
        throw new TypeError('expected an object, function, or array');
    }
    if (typeof key !== 'string') {
        throw new TypeError('expected "key" to be a string');
    }
    if (isDescriptor(val)) {
        define(obj, key, val);
        return obj;
    }
    define(obj, key, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
    return obj;
};

function isObjectObject(o) {
    return isobject(o) === true
        && Object.prototype.toString.call(o) === '[object Object]';
}
var isPlainObject = function isPlainObject(o) {
    var ctor, prot;
    if (isObjectObject(o) === false)
        return false;
    // If has modified constructor
    ctor = o.constructor;
    if (typeof ctor !== 'function')
        return false;
    // If has modified prototype
    prot = ctor.prototype;
    if (isObjectObject(prot) === false)
        return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
    }
    // Most likely a plain Object
    return true;
};

var isExtendable = function isExtendable(val) {
    return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var assignSymbols = function (receiver, objects) {
    if (receiver === null || typeof receiver === 'undefined') {
        throw new TypeError('expected first argument to be an object.');
    }
    if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
        return receiver;
    }
    if (typeof Object.getOwnPropertySymbols !== 'function') {
        return receiver;
    }
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var target = Object(receiver);
    var len = arguments.length, i = 0;
    while (++i < len) {
        var provider = Object(arguments[i]);
        var names = Object.getOwnPropertySymbols(provider);
        for (var j = 0; j < names.length; j++) {
            var key = names[j];
            if (isEnumerable.call(provider, key)) {
                target[key] = provider[key];
            }
        }
    }
    return target;
};

var extendShallow = Object.assign || function (obj /*, objects*/) {
    if (obj === null || typeof obj === 'undefined') {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    if (!isObject$1(obj)) {
        obj = {};
    }
    for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isString(val)) {
            val = toObject$1(val);
        }
        if (isObject$1(val)) {
            assign(obj, val);
            assignSymbols(obj, val);
        }
    }
    return obj;
};
function assign(a, b) {
    for (var key in b) {
        if (hasOwn(b, key)) {
            a[key] = b[key];
        }
    }
}
function isString(val) {
    return (val && typeof val === 'string');
}
function toObject$1(str) {
    var obj = {};
    for (var i in str) {
        obj[i] = str[i];
    }
    return obj;
}
function isObject$1(val) {
    return (val && typeof val === 'object') || isExtendable(val);
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

/**
 * The main export is a function that takes a `pattern` string and an `options` object.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not('foo'));
 & //=> /^(?:(?!^(?:foo)$).)*$/
 * ```
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
 * @api public
 */
function toRegex(pattern, options) {
    return new RegExp(toRegex.create(pattern, options));
}
/**
 * Create a regex-compatible string from the given `pattern` and `options`.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not.create('foo'));
 & //=> '^(?:(?!^(?:foo)$).)*$'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */
toRegex.create = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    var opts = extendShallow({}, options);
    if (opts.contains === true) {
        opts.strictNegate = false;
    }
    var open = opts.strictOpen !== false ? '^' : '';
    var close = opts.strictClose !== false ? '$' : '';
    var endChar = opts.endChar ? opts.endChar : '+';
    var str = pattern;
    if (opts.strictNegate === false) {
        str = '(?:(?!(?:' + pattern + ')).)' + endChar;
    }
    else {
        str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;
    }
    var res = open + str + close;
    if (opts.safe === true && safeRegex(res) === false) {
        throw new Error('potentially unsafe regular expression: ' + res);
    }
    return res;
};
/**
 * Expose `toRegex`
 */
var regexNot = toRegex;

var MAX_LENGTH = 1024 * 64;
/**
 * Session cache
 */
var cache = {};
/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
var toRegex$1 = function (patterns, options) {
    if (!Array.isArray(patterns)) {
        return makeRe(patterns, options);
    }
    return makeRe(patterns.join('|'), options);
};
/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
function makeRe(pattern, options) {
    if (pattern instanceof RegExp) {
        return pattern;
    }
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    if (pattern.length > MAX_LENGTH) {
        throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
    }
    var key = pattern;
    // do this before shallow cloning options, it's a lot faster
    if (!options || (options && options.cache !== false)) {
        key = createKey(pattern, options);
        if (cache.hasOwnProperty(key)) {
            return cache[key];
        }
    }
    var opts = extendShallow({}, options);
    if (opts.contains === true) {
        if (opts.negate === true) {
            opts.strictNegate = false;
        }
        else {
            opts.strict = false;
        }
    }
    if (opts.strict === false) {
        opts.strictOpen = false;
        opts.strictClose = false;
    }
    var open = opts.strictOpen !== false ? '^' : '';
    var close = opts.strictClose !== false ? '$' : '';
    var flags = opts.flags || '';
    var regex;
    if (opts.nocase === true && !/i/.test(flags)) {
        flags += 'i';
    }
    try {
        if (opts.negate || typeof opts.strictNegate === 'boolean') {
            pattern = regexNot.create(pattern, opts);
        }
        var str = open + '(?:' + pattern + ')' + close;
        regex = new RegExp(str, flags);
        if (opts.safe === true && safeRegex(regex) === false) {
            throw new Error('potentially unsafe regular expression: ' + regex.source);
        }
    }
    catch (err) {
        if (opts.strictErrors === true || opts.safe === true) {
            err.key = key;
            err.pattern = pattern;
            err.originalOptions = options;
            err.createdOptions = opts;
            throw err;
        }
        try {
            regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
        }
        catch (err) {
            regex = /.^/; //<= match nothing
        }
    }
    if (opts.cache !== false) {
        memoize(regex, key, pattern, opts);
    }
    return regex;
}
/**
 * Memoize generated regex. This can result in dramatic speed improvements
 * and simplify debugging by adding options and pattern to the regex. It can be
 * disabled by passing setting `options.cache` to false.
 */
function memoize(regex, key, pattern, options) {
    defineProperty(regex, 'cached', true);
    defineProperty(regex, 'pattern', pattern);
    defineProperty(regex, 'options', options);
    defineProperty(regex, 'key', key);
    cache[key] = regex;
}
/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */
function createKey(pattern, options) {
    if (!options)
        return pattern;
    var key = pattern;
    for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
            key += ';' + prop + '=' + String(options[prop]);
        }
    }
    return key;
}
/**
 * Expose `makeRe`
 */
var makeRe_1 = makeRe;
toRegex$1.makeRe = makeRe_1;

var arrayUnique = createCommonjsModule(function (module) {
    module.exports = function unique(arr) {
        if (!Array.isArray(arr)) {
            throw new TypeError('array-unique expects an array.');
        }
        var len = arr.length;
        var i = -1;
        while (i++ < len) {
            var j = i + 1;
            for (; j < arr.length; ++j) {
                if (arr[i] === arr[j]) {
                    arr.splice(j--, 1);
                }
            }
        }
        return arr;
    };
    module.exports.immutable = function uniqueImmutable(arr) {
        if (!Array.isArray(arr)) {
            throw new TypeError('array-unique expects an array.');
        }
        var arrLen = arr.length;
        var newArr = new Array(arrLen);
        for (var i = 0; i < arrLen; i++) {
            newArr[i] = arr[i];
        }
        return module.exports(newArr);
    };
});

/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtendable$1 = function isExtendable(val) {
    return typeof val !== 'undefined' && val !== null
        && (typeof val === 'object' || typeof val === 'function');
};

var extendShallow$1 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$1(o, obj);
        }
    }
    return o;
};
function assign$1(a, b) {
    for (var key in b) {
        if (hasOwn$1(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$1(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

var splitString = function (str, options, fn) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string');
    }
    if (typeof options === 'function') {
        fn = options;
        options = null;
    }
    // allow separator to be defined as a string
    if (typeof options === 'string') {
        options = { sep: options };
    }
    var opts = extendShallow({ sep: '.' }, options);
    var quotes = opts.quotes || ['"', "'", '`'];
    var brackets;
    if (opts.brackets === true) {
        brackets = {
            '<': '>',
            '(': ')',
            '[': ']',
            '{': '}'
        };
    }
    else if (opts.brackets) {
        brackets = opts.brackets;
    }
    var tokens = [];
    var stack = [];
    var arr = [''];
    var sep = opts.sep;
    var len = str.length;
    var idx = -1;
    var closeIdx;
    function expected() {
        if (brackets && stack.length) {
            return brackets[stack[stack.length - 1]];
        }
    }
    while (++idx < len) {
        var ch = str[idx];
        var next = str[idx + 1];
        var tok = { val: ch, idx: idx, arr: arr, str: str };
        tokens.push(tok);
        if (ch === '\\') {
            tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;
            tok.escaped = true;
            if (typeof fn === 'function') {
                fn(tok);
            }
            arr[arr.length - 1] += tok.val;
            idx++;
            continue;
        }
        if (brackets && brackets[ch]) {
            stack.push(ch);
            var e = expected();
            var i = idx + 1;
            if (str.indexOf(e, i + 1) !== -1) {
                while (stack.length && i < len) {
                    var s = str[++i];
                    if (s === '\\') {
                        s++;
                        continue;
                    }
                    if (quotes.indexOf(s) !== -1) {
                        i = getClosingQuote(str, s, i + 1);
                        continue;
                    }
                    e = expected();
                    if (stack.length && str.indexOf(e, i + 1) === -1) {
                        break;
                    }
                    if (brackets[s]) {
                        stack.push(s);
                        continue;
                    }
                    if (e === s) {
                        stack.pop();
                    }
                }
            }
            closeIdx = i;
            if (closeIdx === -1) {
                arr[arr.length - 1] += ch;
                continue;
            }
            ch = str.slice(idx, closeIdx + 1);
            tok.val = ch;
            tok.idx = idx = closeIdx;
        }
        if (quotes.indexOf(ch) !== -1) {
            closeIdx = getClosingQuote(str, ch, idx + 1);
            if (closeIdx === -1) {
                arr[arr.length - 1] += ch;
                continue;
            }
            if (keepQuotes(ch, opts) === true) {
                ch = str.slice(idx, closeIdx + 1);
            }
            else {
                ch = str.slice(idx + 1, closeIdx);
            }
            tok.val = ch;
            tok.idx = idx = closeIdx;
        }
        if (typeof fn === 'function') {
            fn(tok, tokens);
            ch = tok.val;
            idx = tok.idx;
        }
        if (tok.val === sep && tok.split !== false) {
            arr.push('');
            continue;
        }
        arr[arr.length - 1] += tok.val;
    }
    return arr;
};
function getClosingQuote(str, ch, i, brackets) {
    var idx = str.indexOf(ch, i);
    if (str.charAt(idx - 1) === '\\') {
        return getClosingQuote(str, ch, idx + 1);
    }
    return idx;
}
function keepQuotes(ch, opts) {
    if (opts.keepDoubleQuotes === true && ch === '"')
        return true;
    if (opts.keepSingleQuotes === true && ch === "'")
        return true;
    return opts.keepQuotes;
}
function keepEscaping(opts, str, idx) {
    if (typeof opts.keepEscaping === 'function') {
        return opts.keepEscaping(str, idx);
    }
    return opts.keepEscaping === true || str[idx + 1] === '\\';
}

/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var arrFlatten = function (arr) {
    return flat(arr, []);
};
function flat(arr, res) {
    var i = 0, cur;
    var len = arr.length;
    for (; i < len; i++) {
        cur = arr[i];
        Array.isArray(cur) ? flat(cur, res) : res.push(cur);
    }
    return res;
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function (obj) {
    return obj != null && (isBuffer$1(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer$1(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer$1(obj.slice(0, 0));
}

var toString$2 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$1 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$2.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

var isNumber = function isNumber(num) {
    var type = kindOf$1(num);
    if (type === 'string') {
        if (!num.trim())
            return false;
    }
    else if (type !== 'number') {
        return false;
    }
    return (num - num + 1) >= 0;
};

var extendShallow$2 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$2(o, obj);
        }
    }
    return o;
};
function assign$2(a, b) {
    for (var key in b) {
        if (hasOwn$2(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$2(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/**
 * Results cache
 */
var res = '';
var cache$1;
/**
 * Expose `repeat`
 */
var repeatString = repeat;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */
function repeat(str, num) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string');
    }
    // cover common, quick use cases
    if (num === 1)
        return str;
    if (num === 2)
        return str + str;
    var max = str.length * num;
    if (cache$1 !== str || typeof cache$1 === 'undefined') {
        cache$1 = str;
        res = '';
    }
    else if (res.length >= max) {
        return res.substr(0, max);
    }
    while (max > res.length && num > 1) {
        if (num & 1) {
            res += str;
        }
        num >>= 1;
        str += str;
    }
    res += str;
    res = res.substr(0, max);
    return res;
}

var cache$2 = {};
function toRegexRange(min, max, options) {
    if (isNumber(min) === false) {
        throw new RangeError('toRegexRange: first argument is invalid.');
    }
    if (typeof max === 'undefined' || min === max) {
        return String(min);
    }
    if (isNumber(max) === false) {
        throw new RangeError('toRegexRange: second argument is invalid.');
    }
    options = options || {};
    var relax = String(options.relaxZeros);
    var shorthand = String(options.shorthand);
    var capture = String(options.capture);
    var key = min + ':' + max + '=' + relax + shorthand + capture;
    if (cache$2.hasOwnProperty(key)) {
        return cache$2[key].result;
    }
    var a = Math.min(min, max);
    var b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
        var result = min + '|' + max;
        if (options.capture) {
            return '(' + result + ')';
        }
        return result;
    }
    var isPadded = padding(min) || padding(max);
    var positives = [];
    var negatives = [];
    var tok = { min: min, max: max, a: a, b: b };
    if (isPadded) {
        tok.isPadded = isPadded;
        tok.maxLen = String(tok.max).length;
    }
    if (a < 0) {
        var newMin = b < 0 ? Math.abs(b) : 1;
        var newMax = Math.abs(a);
        negatives = splitToPatterns(newMin, newMax, tok, options);
        a = tok.a = 0;
    }
    if (b >= 0) {
        positives = splitToPatterns(a, b, tok, options);
    }
    tok.negatives = negatives;
    tok.positives = positives;
    tok.result = siftPatterns(negatives, positives, options);
    if (options.capture && (positives.length + negatives.length) > 1) {
        tok.result = '(' + tok.result + ')';
    }
    cache$2[key] = tok;
    return tok.result;
}
function siftPatterns(neg, pos, options) {
    var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
    var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
    var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
    var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
}
function splitToRanges(min, max) {
    min = Number(min);
    max = Number(max);
    var nines = 1;
    var stops = [max];
    var stop = +countNines(min, nines);
    while (min <= stop && stop <= max) {
        stops = push(stops, stop);
        nines += 1;
        stop = +countNines(min, nines);
    }
    var zeros = 1;
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
        stops = push(stops, stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
    }
    stops.sort(compare);
    return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */
function rangeToPattern(start, stop, options) {
    if (start === stop) {
        return { pattern: String(start), digits: [] };
    }
    var zipped = zip(String(start), String(stop));
    var len = zipped.length, i = -1;
    var pattern = '';
    var digits = 0;
    while (++i < len) {
        var numbers = zipped[i];
        var startDigit = numbers[0];
        var stopDigit = numbers[1];
        if (startDigit === stopDigit) {
            pattern += startDigit;
        }
        else if (startDigit !== '0' || stopDigit !== '9') {
            pattern += toCharacterClass(startDigit, stopDigit);
        }
        else {
            digits += 1;
        }
    }
    if (digits) {
        pattern += options.shorthand ? '\\d' : '[0-9]';
    }
    return { pattern: pattern, digits: [digits] };
}
function splitToPatterns(min, max, tok, options) {
    var ranges = splitToRanges(min, max);
    var len = ranges.length;
    var idx = -1;
    var tokens = [];
    var start = min;
    var prev;
    while (++idx < len) {
        var range = ranges[idx];
        var obj = rangeToPattern(start, range, options);
        var zeros = '';
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.digits.length > 1) {
                prev.digits.pop();
            }
            prev.digits.push(obj.digits[0]);
            prev.string = prev.pattern + toQuantifier(prev.digits);
            start = range + 1;
            continue;
        }
        if (tok.isPadded) {
            zeros = padZeros(range, tok);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
        tokens.push(obj);
        start = range + 1;
        prev = obj;
    }
    return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options) {
    var res = [];
    for (var i = 0; i < arr.length; i++) {
        var tok = arr[i];
        var ele = tok.string;
        if (options.relaxZeros !== false) {
            if (prefix === '-' && ele.charAt(0) === '0') {
                if (ele.charAt(1) === '{') {
                    ele = '0*' + ele.replace(/^0\{\d+\}/, '');
                }
                else {
                    ele = '0*' + ele.slice(1);
                }
            }
        }
        if (!intersection && !contains(comparison, 'string', ele)) {
            res.push(prefix + ele);
        }
        if (intersection && contains(comparison, 'string', ele)) {
            res.push(prefix + ele);
        }
    }
    return res;
}
/**
 * Zip strings (`for in` can be used on string characters)
 */
function zip(a, b) {
    var arr = [];
    for (var ch in a)
        arr.push([a[ch], b[ch]]);
    return arr;
}
function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
}
function push(arr, ele) {
    if (arr.indexOf(ele) === -1)
        arr.push(ele);
    return arr;
}
function contains(arr, key, val) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i][key] === val) {
            return true;
        }
    }
    return false;
}
function countNines(min, len) {
    return String(min).slice(0, -len) + repeatString('9', len);
}
function countZeros(integer, zeros) {
    return integer - (integer % Math.pow(10, zeros));
}
function toQuantifier(digits) {
    var start = digits[0];
    var stop = digits[1] ? (',' + digits[1]) : '';
    if (!stop && (!start || start === 1)) {
        return '';
    }
    return '{' + start + stop + '}';
}
function toCharacterClass(a, b) {
    return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
}
function padding(str) {
    return /^-?(0+)\d/.exec(str);
}
function padZeros(val, tok) {
    if (tok.isPadded) {
        var diff = Math.abs(tok.maxLen - String(val).length);
        switch (diff) {
            case 0:
                return '';
            case 1:
                return '0';
            default: {
                return '0{' + diff + '}';
            }
        }
    }
    return val;
}
/**
 * Expose `toRegexRange`
 */
var toRegexRange_1 = toRegexRange;

/**
 * Return a range of numbers or letters.
 *
 * @param  {String} `start` Start of the range
 * @param  {String} `stop` End of the range
 * @param  {String} `step` Increment or decrement to use.
 * @param  {Function} `fn` Custom function to modify each element in the range.
 * @return {Array}
 */
function fillRange(start, stop, step, options) {
    if (typeof start === 'undefined') {
        return [];
    }
    if (typeof stop === 'undefined' || start === stop) {
        // special case, for handling negative zero
        var isString = typeof start === 'string';
        if (isNumber(start) && !toNumber(start)) {
            return [isString ? '0' : 0];
        }
        return [start];
    }
    if (typeof step !== 'number' && typeof step !== 'string') {
        options = step;
        step = undefined;
    }
    if (typeof options === 'function') {
        options = { transform: options };
    }
    var opts = extendShallow$2({ step: step }, options);
    if (opts.step && !isValidNumber(opts.step)) {
        if (opts.strictRanges === true) {
            throw new TypeError('expected options.step to be a number');
        }
        return [];
    }
    opts.isNumber = isValidNumber(start) && isValidNumber(stop);
    if (!opts.isNumber && !isValid(start, stop)) {
        if (opts.strictRanges === true) {
            throw new RangeError('invalid range arguments: ' + util$2.inspect([start, stop]));
        }
        return [];
    }
    opts.isPadded = isPadded(start) || isPadded(stop);
    opts.toString = opts.stringify
        || typeof opts.step === 'string'
        || typeof start === 'string'
        || typeof stop === 'string'
        || !opts.isNumber;
    if (opts.isPadded) {
        opts.maxLength = Math.max(String(start).length, String(stop).length);
    }
    // support legacy minimatch/fill-range options
    if (typeof opts.optimize === 'boolean')
        opts.toRegex = opts.optimize;
    if (typeof opts.makeRe === 'boolean')
        opts.toRegex = opts.makeRe;
    return expand(start, stop, opts);
}
function expand(start, stop, options) {
    var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
    var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);
    var step = Math.abs(toNumber(options.step)) || 1;
    if (options.toRegex && step === 1) {
        return toRange(a, b, start, stop, options);
    }
    var zero = { greater: [], lesser: [] };
    var asc = a < b;
    var arr = new Array(Math.round((asc ? b - a : a - b) / step));
    var idx = 0;
    while (asc ? a <= b : a >= b) {
        var val = options.isNumber ? a : String.fromCharCode(a);
        if (options.toRegex && (val >= 0 || !options.isNumber)) {
            zero.greater.push(val);
        }
        else {
            zero.lesser.push(Math.abs(val));
        }
        if (options.isPadded) {
            val = zeros(val, options);
        }
        if (options.toString) {
            val = String(val);
        }
        if (typeof options.transform === 'function') {
            arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
        }
        else {
            arr[idx++] = val;
        }
        if (asc) {
            a += step;
        }
        else {
            a -= step;
        }
    }
    if (options.toRegex === true) {
        return toSequence(arr, zero, options);
    }
    return arr;
}
function toRange(a, b, start, stop, options) {
    if (options.isPadded) {
        return toRegexRange_1(start, stop, options);
    }
    if (options.isNumber) {
        return toRegexRange_1(Math.min(a, b), Math.max(a, b), options);
    }
    var start = String.fromCharCode(Math.min(a, b));
    var stop = String.fromCharCode(Math.max(a, b));
    return '[' + start + '-' + stop + ']';
}
function toSequence(arr, zeros, options) {
    var greater = '', lesser = '';
    if (zeros.greater.length) {
        greater = zeros.greater.join('|');
    }
    if (zeros.lesser.length) {
        lesser = '-(' + zeros.lesser.join('|') + ')';
    }
    var res = greater && lesser
        ? greater + '|' + lesser
        : greater || lesser;
    if (options.capture) {
        return '(' + res + ')';
    }
    return res;
}
function zeros(val, options) {
    if (options.isPadded) {
        var str = String(val);
        var len = str.length;
        var dash = '';
        if (str.charAt(0) === '-') {
            dash = '-';
            str = str.slice(1);
        }
        var diff = options.maxLength - len;
        var pad = repeatString('0', diff);
        val = (dash + pad + str);
    }
    if (options.stringify) {
        return String(val);
    }
    return val;
}
function toNumber(val) {
    return Number(val) || 0;
}
function isPadded(str) {
    return /^-?0\d/.test(str);
}
function isValid(min, max) {
    return (isValidNumber(min) || isValidLetter(min))
        && (isValidNumber(max) || isValidLetter(max));
}
function isValidLetter(ch) {
    return typeof ch === 'string' && ch.length === 1 && /^\w+$/.test(ch);
}
function isValidNumber(n) {
    return isNumber(n) && !/\./.test(n);
}
/**
 * Expose `fillRange`
 * @type {Function}
 */
var fillRange_1 = fillRange;

/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */
var repeatElement = function repeat(ele, num) {
    var arr = new Array(num);
    for (var i = 0; i < num; i++) {
        arr[i] = ele;
    }
    return arr;
};

var utils_1 = createCommonjsModule(function (module) {
    var utils = module.exports;
    /**
     * Module dependencies
     */
    utils.extend = extendShallow$1;
    utils.flatten = arrFlatten;
    utils.isObject = isobject;
    utils.fillRange = fillRange_1;
    utils.repeat = repeatElement;
    utils.unique = arrayUnique;
    utils.define = function (obj, key, val) {
        Object.defineProperty(obj, key, {
            writable: true,
            configurable: true,
            enumerable: false,
            value: val
        });
    };
    /**
     * Returns true if the given string contains only empty brace sets.
     */
    utils.isEmptySets = function (str) {
        return /^(?:\{,\})+$/.test(str);
    };
    /**
     * Returns true if the given string contains only empty brace sets.
     */
    utils.isQuotedString = function (str) {
        var open = str.charAt(0);
        if (open === '\'' || open === '"' || open === '`') {
            return str.slice(-1) === open;
        }
        return false;
    };
    /**
     * Create the key to use for memoization. The unique key is generated
     * by iterating over the options and concatenating key-value pairs
     * to the pattern string.
     */
    utils.createKey = function (pattern, options) {
        var id = pattern;
        if (typeof options === 'undefined') {
            return id;
        }
        var keys = Object.keys(options);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            id += ';' + key + '=' + String(options[key]);
        }
        return id;
    };
    /**
     * Normalize options
     */
    utils.createOptions = function (options) {
        var opts = utils.extend.apply(null, arguments);
        if (typeof opts.expand === 'boolean') {
            opts.optimize = !opts.expand;
        }
        if (typeof opts.optimize === 'boolean') {
            opts.expand = !opts.optimize;
        }
        if (opts.optimize === true) {
            opts.makeRe = true;
        }
        return opts;
    };
    /**
     * Join patterns in `a` to patterns in `b`
     */
    utils.join = function (a, b, options) {
        options = options || {};
        a = utils.arrayify(a);
        b = utils.arrayify(b);
        if (!a.length)
            return b;
        if (!b.length)
            return a;
        var len = a.length;
        var idx = -1;
        var arr = [];
        while (++idx < len) {
            var val = a[idx];
            if (Array.isArray(val)) {
                for (var i = 0; i < val.length; i++) {
                    val[i] = utils.join(val[i], b, options);
                }
                arr.push(val);
                continue;
            }
            for (var j = 0; j < b.length; j++) {
                var bval = b[j];
                if (Array.isArray(bval)) {
                    arr.push(utils.join(val, bval, options));
                }
                else {
                    arr.push(val + bval);
                }
            }
        }
        return arr;
    };
    /**
     * Split the given string on `,` if not escaped.
     */
    utils.split = function (str, options) {
        var opts = utils.extend({ sep: ',' }, options);
        if (typeof opts.keepQuotes !== 'boolean') {
            opts.keepQuotes = true;
        }
        if (opts.unescape === false) {
            opts.keepEscaping = true;
        }
        return splitString(str, opts, utils.escapeBrackets(opts));
    };
    /**
     * Expand ranges or sets in the given `pattern`.
     *
     * @param {String} `str`
     * @param {Object} `options`
     * @return {Object}
     */
    utils.expand = function (str, options) {
        var opts = utils.extend({ rangeLimit: 10000 }, options);
        var segs = utils.split(str, opts);
        var tok = { segs: segs };
        if (utils.isQuotedString(str)) {
            return tok;
        }
        if (opts.rangeLimit === true) {
            opts.rangeLimit = 10000;
        }
        if (segs.length > 1) {
            if (opts.optimize === false) {
                tok.val = segs[0];
                return tok;
            }
            tok.segs = utils.stringifyArray(tok.segs);
        }
        else if (segs.length === 1) {
            var arr = str.split('..');
            if (arr.length === 1) {
                tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
                tok.segs = [];
                return tok;
            }
            if (arr.length === 2 && arr[0] === arr[1]) {
                tok.escaped = true;
                tok.val = arr[0];
                tok.segs = [];
                return tok;
            }
            if (arr.length > 1) {
                if (opts.optimize !== false) {
                    opts.optimize = true;
                    delete opts.expand;
                }
                if (opts.optimize !== true) {
                    var min = Math.min(arr[0], arr[1]);
                    var max = Math.max(arr[0], arr[1]);
                    var step = arr[2] || 1;
                    if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {
                        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
                    }
                }
                arr.push(opts);
                tok.segs = utils.fillRange.apply(null, arr);
                if (!tok.segs.length) {
                    tok.escaped = true;
                    tok.val = str;
                    return tok;
                }
                if (opts.optimize === true) {
                    tok.segs = utils.stringifyArray(tok.segs);
                }
                if (tok.segs === '') {
                    tok.val = str;
                }
                else {
                    tok.val = tok.segs[0];
                }
                return tok;
            }
        }
        else {
            tok.val = str;
        }
        return tok;
    };
    /**
     * Ensure commas inside brackets and parens are not split.
     * @param {Object} `tok` Token from the `split-string` module
     * @return {undefined}
     */
    utils.escapeBrackets = function (options) {
        return function (tok) {
            if (tok.escaped && tok.val === 'b') {
                tok.val = '\\b';
                return;
            }
            if (tok.val !== '(' && tok.val !== '[')
                return;
            var opts = utils.extend({}, options);
            var stack = [];
            var val = tok.val;
            var str = tok.str;
            var i = tok.idx - 1;
            while (++i < str.length) {
                var ch = str[i];
                if (ch === '\\') {
                    val += (opts.keepEscaping === false ? '' : ch) + str[++i];
                    continue;
                }
                if (ch === '(') {
                    stack.push(ch);
                }
                if (ch === '[') {
                    stack.push(ch);
                }
                if (ch === ')') {
                    stack.pop();
                    if (!stack.length) {
                        val += ch;
                        break;
                    }
                }
                if (ch === ']') {
                    stack.pop();
                    if (!stack.length) {
                        val += ch;
                        break;
                    }
                }
                val += ch;
            }
            tok.split = false;
            tok.val = val.slice(1);
            tok.idx = i;
        };
    };
    /**
     * Returns true if the given string looks like a regex quantifier
     * @return {Boolean}
     */
    utils.isQuantifier = function (str) {
        return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
    };
    /**
     * Cast `val` to an array.
     * @param {*} `val`
     */
    utils.stringifyArray = function (arr) {
        return [utils.arrayify(arr).join('|')];
    };
    /**
     * Cast `val` to an array.
     * @param {*} `val`
     */
    utils.arrayify = function (arr) {
        if (typeof arr === 'undefined') {
            return [];
        }
        if (typeof arr === 'string') {
            return [arr];
        }
        return arr;
    };
    /**
     * Returns true if the given `str` is a non-empty string
     * @return {Boolean}
     */
    utils.isString = function (str) {
        return str != null && typeof str === 'string';
    };
    /**
     * Get the last element from `array`
     * @param {Array} `array`
     * @return {*}
     */
    utils.last = function (arr, n) {
        return arr[arr.length - (n || 1)];
    };
    utils.escapeRegex = function (str) {
        return str.replace(/\\?([!^*?()[\]{}+?/])/g, '\\$1');
    };
});

var compilers = function (braces, options) {
    braces.compiler
        /**
         * bos
         */
        .set('bos', function () {
        if (this.output)
            return;
        this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
        this.ast.count = 1;
    })
        /**
         * Square brackets
         */
        .set('bracket', function (node) {
        var close = node.close;
        var open = !node.escaped ? '[' : '\\[';
        var negated = node.negated;
        var inner = node.inner;
        inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
        if (inner === ']-') {
            inner = '\\]\\-';
        }
        if (negated && inner.indexOf('.') === -1) {
            inner += '.';
        }
        if (negated && inner.indexOf('/') === -1) {
            inner += '/';
        }
        var val = open + negated + inner + close;
        var queue = node.parent.queue;
        var last = utils_1.arrayify(queue.pop());
        queue.push(utils_1.join(last, val));
        queue.push.apply(queue, []);
    })
        /**
         * Brace
         */
        .set('brace', function (node) {
        node.queue = isEscaped(node) ? [node.val] : [];
        node.count = 1;
        return this.mapVisit(node.nodes);
    })
        /**
         * Open
         */
        .set('brace.open', function (node) {
        node.parent.open = node.val;
    })
        /**
         * Inner
         */
        .set('text', function (node) {
        var queue = node.parent.queue;
        var escaped = node.escaped;
        var segs = [node.val];
        if (node.optimize === false) {
            options = utils_1.extend({}, options, { optimize: false });
        }
        if (node.multiplier > 1) {
            node.parent.count *= node.multiplier;
        }
        if (options.quantifiers === true && utils_1.isQuantifier(node.val)) {
            escaped = true;
        }
        else if (node.val.length > 1) {
            if (isType(node.parent, 'brace') && !isEscaped(node)) {
                var expanded = utils_1.expand(node.val, options);
                segs = expanded.segs;
                if (expanded.isOptimized) {
                    node.parent.isOptimized = true;
                }
                // if nothing was expanded, we probably have a literal brace
                if (!segs.length) {
                    var val = (expanded.val || node.val);
                    if (options.unescape !== false) {
                        // unescape unexpanded brace sequence/set separators
                        val = val.replace(/\\([,.])/g, '$1');
                        // strip quotes
                        val = val.replace(/["'`]/g, '');
                    }
                    segs = [val];
                    escaped = true;
                }
            }
        }
        else if (node.val === ',') {
            if (options.expand) {
                node.parent.queue.push(['']);
                segs = [''];
            }
            else {
                segs = ['|'];
            }
        }
        else {
            escaped = true;
        }
        if (escaped && isType(node.parent, 'brace')) {
            if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
                node.parent.escaped = true;
            }
            else if (node.parent.length <= 3) {
                node.parent.escaped = true;
            }
        }
        if (!hasQueue(node.parent)) {
            node.parent.queue = segs;
            return;
        }
        var last = utils_1.arrayify(queue.pop());
        if (node.parent.count > 1 && options.expand) {
            last = multiply(last, node.parent.count);
            node.parent.count = 1;
        }
        queue.push(utils_1.join(utils_1.flatten(last), segs.shift()));
        queue.push.apply(queue, segs);
    })
        /**
         * Close
         */
        .set('brace.close', function (node) {
        var queue = node.parent.queue;
        var prev = node.parent.parent;
        var last = prev.queue.pop();
        var open = node.parent.open;
        var close = node.val;
        if (open && close && isOptimized(node, options)) {
            open = '(';
            close = ')';
        }
        // if a close brace exists, and the previous segment is one character
        // don't wrap the result in braces or parens
        var ele = utils_1.last(queue);
        if (node.parent.count > 1 && options.expand) {
            ele = multiply(queue.pop(), node.parent.count);
            node.parent.count = 1;
            queue.push(ele);
        }
        if (close && typeof ele === 'string' && ele.length === 1) {
            open = '';
            close = '';
        }
        if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
            queue.push(utils_1.join(open, queue.pop() || ''));
            queue = utils_1.flatten(utils_1.join(queue, close));
        }
        if (typeof last === 'undefined') {
            prev.queue = [queue];
        }
        else {
            prev.queue.push(utils_1.flatten(utils_1.join(last, queue)));
        }
    })
        /**
         * eos
         */
        .set('eos', function (node) {
        if (this.input)
            return;
        if (options.optimize !== false) {
            this.output = utils_1.last(utils_1.flatten(this.ast.queue));
        }
        else if (Array.isArray(utils_1.last(this.ast.queue))) {
            this.output = utils_1.flatten(this.ast.queue.pop());
        }
        else {
            this.output = utils_1.flatten(this.ast.queue);
        }
        if (node.parent.count > 1 && options.expand) {
            this.output = multiply(this.output, node.parent.count);
        }
        this.output = utils_1.arrayify(this.output);
        this.ast.queue = [];
    });
};
/**
 * Multiply the segments in the current brace level
 */
function multiply(queue, n, options) {
    return utils_1.flatten(utils_1.repeat(utils_1.arrayify(queue), n));
}
/**
 * Return true if `node` is escaped
 */
function isEscaped(node) {
    return node.escaped === true;
}
/**
 * Returns true if regex parens should be used for sets. If the parent `type`
 * is not `brace`, then we're on a root node, which means we should never
 * expand segments and open/close braces should be `{}` (since this indicates
 * a brace is missing from the set)
 */
function isOptimized(node, options) {
    if (node.parent.isOptimized)
        return true;
    return isType(node.parent, 'brace')
        && !isEscaped(node.parent)
        && options.expand !== true;
}
/**
 * Returns true if the value in `node` should be wrapped in a literal brace.
 * @return {Boolean}
 */
function isLiteralBrace(node, options) {
    return isEscaped(node.parent) || options.optimize !== false;
}
/**
 * Returns true if the given `node` does not have an inner value.
 * @return {Boolean}
 */
function noInner(node, type) {
    if (node.parent.queue.length === 1) {
        return true;
    }
    var nodes = node.parent.nodes;
    return nodes.length === 3
        && isType(nodes[0], 'brace.open')
        && !isType(nodes[1], 'text')
        && isType(nodes[2], 'brace.close');
}
/**
 * Returns true if the given `node` is the given `type`
 * @return {Boolean}
 */
function isType(node, type) {
    return typeof node !== 'undefined' && node.type === type;
}
/**
 * Returns true if the given `node` has a non-empty queue.
 * @return {Boolean}
 */
function hasQueue(node) {
    return Array.isArray(node.queue) && node.queue.length;
}

// accessor descriptor properties
var accessor$1 = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
};
function isAccessorDescriptor$1(obj, prop) {
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (has$2(obj, 'value') || has$2(obj, 'writable')) {
        return false;
    }
    if (!has$2(obj, 'get') || typeof obj.get !== 'function') {
        return false;
    }
    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has$2(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
        return false;
    }
    for (var key in obj) {
        if (!accessor$1.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === accessor$1[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
function has$2(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
/**
 * Expose `isAccessorDescriptor`
 */
var isAccessorDescriptor_1$1 = isAccessorDescriptor$1;

var isDataDescriptor$1 = function isDataDescriptor(obj, prop) {
    // data descriptor properties
    var data = {
        configurable: 'boolean',
        enumerable: 'boolean',
        writable: 'boolean'
    };
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (!('value' in obj) && !('writable' in obj)) {
        return false;
    }
    for (var key in obj) {
        if (key === 'value')
            continue;
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === data[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
};

var isDescriptor$1 = function isDescriptor(obj, key) {
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if ('get' in obj) {
        return isAccessorDescriptor_1$1(obj, key);
    }
    return isDataDescriptor$1(obj, key);
};

var defineProperty$1 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$1(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

var toString$3 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$2 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$3.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

var snapdragonUtil = createCommonjsModule(function (module) {
    var utils = module.exports;
    /**
     * Returns true if the given value is a node.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var node = new Node({type: 'foo'});
     * console.log(utils.isNode(node)); //=> true
     * console.log(utils.isNode({})); //=> false
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @returns {Boolean}
     * @api public
     */
    utils.isNode = function (node) {
        return kindOf$2(node) === 'object' && node.isNode === true;
    };
    /**
     * Emit an empty string for the given `node`.
     *
     * ```js
     * // do nothing for beginning-of-string
     * snapdragon.compiler.set('bos', utils.noop);
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @returns {undefined}
     * @api public
     */
    utils.noop = function (node) {
        append(this, '', node);
    };
    /**
     * Appdend `node.val` to `compiler.output`, exactly as it was created
     * by the parser.
     *
     * ```js
     * snapdragon.compiler.set('text', utils.identity);
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @returns {undefined}
     * @api public
     */
    utils.identity = function (node) {
        append(this, node.val, node);
    };
    /**
     * Previously named `.emit`, this method appends the given `val`
     * to `compiler.output` for the given node. Useful when you know
     * what value should be appended advance, regardless of the actual
     * value of `node.val`.
     *
     * ```js
     * snapdragon.compiler
     *   .set('i', function(node) {
     *     this.mapVisit(node);
     *   })
     *   .set('i.open', utils.append('<i>'))
     *   .set('i.close', utils.append('</i>'))
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @returns {Function} Returns a compiler middleware function.
     * @api public
     */
    utils.append = function (val) {
        return function (node) {
            append(this, val, node);
        };
    };
    /**
     * Used in compiler middleware, this onverts an AST node into
     * an empty `text` node and deletes `node.nodes` if it exists.
     * The advantage of this method is that, as opposed to completely
     * removing the node, indices will not need to be re-calculated
     * in sibling nodes, and nothing is appended to the output.
     *
     * ```js
     * utils.toNoop(node);
     * // convert `node.nodes` to the given value instead of deleting it
     * utils.toNoop(node, []);
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
     * @api public
     */
    utils.toNoop = function (node, nodes) {
        if (nodes) {
            node.nodes = nodes;
        }
        else {
            delete node.nodes;
            node.type = 'text';
            node.val = '';
        }
    };
    /**
     * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
     * automatically calls registered compilers, this allows you to pass a visitor
     * function.
     *
     * ```js
     * snapdragon.compiler.set('i', function(node) {
     *   utils.visit(node, function(childNode) {
     *     // do stuff with "childNode"
     *     return childNode;
     *   });
     * });
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Function} `fn`
     * @return {Object} returns the node after recursively visiting all child nodes.
     * @api public
     */
    utils.visit = function (node, fn) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isFunction(fn), 'expected a visitor function');
        fn(node);
        return node.nodes ? utils.mapVisit(node, fn) : node;
    };
    /**
     * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
     * [visit](#visit), use this method if you do not want `fn` to be called on
     * the first node.
     *
     * ```js
     * snapdragon.compiler.set('i', function(node) {
     *   utils.mapVisit(node, function(childNode) {
     *     // do stuff with "childNode"
     *     return childNode;
     *   });
     * });
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Object} `options`
     * @param {Function} `fn`
     * @return {Object} returns the node
     * @api public
     */
    utils.mapVisit = function (node, fn) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isArray(node.nodes), 'expected node.nodes to be an array');
        assert(isFunction(fn), 'expected a visitor function');
        for (var i = 0; i < node.nodes.length; i++) {
            utils.visit(node.nodes[i], fn);
        }
        return node;
    };
    /**
     * Unshift an `*.open` node onto `node.nodes`.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * snapdragon.parser.set('brace', function(node) {
     *   var match = this.match(/^{/);
     *   if (match) {
     *     var parent = new Node({type: 'brace'});
     *     utils.addOpen(parent, Node);
     *     console.log(parent.nodes[0]):
     *     // { type: 'brace.open', val: '' };
     *
     *     // push the parent "brace" node onto the stack
     *     this.push(parent);
     *
     *     // return the parent node, so it's also added to the AST
     *     return brace;
     *   }
     * });
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
     * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
     * @return {Object} Returns the created opening node.
     * @api public
     */
    utils.addOpen = function (node, Node, val, filter) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isFunction(Node), 'expected Node to be a constructor function');
        if (typeof val === 'function') {
            filter = val;
            val = '';
        }
        if (typeof filter === 'function' && !filter(node))
            return;
        var open = new Node({ type: node.type + '.open', val: val });
        var unshift = node.unshift || node.unshiftNode;
        if (typeof unshift === 'function') {
            unshift.call(node, open);
        }
        else {
            utils.unshiftNode(node, open);
        }
        return open;
    };
    /**
     * Push a `*.close` node onto `node.nodes`.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * snapdragon.parser.set('brace', function(node) {
     *   var match = this.match(/^}/);
     *   if (match) {
     *     var parent = this.parent();
     *     if (parent.type !== 'brace') {
     *       throw new Error('missing opening: ' + '}');
     *     }
     *
     *     utils.addClose(parent, Node);
     *     console.log(parent.nodes[parent.nodes.length - 1]):
     *     // { type: 'brace.close', val: '' };
     *
     *     // no need to return a node, since the parent
     *     // was already added to the AST
     *     return;
     *   }
     * });
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
     * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
     * @return {Object} Returns the created closing node.
     * @api public
     */
    utils.addClose = function (node, Node, val, filter) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isFunction(Node), 'expected Node to be a constructor function');
        if (typeof val === 'function') {
            filter = val;
            val = '';
        }
        if (typeof filter === 'function' && !filter(node))
            return;
        var close = new Node({ type: node.type + '.close', val: val });
        var push = node.push || node.pushNode;
        if (typeof push === 'function') {
            push.call(node, close);
        }
        else {
            utils.pushNode(node, close);
        }
        return close;
    };
    /**
     * Wraps the given `node` with `*.open` and `*.close` nodes.
     *
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
     * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
     * @return {Object} Returns the node
     * @api public
     */
    utils.wrapNodes = function (node, Node, filter) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isFunction(Node), 'expected Node to be a constructor function');
        utils.addOpen(node, Node, filter);
        utils.addClose(node, Node, filter);
        return node;
    };
    /**
     * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
     *
     * ```js
     * var parent = new Node({type: 'foo'});
     * var node = new Node({type: 'bar'});
     * utils.pushNode(parent, node);
     * console.log(parent.nodes[0].type) // 'bar'
     * console.log(node.parent.type) // 'foo'
     * ```
     * @param {Object} `parent`
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Object} Returns the child node
     * @api public
     */
    utils.pushNode = function (parent, node) {
        assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        node.define('parent', parent);
        parent.nodes = parent.nodes || [];
        parent.nodes.push(node);
        return node;
    };
    /**
     * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
     *
     * ```js
     * var parent = new Node({type: 'foo'});
     * var node = new Node({type: 'bar'});
     * utils.unshiftNode(parent, node);
     * console.log(parent.nodes[0].type) // 'bar'
     * console.log(node.parent.type) // 'foo'
     * ```
     * @param {Object} `parent`
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {undefined}
     * @api public
     */
    utils.unshiftNode = function (parent, node) {
        assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        node.define('parent', parent);
        parent.nodes = parent.nodes || [];
        parent.nodes.unshift(node);
    };
    /**
     * Pop the last `node` off of `parent.nodes`. The advantage of
     * using this method is that it checks for `node.nodes` and works
     * with any version of `snapdragon-node`.
     *
     * ```js
     * var parent = new Node({type: 'foo'});
     * utils.pushNode(parent, new Node({type: 'foo'}));
     * utils.pushNode(parent, new Node({type: 'bar'}));
     * utils.pushNode(parent, new Node({type: 'baz'}));
     * console.log(parent.nodes.length); //=> 3
     * utils.popNode(parent);
     * console.log(parent.nodes.length); //=> 2
     * ```
     * @param {Object} `parent`
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
     * @api public
     */
    utils.popNode = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        if (typeof node.pop === 'function') {
            return node.pop();
        }
        return node.nodes && node.nodes.pop();
    };
    /**
     * Shift the first `node` off of `parent.nodes`. The advantage of
     * using this method is that it checks for `node.nodes` and works
     * with any version of `snapdragon-node`.
     *
     * ```js
     * var parent = new Node({type: 'foo'});
     * utils.pushNode(parent, new Node({type: 'foo'}));
     * utils.pushNode(parent, new Node({type: 'bar'}));
     * utils.pushNode(parent, new Node({type: 'baz'}));
     * console.log(parent.nodes.length); //=> 3
     * utils.shiftNode(parent);
     * console.log(parent.nodes.length); //=> 2
     * ```
     * @param {Object} `parent`
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
     * @api public
     */
    utils.shiftNode = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        if (typeof node.shift === 'function') {
            return node.shift();
        }
        return node.nodes && node.nodes.shift();
    };
    /**
     * Remove the specified `node` from `parent.nodes`.
     *
     * ```js
     * var parent = new Node({type: 'abc'});
     * var foo = new Node({type: 'foo'});
     * utils.pushNode(parent, foo);
     * utils.pushNode(parent, new Node({type: 'bar'}));
     * utils.pushNode(parent, new Node({type: 'baz'}));
     * console.log(parent.nodes.length); //=> 3
     * utils.removeNode(parent, foo);
     * console.log(parent.nodes.length); //=> 2
     * ```
     * @param {Object} `parent`
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
     * @api public
     */
    utils.removeNode = function (parent, node) {
        assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        if (!parent.nodes) {
            return null;
        }
        if (typeof parent.remove === 'function') {
            return parent.remove(node);
        }
        var idx = parent.nodes.indexOf(node);
        if (idx !== -1) {
            return parent.nodes.splice(idx, 1);
        }
    };
    /**
     * Returns true if `node.type` matches the given `type`. Throws a
     * `TypeError` if `node` is not an instance of `Node`.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var node = new Node({type: 'foo'});
     * console.log(utils.isType(node, 'foo')); // false
     * console.log(utils.isType(node, 'bar')); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    utils.isType = function (node, type) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        switch (kindOf$2(type)) {
            case 'array':
                var types = type.slice();
                for (var i = 0; i < types.length; i++) {
                    if (utils.isType(node, types[i])) {
                        return true;
                    }
                }
                return false;
            case 'string':
                return node.type === type;
            case 'regexp':
                return type.test(node.type);
            default: {
                throw new TypeError('expected "type" to be an array, string or regexp');
            }
        }
    };
    /**
     * Returns true if the given `node` has the given `type` in `node.nodes`.
     * Throws a `TypeError` if `node` is not an instance of `Node`.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var node = new Node({
     *   type: 'foo',
     *   nodes: [
     *     new Node({type: 'bar'}),
     *     new Node({type: 'baz'})
     *   ]
     * });
     * console.log(utils.hasType(node, 'xyz')); // false
     * console.log(utils.hasType(node, 'baz')); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    utils.hasType = function (node, type) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        if (!Array.isArray(node.nodes))
            return false;
        for (var i = 0; i < node.nodes.length; i++) {
            if (utils.isType(node.nodes[i], type)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns the first node from `node.nodes` of the given `type`
     *
     * ```js
     * var node = new Node({
     *   type: 'foo',
     *   nodes: [
     *     new Node({type: 'text', val: 'abc'}),
     *     new Node({type: 'text', val: 'xyz'})
     *   ]
     * });
     *
     * var textNode = utils.firstOfType(node.nodes, 'text');
     * console.log(textNode.val);
     * //=> 'abc'
     * ```
     * @param {Array} `nodes`
     * @param {String} `type`
     * @return {Object|undefined} Returns the first matching node or undefined.
     * @api public
     */
    utils.firstOfType = function (nodes, type) {
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (utils.isType(node, type)) {
                return node;
            }
        }
    };
    /**
     * Returns the node at the specified index, or the first node of the
     * given `type` from `node.nodes`.
     *
     * ```js
     * var node = new Node({
     *   type: 'foo',
     *   nodes: [
     *     new Node({type: 'text', val: 'abc'}),
     *     new Node({type: 'text', val: 'xyz'})
     *   ]
     * });
     *
     * var nodeOne = utils.findNode(node.nodes, 'text');
     * console.log(nodeOne.val);
     * //=> 'abc'
     *
     * var nodeTwo = utils.findNode(node.nodes, 1);
     * console.log(nodeTwo.val);
     * //=> 'xyz'
     * ```
     *
     * @param {Array} `nodes`
     * @param {String|Number} `type` Node type or index.
     * @return {Object} Returns a node or undefined.
     * @api public
     */
    utils.findNode = function (nodes, type) {
        if (!Array.isArray(nodes)) {
            return null;
        }
        if (typeof type === 'number') {
            return nodes[type];
        }
        return utils.firstOfType(nodes, type);
    };
    /**
     * Returns true if the given node is an "*.open" node.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var brace = new Node({type: 'brace'});
     * var open = new Node({type: 'brace.open'});
     * var close = new Node({type: 'brace.close'});
     *
     * console.log(utils.isOpen(brace)); // false
     * console.log(utils.isOpen(open)); // true
     * console.log(utils.isOpen(close)); // false
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Boolean}
     * @api public
     */
    utils.isOpen = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        return node.type.slice(-5) === '.open';
    };
    /**
     * Returns true if the given node is a "*.close" node.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var brace = new Node({type: 'brace'});
     * var open = new Node({type: 'brace.open'});
     * var close = new Node({type: 'brace.close'});
     *
     * console.log(utils.isClose(brace)); // false
     * console.log(utils.isClose(open)); // false
     * console.log(utils.isClose(close)); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Boolean}
     * @api public
     */
    utils.isClose = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        return node.type.slice(-6) === '.close';
    };
    /**
     * Returns true if `node.nodes` **has** an `.open` node
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var brace = new Node({
     *   type: 'brace',
     *   nodes: []
     * });
     *
     * var open = new Node({type: 'brace.open'});
     * console.log(utils.hasOpen(brace)); // false
     *
     * brace.pushNode(open);
     * console.log(utils.hasOpen(brace)); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Boolean}
     * @api public
     */
    utils.hasOpen = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        var first = node.first || node.nodes ? node.nodes[0] : null;
        if (utils.isNode(first)) {
            return first.type === node.type + '.open';
        }
        return false;
    };
    /**
     * Returns true if `node.nodes` **has** a `.close` node
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var brace = new Node({
     *   type: 'brace',
     *   nodes: []
     * });
     *
     * var close = new Node({type: 'brace.close'});
     * console.log(utils.hasClose(brace)); // false
     *
     * brace.pushNode(close);
     * console.log(utils.hasClose(brace)); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Boolean}
     * @api public
     */
    utils.hasClose = function (node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
        if (utils.isNode(last)) {
            return last.type === node.type + '.close';
        }
        return false;
    };
    /**
     * Returns true if `node.nodes` has both `.open` and `.close` nodes
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var brace = new Node({
     *   type: 'brace',
     *   nodes: []
     * });
     *
     * var open = new Node({type: 'brace.open'});
     * var close = new Node({type: 'brace.close'});
     * console.log(utils.hasOpen(brace)); // false
     * console.log(utils.hasClose(brace)); // false
     *
     * brace.pushNode(open);
     * brace.pushNode(close);
     * console.log(utils.hasOpen(brace)); // true
     * console.log(utils.hasClose(brace)); // true
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Boolean}
     * @api public
     */
    utils.hasOpenAndClose = function (node) {
        return utils.hasOpen(node) && utils.hasClose(node);
    };
    /**
     * Push the given `node` onto the `state.inside` array for the
     * given type. This array is used as a specialized "stack" for
     * only the given `node.type`.
     *
     * ```js
     * var state = { inside: {}};
     * var node = new Node({type: 'brace'});
     * utils.addType(state, node);
     * console.log(state.inside);
     * //=> { brace: [{type: 'brace'}] }
     * ```
     * @param {Object} `state` The `compiler.state` object or custom state object.
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Array} Returns the `state.inside` stack for the given type.
     * @api public
     */
    utils.addType = function (state, node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isObject(state), 'expected state to be an object');
        var type = node.parent
            ? node.parent.type
            : node.type.replace(/\.open$/, '');
        if (!state.hasOwnProperty('inside')) {
            state.inside = {};
        }
        if (!state.inside.hasOwnProperty(type)) {
            state.inside[type] = [];
        }
        var arr = state.inside[type];
        arr.push(node);
        return arr;
    };
    /**
     * Remove the given `node` from the `state.inside` array for the
     * given type. This array is used as a specialized "stack" for
     * only the given `node.type`.
     *
     * ```js
     * var state = { inside: {}};
     * var node = new Node({type: 'brace'});
     * utils.addType(state, node);
     * console.log(state.inside);
     * //=> { brace: [{type: 'brace'}] }
     * utils.removeType(state, node);
     * //=> { brace: [] }
     * ```
     * @param {Object} `state` The `compiler.state` object or custom state object.
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @return {Array} Returns the `state.inside` stack for the given type.
     * @api public
     */
    utils.removeType = function (state, node) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isObject(state), 'expected state to be an object');
        var type = node.parent
            ? node.parent.type
            : node.type.replace(/\.close$/, '');
        if (state.inside.hasOwnProperty(type)) {
            return state.inside[type].pop();
        }
    };
    /**
     * Returns true if `node.val` is an empty string, or `node.nodes` does
     * not contain any non-empty text nodes.
     *
     * ```js
     * var node = new Node({type: 'text'});
     * utils.isEmpty(node); //=> true
     * node.val = 'foo';
     * utils.isEmpty(node); //=> false
     * ```
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {Function} `fn`
     * @return {Boolean}
     * @api public
     */
    utils.isEmpty = function (node, fn) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        if (!Array.isArray(node.nodes)) {
            if (node.type !== 'text') {
                return true;
            }
            if (typeof fn === 'function') {
                return fn(node, node.parent);
            }
            return !utils.trim(node.val);
        }
        for (var i = 0; i < node.nodes.length; i++) {
            var child = node.nodes[i];
            if (utils.isOpen(child) || utils.isClose(child)) {
                continue;
            }
            if (!utils.isEmpty(child, fn)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns true if the `state.inside` stack for the given type exists
     * and has one or more nodes on it.
     *
     * ```js
     * var state = { inside: {}};
     * var node = new Node({type: 'brace'});
     * console.log(utils.isInsideType(state, 'brace')); //=> false
     * utils.addType(state, node);
     * console.log(utils.isInsideType(state, 'brace')); //=> true
     * utils.removeType(state, node);
     * console.log(utils.isInsideType(state, 'brace')); //=> false
     * ```
     * @param {Object} `state`
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    utils.isInsideType = function (state, type) {
        assert(isObject(state), 'expected state to be an object');
        assert(isString(type), 'expected type to be a string');
        if (!state.hasOwnProperty('inside')) {
            return false;
        }
        if (!state.inside.hasOwnProperty(type)) {
            return false;
        }
        return state.inside[type].length > 0;
    };
    /**
     * Returns true if `node` is either a child or grand-child of the given `type`,
     * or `state.inside[type]` is a non-empty array.
     *
     * ```js
     * var state = { inside: {}};
     * var node = new Node({type: 'brace'});
     * var open = new Node({type: 'brace.open'});
     * console.log(utils.isInside(state, open, 'brace')); //=> false
     * utils.pushNode(node, open);
     * console.log(utils.isInside(state, open, 'brace')); //=> true
     * ```
     * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
     * @param {Object} `node` Instance of [snapdragon-node][]
     * @param {String} `type` The `node.type` to check for.
     * @return {Boolean}
     * @api public
     */
    utils.isInside = function (state, node, type) {
        assert(utils.isNode(node), 'expected node to be an instance of Node');
        assert(isObject(state), 'expected state to be an object');
        if (Array.isArray(type)) {
            for (var i = 0; i < type.length; i++) {
                if (utils.isInside(state, node, type[i])) {
                    return true;
                }
            }
            return false;
        }
        var parent = node.parent;
        if (typeof type === 'string') {
            return (parent && parent.type === type) || utils.isInsideType(state, type);
        }
        if (kindOf$2(type) === 'regexp') {
            if (parent && parent.type && type.test(parent.type)) {
                return true;
            }
            var keys = Object.keys(state.inside);
            var len = keys.length;
            var idx = -1;
            while (++idx < len) {
                var key = keys[idx];
                var val = state.inside[key];
                if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Get the last `n` element from the given `array`. Used for getting
     * a node from `node.nodes.`
     *
     * @param {Array} `array`
     * @param {Number} `n`
     * @return {undefined}
     * @api public
     */
    utils.last = function (arr, n) {
        return arr[arr.length - (n || 1)];
    };
    /**
     * Cast the given `val` to an array.
     *
     * ```js
     * console.log(utils.arrayify(''));
     * //=> []
     * console.log(utils.arrayify('foo'));
     * //=> ['foo']
     * console.log(utils.arrayify(['foo']));
     * //=> ['foo']
     * ```
     * @param {any} `val`
     * @return {Array}
     * @api public
     */
    utils.arrayify = function (val) {
        if (typeof val === 'string' && val !== '') {
            return [val];
        }
        if (!Array.isArray(val)) {
            return [];
        }
        return val;
    };
    /**
     * Convert the given `val` to a string by joining with `,`. Useful
     * for creating a cheerio/CSS/DOM-style selector from a list of strings.
     *
     * @param {any} `val`
     * @return {Array}
     * @api public
     */
    utils.stringify = function (val) {
        return utils.arrayify(val).join(',');
    };
    /**
     * Ensure that the given value is a string and call `.trim()` on it,
     * or return an empty string.
     *
     * @param {String} `str`
     * @return {String}
     * @api public
     */
    utils.trim = function (str) {
        return typeof str === 'string' ? str.trim() : '';
    };
    /**
     * Return true if val is an object
     */
    function isObject(val) {
        return kindOf$2(val) === 'object';
    }
    /**
     * Return true if val is a string
     */
    function isString(val) {
        return typeof val === 'string';
    }
    /**
     * Return true if val is a function
     */
    function isFunction(val) {
        return typeof val === 'function';
    }
    /**
     * Return true if val is an array
     */
    function isArray(val) {
        return Array.isArray(val);
    }
    /**
     * Shim to ensure the `.append` methods work with any version of snapdragon
     */
    function append(compiler, val, node) {
        if (typeof compiler.append !== 'function') {
            return compiler.emit(val, node);
        }
        return compiler.append(val, node);
    }
    /**
     * Simplified assertion. Throws an error is `val` is falsey.
     */
    function assert(val, message) {
        if (!val)
            throw new Error(message);
    }
});

var snapdragonNode = createCommonjsModule(function (module, exports) {
    var ownNames;
    /**
     * Create a new AST `Node` with the given `val` and `type`.
     *
     * ```js
     * var node = new Node('*', 'Star');
     * var node = new Node({type: 'star', val: '*'});
     * ```
     * @name Node
     * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
     * @param {String} `type` The node type to use when `val` is a string.
     * @return {Object} node instance
     * @api public
     */
    function Node(val, type, parent) {
        if (typeof type !== 'string') {
            parent = type;
            type = null;
        }
        defineProperty$1(this, 'parent', parent);
        defineProperty$1(this, 'isNode', true);
        defineProperty$1(this, 'expect', null);
        if (typeof type !== 'string' && isobject(val)) {
            lazyKeys();
            var keys = Object.keys(val);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (ownNames.indexOf(key) === -1) {
                    this[key] = val[key];
                }
            }
        }
        else {
            this.type = type;
            this.val = val;
        }
    }
    /**
     * Returns true if the given value is a node.
     *
     * ```js
     * var Node = require('snapdragon-node');
     * var node = new Node({type: 'foo'});
     * console.log(Node.isNode(node)); //=> true
     * console.log(Node.isNode({})); //=> false
     * ```
     * @param {Object} `node`
     * @returns {Boolean}
     * @api public
     */
    Node.isNode = function (node) {
        return snapdragonUtil.isNode(node);
    };
    /**
     * Define a non-enumberable property on the node instance.
     * Useful for adding properties that shouldn't be extended
     * or visible during debugging.
     *
     * ```js
     * var node = new Node();
     * node.define('foo', 'something non-enumerable');
     * ```
     * @param {String} `name`
     * @param {any} `val`
     * @return {Object} returns the node instance
     * @api public
     */
    Node.prototype.define = function (name, val) {
        defineProperty$1(this, name, val);
        return this;
    };
    /**
     * Returns true if `node.val` is an empty string, or `node.nodes` does
     * not contain any non-empty text nodes.
     *
     * ```js
     * var node = new Node({type: 'text'});
     * node.isEmpty(); //=> true
     * node.val = 'foo';
     * node.isEmpty(); //=> false
     * ```
     * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
     * @return {Boolean}
     * @api public
     */
    Node.prototype.isEmpty = function (fn) {
        return snapdragonUtil.isEmpty(this, fn);
    };
    /**
     * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
     * set `foo` as `bar.parent`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * foo.push(bar);
     * ```
     * @param {Object} `node`
     * @return {Number} Returns the length of `node.nodes`
     * @api public
     */
    Node.prototype.push = function (node) {
        assert(Node.isNode(node), 'expected node to be an instance of Node');
        defineProperty$1(node, 'parent', this);
        this.nodes = this.nodes || [];
        return this.nodes.push(node);
    };
    /**
     * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
     * set `foo` as `bar.parent`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * foo.unshift(bar);
     * ```
     * @param {Object} `node`
     * @return {Number} Returns the length of `node.nodes`
     * @api public
     */
    Node.prototype.unshift = function (node) {
        assert(Node.isNode(node), 'expected node to be an instance of Node');
        defineProperty$1(node, 'parent', this);
        this.nodes = this.nodes || [];
        return this.nodes.unshift(node);
    };
    /**
     * Pop a node from `node.nodes`.
     *
     * ```js
     * var node = new Node({type: 'foo'});
     * node.push(new Node({type: 'a'}));
     * node.push(new Node({type: 'b'}));
     * node.push(new Node({type: 'c'}));
     * node.push(new Node({type: 'd'}));
     * console.log(node.nodes.length);
     * //=> 4
     * node.pop();
     * console.log(node.nodes.length);
     * //=> 3
     * ```
     * @return {Number} Returns the popped `node`
     * @api public
     */
    Node.prototype.pop = function () {
        return this.nodes && this.nodes.pop();
    };
    /**
     * Shift a node from `node.nodes`.
     *
     * ```js
     * var node = new Node({type: 'foo'});
     * node.push(new Node({type: 'a'}));
     * node.push(new Node({type: 'b'}));
     * node.push(new Node({type: 'c'}));
     * node.push(new Node({type: 'd'}));
     * console.log(node.nodes.length);
     * //=> 4
     * node.shift();
     * console.log(node.nodes.length);
     * //=> 3
     * ```
     * @return {Object} Returns the shifted `node`
     * @api public
     */
    Node.prototype.shift = function () {
        return this.nodes && this.nodes.shift();
    };
    /**
     * Remove `node` from `node.nodes`.
     *
     * ```js
     * node.remove(childNode);
     * ```
     * @param {Object} `node`
     * @return {Object} Returns the removed node.
     * @api public
     */
    Node.prototype.remove = function (node) {
        assert(Node.isNode(node), 'expected node to be an instance of Node');
        this.nodes = this.nodes || [];
        var idx = node.index;
        if (idx !== -1) {
            node.index = -1;
            return this.nodes.splice(idx, 1);
        }
        return null;
    };
    /**
     * Get the first child node from `node.nodes` that matches the given `type`.
     * If `type` is a number, the child node at that index is returned.
     *
     * ```js
     * var child = node.find(1); //<= index of the node to get
     * var child = node.find('foo'); //<= node.type of a child node
     * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
     * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
     * ```
     * @param {String} `type`
     * @return {Object} Returns a child node or undefined.
     * @api public
     */
    Node.prototype.find = function (type) {
        return snapdragonUtil.findNode(this.nodes, type);
    };
    /**
     * Return true if the node is the given `type`.
     *
     * ```js
     * var node = new Node({type: 'bar'});
     * cosole.log(node.isType('foo'));          // false
     * cosole.log(node.isType(/^(foo|bar)$/));  // true
     * cosole.log(node.isType(['foo', 'bar'])); // true
     * ```
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    Node.prototype.isType = function (type) {
        return snapdragonUtil.isType(this, type);
    };
    /**
     * Return true if the `node.nodes` has the given `type`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * foo.push(bar);
     *
     * cosole.log(foo.hasType('qux'));          // false
     * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
     * cosole.log(foo.hasType(['qux', 'bar'])); // true
     * ```
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    Node.prototype.hasType = function (type) {
        return snapdragonUtil.hasType(this, type);
    };
    /**
     * Get the siblings array, or `null` if it doesn't exist.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * foo.push(bar);
     * foo.push(baz);
     *
     * console.log(bar.siblings.length) // 2
     * console.log(baz.siblings.length) // 2
     * ```
     * @return {Array}
     * @api public
     */
    Object.defineProperty(Node.prototype, 'siblings', {
        set: function () {
            throw new Error('node.siblings is a getter and cannot be defined');
        },
        get: function () {
            return this.parent ? this.parent.nodes : null;
        }
    });
    /**
     * Get the node's current index from `node.parent.nodes`.
     * This should always be correct, even when the parent adds nodes.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * var qux = new Node({type: 'qux'});
     * foo.push(bar);
     * foo.push(baz);
     * foo.unshift(qux);
     *
     * console.log(bar.index) // 1
     * console.log(baz.index) // 2
     * console.log(qux.index) // 0
     * ```
     * @return {Number}
     * @api public
     */
    Object.defineProperty(Node.prototype, 'index', {
        set: function (index) {
            defineProperty$1(this, 'idx', index);
        },
        get: function () {
            if (!Array.isArray(this.siblings)) {
                return -1;
            }
            var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
            if (tok !== this) {
                this.idx = this.siblings.indexOf(this);
            }
            return this.idx;
        }
    });
    /**
     * Get the previous node from the siblings array or `null`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * foo.push(bar);
     * foo.push(baz);
     *
     * console.log(baz.prev.type) // 'bar'
     * ```
     * @return {Object}
     * @api public
     */
    Object.defineProperty(Node.prototype, 'prev', {
        set: function () {
            throw new Error('node.prev is a getter and cannot be defined');
        },
        get: function () {
            if (Array.isArray(this.siblings)) {
                return this.siblings[this.index - 1] || this.parent.prev;
            }
            return null;
        }
    });
    /**
     * Get the siblings array, or `null` if it doesn't exist.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * foo.push(bar);
     * foo.push(baz);
     *
     * console.log(bar.siblings.length) // 2
     * console.log(baz.siblings.length) // 2
     * ```
     * @return {Object}
     * @api public
     */
    Object.defineProperty(Node.prototype, 'next', {
        set: function () {
            throw new Error('node.next is a getter and cannot be defined');
        },
        get: function () {
            if (Array.isArray(this.siblings)) {
                return this.siblings[this.index + 1] || this.parent.next;
            }
            return null;
        }
    });
    /**
     * Get the first node from `node.nodes`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * var qux = new Node({type: 'qux'});
     * foo.push(bar);
     * foo.push(baz);
     * foo.push(qux);
     *
     * console.log(foo.first.type) // 'bar'
     * ```
     * @return {Object} The first node, or undefiend
     * @api public
     */
    Object.defineProperty(Node.prototype, 'first', {
        get: function () {
            return this.nodes ? this.nodes[0] : null;
        }
    });
    /**
     * Get the last node from `node.nodes`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * var qux = new Node({type: 'qux'});
     * foo.push(bar);
     * foo.push(baz);
     * foo.push(qux);
     *
     * console.log(foo.last.type) // 'qux'
     * ```
     * @return {Object} The last node, or undefiend
     * @api public
     */
    Object.defineProperty(Node.prototype, 'last', {
        get: function () {
            return this.nodes ? snapdragonUtil.last(this.nodes) : null;
        }
    });
    /**
     * Get the last node from `node.nodes`.
     *
     * ```js
     * var foo = new Node({type: 'foo'});
     * var bar = new Node({type: 'bar'});
     * var baz = new Node({type: 'baz'});
     * var qux = new Node({type: 'qux'});
     * foo.push(bar);
     * foo.push(baz);
     * foo.push(qux);
     *
     * console.log(foo.last.type) // 'qux'
     * ```
     * @return {Object} The last node, or undefiend
     * @api public
     */
    Object.defineProperty(Node.prototype, 'scope', {
        get: function () {
            if (this.isScope !== true) {
                return this.parent ? this.parent.scope : this;
            }
            return this;
        }
    });
    /**
     * Get own property names from Node prototype, but only the
     * first time `Node` is instantiated
     */
    function lazyKeys() {
        if (!ownNames) {
            ownNames = Object.getOwnPropertyNames(Node.prototype);
        }
    }
    /**
     * Simplified assertion. Throws an error is `val` is falsey.
     */
    function assert(val, message) {
        if (!val)
            throw new Error(message);
    }
    /**
     * Expose `Node`
     */
    exports = module.exports = Node;
});

/**
 * Braces parsers
 */
var parsers = function (braces, options) {
    braces.parser
        .set('bos', function () {
        if (!this.parsed) {
            this.ast = this.nodes[0] = new snapdragonNode(this.ast);
        }
    })
        /**
         * Character parsers
         */
        .set('escape', function () {
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|\$\{)/);
        if (!m)
            return;
        var prev = this.prev();
        var last = utils_1.last(prev.nodes);
        var node = pos(new snapdragonNode({
            type: 'text',
            multiplier: 1,
            val: m[0]
        }));
        if (node.val === '\\\\') {
            return node;
        }
        if (node.val === '${') {
            var str = this.input;
            var idx = -1;
            var ch;
            while ((ch = str[++idx])) {
                this.consume(1);
                node.val += ch;
                if (ch === '\\') {
                    node.val += str[++idx];
                    continue;
                }
                if (ch === '}') {
                    break;
                }
            }
        }
        if (this.options.unescape !== false) {
            node.val = node.val.replace(/\\([{}])/g, '$1');
        }
        if (last.val === '"' && this.input.charAt(0) === '"') {
            last.val = node.val;
            this.consume(1);
            return;
        }
        return concatNodes.call(this, pos, node, prev, options);
    })
        /**
         * Brackets: "[...]" (basic, this is overridden by
         * other parsers in more advanced implementations)
         */
        .set('bracket', function () {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
            return;
        var prev = this.prev();
        var val = m[0];
        var negated = m[1] ? '^' : '';
        var inner = m[2] || '';
        var close = m[3] || '';
        if (isInside && prev.type === 'brace') {
            prev.text = prev.text || '';
            prev.text += val;
        }
        var esc = this.input.slice(0, 2);
        if (inner === '' && esc === '\\]') {
            inner += esc;
            this.consume(2);
            var str = this.input;
            var idx = -1;
            var ch;
            while ((ch = str[++idx])) {
                this.consume(1);
                if (ch === ']') {
                    close = ch;
                    break;
                }
                inner += ch;
            }
        }
        return pos(new snapdragonNode({
            type: 'bracket',
            val: val,
            escaped: close !== ']',
            negated: negated,
            inner: inner,
            close: close
        }));
    })
        /**
         * Empty braces (we capture these early to
         * speed up processing in the compiler)
         */
        .set('multiplier', function () {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^\{((?:,|\{,+\})+)\}/);
        if (!m)
            return;
        this.multiplier = true;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === 'brace') {
            prev.text = prev.text || '';
            prev.text += val;
        }
        var node = pos(new snapdragonNode({
            type: 'text',
            multiplier: 1,
            match: m,
            val: val
        }));
        return concatNodes.call(this, pos, node, prev, options);
    })
        /**
         * Open
         */
        .set('brace.open', function () {
        var pos = this.position();
        var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
        if (!m)
            return;
        var prev = this.prev();
        var last = utils_1.last(prev.nodes);
        // if the last parsed character was an extglob character
        // we need to _not optimize_ the brace pattern because
        // it might be mistaken for an extglob by a downstream parser
        if (last && last.val && isExtglobChar(last.val.slice(-1))) {
            last.optimize = false;
        }
        var open = pos(new snapdragonNode({
            type: 'brace.open',
            val: m[0]
        }));
        var node = pos(new snapdragonNode({
            type: 'brace',
            nodes: []
        }));
        node.push(open);
        prev.push(node);
        this.push('brace', node);
    })
        /**
         * Close
         */
        .set('brace.close', function () {
        var pos = this.position();
        var m = this.match(/^\}/);
        if (!m || !m[0])
            return;
        var brace = this.pop('brace');
        var node = pos(new snapdragonNode({
            type: 'brace.close',
            val: m[0]
        }));
        if (!this.isType(brace, 'brace')) {
            if (this.options.strict) {
                throw new Error('missing opening "{"');
            }
            node.type = 'text';
            node.multiplier = 0;
            node.escaped = true;
            return node;
        }
        var prev = this.prev();
        var last = utils_1.last(prev.nodes);
        if (last.text) {
            var lastNode = utils_1.last(last.nodes);
            if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) {
                var open = last.nodes[0];
                var text = last.nodes[1];
                if (open.type === 'brace.open' && text && text.type === 'text') {
                    text.optimize = false;
                }
            }
        }
        if (brace.nodes.length > 2) {
            var first = brace.nodes[1];
            if (first.type === 'text' && first.val === ',') {
                brace.nodes.splice(1, 1);
                brace.nodes.push(first);
            }
        }
        brace.push(node);
    })
        /**
         * Capture boundary characters
         */
        .set('boundary', function () {
        var pos = this.position();
        var m = this.match(/^[$^](?!\{)/);
        if (!m)
            return;
        return pos(new snapdragonNode({
            type: 'text',
            val: m[0]
        }));
    })
        /**
         * One or zero, non-comma characters wrapped in braces
         */
        .set('nobrace', function () {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^\{[^,]?\}/);
        if (!m)
            return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === 'brace') {
            prev.text = prev.text || '';
            prev.text += val;
        }
        return pos(new snapdragonNode({
            type: 'text',
            multiplier: 0,
            val: val
        }));
    })
        /**
         * Text
         */
        .set('text', function () {
        var isInside = this.isInside('brace');
        var pos = this.position();
        var m = this.match(/^((?!\\)[^${}[\]])+/);
        if (!m)
            return;
        var prev = this.prev();
        var val = m[0];
        if (isInside && prev.type === 'brace') {
            prev.text = prev.text || '';
            prev.text += val;
        }
        var node = pos(new snapdragonNode({
            type: 'text',
            multiplier: 1,
            val: val
        }));
        return concatNodes.call(this, pos, node, prev, options);
    });
};
/**
 * Returns true if the character is an extglob character.
 */
function isExtglobChar(ch) {
    return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
}
/**
 * Combine text nodes, and calculate empty sets (`{,,}`)
 * @param {Function} `pos` Function to calculate node position
 * @param {Object} `node` AST node
 * @return {Object}
 */
function concatNodes(pos, node, parent, options) {
    node.orig = node.val;
    var prev = this.prev();
    var last = utils_1.last(prev.nodes);
    var isEscaped = false;
    if (node.val.length > 1) {
        var a = node.val.charAt(0);
        var b = node.val.slice(-1);
        isEscaped = (a === '"' && b === '"')
            || (a === "'" && b === "'")
            || (a === '`' && b === '`');
    }
    if (isEscaped && options.unescape !== false) {
        node.val = node.val.slice(1, node.val.length - 1);
        node.escaped = true;
    }
    if (node.match) {
        var match = node.match[1];
        if (!match || match.indexOf('}') === -1) {
            match = node.match[0];
        }
        // replace each set with a single ","
        var val = match.replace(/\{/g, ',').replace(/\}/g, '');
        node.multiplier *= val.length;
        node.val = '';
    }
    var simpleText = last.type === 'text'
        && last.multiplier === 1
        && node.multiplier === 1
        && node.val;
    if (simpleText) {
        last.val += node.val;
        return;
    }
    prev.push(node);
}

// accessor descriptor properties
var accessor$2 = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
};
function isAccessorDescriptor$2(obj, prop) {
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (has$3(obj, 'value') || has$3(obj, 'writable')) {
        return false;
    }
    if (!has$3(obj, 'get') || typeof obj.get !== 'function') {
        return false;
    }
    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has$3(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
        return false;
    }
    for (var key in obj) {
        if (!accessor$2.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === accessor$2[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
function has$3(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
/**
 * Expose `isAccessorDescriptor`
 */
var isAccessorDescriptor_1$2 = isAccessorDescriptor$2;

var isDataDescriptor$2 = function isDataDescriptor(obj, prop) {
    // data descriptor properties
    var data = {
        configurable: 'boolean',
        enumerable: 'boolean',
        writable: 'boolean'
    };
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (!('value' in obj) && !('writable' in obj)) {
        return false;
    }
    for (var key in obj) {
        if (key === 'value')
            continue;
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === data[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
};

var isDescriptor$2 = function isDescriptor(obj, key) {
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if ('get' in obj) {
        return isAccessorDescriptor_1$2(obj, key);
    }
    return isDataDescriptor$2(obj, key);
};

var defineProperty$2 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$2(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

var componentEmitter = createCommonjsModule(function (module) {
    /**
     * Expose `Emitter`.
     */
    {
        module.exports = Emitter;
    }
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */
    function Emitter(obj) {
        if (obj)
            return mixin(obj);
    }
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    function mixin(obj) {
        for (var key in Emitter.prototype) {
            obj[key] = Emitter.prototype[key];
        }
        return obj;
    }
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    Emitter.prototype.on =
        Emitter.prototype.addEventListener = function (event, fn) {
            this._callbacks = this._callbacks || {};
            (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
                .push(fn);
            return this;
        };
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    Emitter.prototype.once = function (event, fn) {
        function on() {
            this.off(event, on);
            fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
    };
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    Emitter.prototype.off =
        Emitter.prototype.removeListener =
            Emitter.prototype.removeAllListeners =
                Emitter.prototype.removeEventListener = function (event, fn) {
                    this._callbacks = this._callbacks || {};
                    // all
                    if (0 == arguments.length) {
                        this._callbacks = {};
                        return this;
                    }
                    // specific event
                    var callbacks = this._callbacks['$' + event];
                    if (!callbacks)
                        return this;
                    // remove all handlers
                    if (1 == arguments.length) {
                        delete this._callbacks['$' + event];
                        return this;
                    }
                    // remove specific handler
                    var cb;
                    for (var i = 0; i < callbacks.length; i++) {
                        cb = callbacks[i];
                        if (cb === fn || cb.fn === fn) {
                            callbacks.splice(i, 1);
                            break;
                        }
                    }
                    return this;
                };
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */
    Emitter.prototype.emit = function (event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks = this._callbacks['$' + event];
        if (callbacks) {
            callbacks = callbacks.slice(0);
            for (var i = 0, len = callbacks.length; i < len; ++i) {
                callbacks[i].apply(this, args);
            }
        }
        return this;
    };
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */
    Emitter.prototype.listeners = function (event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks['$' + event] || [];
    };
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */
    Emitter.prototype.hasListeners = function (event) {
        return !!this.listeners(event).length;
    };
});

var objectVisit = function visit(thisArg, method, target, val) {
    if (!isobject(thisArg) && typeof thisArg !== 'function') {
        throw new Error('object-visit expects `thisArg` to be an object.');
    }
    if (typeof method !== 'string') {
        throw new Error('object-visit expects `method` name to be a string');
    }
    if (typeof thisArg[method] !== 'function') {
        return thisArg;
    }
    var args = [].slice.call(arguments, 3);
    target = target || {};
    for (var key in target) {
        var arr = [key, target[key]].concat(args);
        thisArg[method].apply(thisArg, arr);
    }
    return thisArg;
};

/**
 * Map `visit` over an array of objects.
 *
 * @param  {Object} `collection` The context in which to invoke `method`
 * @param  {String} `method` Name of the method to call on `collection`
 * @param  {Object} `arr` Array of objects.
 */
var mapVisit = function mapVisit(collection, method, val) {
    if (isObject$2(val)) {
        return objectVisit.apply(null, arguments);
    }
    if (!Array.isArray(val)) {
        throw new TypeError('expected an array: ' + util$2.inspect(val));
    }
    var args = [].slice.call(arguments, 3);
    for (var i = 0; i < val.length; i++) {
        var ele = val[i];
        if (isObject$2(ele)) {
            objectVisit.apply(null, [collection, method, ele].concat(args));
        }
        else {
            collection[method].apply(collection, [ele].concat(args));
        }
    }
};
function isObject$2(val) {
    return val && (typeof val === 'function' || (!Array.isArray(val) && typeof val === 'object'));
}

var collectionVisit = function (collection, method, val) {
    var result;
    if (typeof val === 'string' && (method in collection)) {
        var args = [].slice.call(arguments, 2);
        result = collection[method].apply(collection, args);
    }
    else if (Array.isArray(val)) {
        result = mapVisit.apply(null, arguments);
    }
    else {
        result = objectVisit.apply(null, arguments);
    }
    if (typeof result !== 'undefined') {
        return result;
    }
    return collection;
};

var toString$4 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$3 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$4.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

var toObjectPath = function toPath(args) {
    if (kindOf$3(args) !== 'arguments') {
        args = arguments;
    }
    return filter(args).join('.');
};
function filter(arr) {
    var len = arr.length;
    var idx = -1;
    var res = [];
    while (++idx < len) {
        var ele = arr[idx];
        if (kindOf$3(ele) === 'arguments' || Array.isArray(ele)) {
            res.push.apply(res, filter(ele));
        }
        else if (typeof ele === 'string') {
            res.push(ele);
        }
    }
    return res;
}

var arrUnion = function union(init) {
    if (!Array.isArray(init)) {
        throw new TypeError('arr-union expects the first argument to be an array.');
    }
    var len = arguments.length;
    var i = 0;
    while (++i < len) {
        var arg = arguments[i];
        if (!arg)
            continue;
        if (!Array.isArray(arg)) {
            arg = [arg];
        }
        for (var j = 0; j < arg.length; j++) {
            var ele = arg[j];
            if (init.indexOf(ele) >= 0) {
                continue;
            }
            init.push(ele);
        }
    }
    return init;
};

/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var getValue = function (obj, prop, a, b, c) {
    if (!isObject$3(obj) || !prop) {
        return obj;
    }
    prop = toString$5(prop);
    // allowing for multiple properties to be passed as
    // a string or array, but much faster (3-4x) than doing
    // `[].slice.call(arguments)`
    if (a)
        prop += '.' + toString$5(a);
    if (b)
        prop += '.' + toString$5(b);
    if (c)
        prop += '.' + toString$5(c);
    if (prop in obj) {
        return obj[prop];
    }
    var segs = prop.split('.');
    var len = segs.length;
    var i = -1;
    while (obj && (++i < len)) {
        var key = segs[i];
        while (key[key.length - 1] === '\\') {
            key = key.slice(0, -1) + '.' + segs[++i];
        }
        obj = obj[key];
    }
    return obj;
};
function isObject$3(val) {
    return val !== null && (typeof val === 'object' || typeof val === 'function');
}
function toString$5(val) {
    if (!val)
        return '';
    if (Array.isArray(val)) {
        return val.join('.');
    }
    return val;
}

var extendShallow$3 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$3(o, obj);
        }
    }
    return o;
};
function assign$3(a, b) {
    for (var key in b) {
        if (hasOwn$3(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$3(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

var setValue = function (obj, path, val) {
    if (!isExtendable$1(obj)) {
        return obj;
    }
    if (Array.isArray(path)) {
        path = toObjectPath(path);
    }
    if (typeof path !== 'string') {
        return obj;
    }
    var segs = path.split('.');
    var len = segs.length, i = -1;
    var res = obj;
    var last;
    while (++i < len) {
        var key = segs[i];
        while (key[key.length - 1] === '\\') {
            key = key.slice(0, -1) + '.' + segs[++i];
        }
        if (i === len - 1) {
            last = key;
            break;
        }
        if (!isExtendable$1(obj[key])) {
            obj[key] = {};
        }
        obj = obj[key];
    }
    if (obj.hasOwnProperty(last) && isExtendable$1(obj[last])) {
        if (isPlainObject(val)) {
            extendShallow$3(obj[last], val);
        }
        else {
            obj[last] = val;
        }
    }
    else {
        obj[last] = val;
    }
    return res;
};

var unionValue = function unionValue(obj, prop, value) {
    if (!isExtendable$1(obj)) {
        throw new TypeError('union-value expects the first argument to be an object.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('union-value expects `prop` to be a string.');
    }
    var arr = arrayify(getValue(obj, prop));
    setValue(obj, prop, arrUnion(arr, arrayify(value)));
    return obj;
};
function arrayify(val) {
    if (val === null || typeof val === 'undefined') {
        return [];
    }
    if (Array.isArray(val)) {
        return val;
    }
    return [val];
}

var toString$6 = {}.toString;
var isarray = Array.isArray || function (arr) {
    return toString$6.call(arr) == '[object Array]';
};

var isobject$1 = function isObject(val) {
    return val != null && typeof val === 'object' && isarray(val) === false;
};

/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var hasValues = function hasValue(o, noZero) {
    if (o === null || o === undefined) {
        return false;
    }
    if (typeof o === 'boolean') {
        return true;
    }
    if (typeof o === 'number') {
        if (o === 0 && noZero === true) {
            return false;
        }
        return true;
    }
    if (o.length !== undefined) {
        return o.length !== 0;
    }
    for (var key in o) {
        if (o.hasOwnProperty(key)) {
            return true;
        }
    }
    return false;
};

var hasValue = function (obj, prop, noZero) {
    if (isobject$1(obj)) {
        return hasValues(getValue(obj, prop), noZero);
    }
    return hasValues(obj, prop);
};

var unsetValue = function unset(obj, prop) {
    if (!isobject(obj)) {
        throw new TypeError('expected an object.');
    }
    if (obj.hasOwnProperty(prop)) {
        delete obj[prop];
        return true;
    }
    if (hasValue(obj, prop)) {
        var segs = prop.split('.');
        var last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
            last = segs.pop().slice(0, -1) + '.' + last;
        }
        while (segs.length)
            obj = obj[prop = segs.shift()];
        return (delete obj[last]);
    }
    return true;
};

var extendShallow$4 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$4(o, obj);
        }
    }
    return o;
};
function assign$4(a, b) {
    for (var key in b) {
        if (hasOwn$4(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$4(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

var setValue$1 = function (obj, prop, val) {
    if (!isExtendable$1(obj)) {
        return obj;
    }
    if (Array.isArray(prop)) {
        prop = [].concat.apply([], prop).join('.');
    }
    if (typeof prop !== 'string') {
        return obj;
    }
    var keys = splitString(prop, { sep: '.', brackets: true });
    var len = keys.length;
    var idx = -1;
    var current = obj;
    while (++idx < len) {
        var key = keys[idx];
        if (idx !== len - 1) {
            if (!isExtendable$1(current[key])) {
                current[key] = {};
            }
            current = current[key];
            continue;
        }
        if (isPlainObject(current[key]) && isPlainObject(val)) {
            current[key] = extendShallow$4({}, current[key], val);
        }
        else {
            current[key] = val;
        }
    }
    return obj;
};

/**
 * Create a `Cache` constructor that when instantiated will
 * store values on the given `prop`.
 *
 * ```js
 * var Cache = require('cache-base').namespace('data');
 * var cache = new Cache();
 *
 * cache.set('foo', 'bar');
 * //=> {data: {foo: 'bar'}}
 * ```
 * @param {String} `prop` The property name to use for storing values.
 * @return {Function} Returns a custom `Cache` constructor
 * @api public
 */
function namespace(prop) {
    /**
     * Create a new `Cache`. Internally the `Cache` constructor is created using
     * the `namespace` function, with `cache` defined as the storage object.
     *
     * ```js
     * var app = new Cache();
     * ```
     * @param {Object} `cache` Optionally pass an object to initialize with.
     * @constructor
     * @api public
     */
    function Cache(cache) {
        if (prop) {
            this[prop] = {};
        }
        if (cache) {
            this.set(cache);
        }
    }
    /**
     * Inherit Emitter
     */
    componentEmitter(Cache.prototype);
    /**
     * Assign `value` to `key`. Also emits `set` with
     * the key and value.
     *
     * ```js
     * app.on('set', function(key, val) {
     *   // do something when `set` is emitted
     * });
     *
     * app.set(key, value);
     *
     * // also takes an object or array
     * app.set({name: 'Halle'});
     * app.set([{foo: 'bar'}, {baz: 'quux'}]);
     * console.log(app);
     * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
     * ```
     *
     * @name .set
     * @emits `set` with `key` and `value` as arguments.
     * @param {String} `key`
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */
    Cache.prototype.set = function (key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
            key = toObjectPath(key);
        }
        if (isobject(key) || Array.isArray(key)) {
            this.visit('set', key);
        }
        else {
            setValue$1(prop ? this[prop] : this, key, val);
            this.emit('set', key, val);
        }
        return this;
    };
    /**
     * Union `array` to `key`. Also emits `set` with
     * the key and value.
     *
     * ```js
     * app.union('a.b', ['foo']);
     * app.union('a.b', ['bar']);
     * console.log(app.get('a'));
     * //=> {b: ['foo', 'bar']}
     * ```
     * @name .union
     * @param {String} `key`
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */
    Cache.prototype.union = function (key, val) {
        if (Array.isArray(key) && arguments.length === 2) {
            key = toObjectPath(key);
        }
        var ctx = prop ? this[prop] : this;
        unionValue(ctx, key, arrayify$1(val));
        this.emit('union', val);
        return this;
    };
    /**
     * Return the value of `key`. Dot notation may be used
     * to get [nested property values][get-value].
     *
     * ```js
     * app.set('a.b.c', 'd');
     * app.get('a.b');
     * //=> {c: 'd'}
     *
     * app.get(['a', 'b']);
     * //=> {c: 'd'}
     * ```
     *
     * @name .get
     * @emits `get` with `key` and `value` as arguments.
     * @param {String} `key` The name of the property to get. Dot-notation may be used.
     * @return {any} Returns the value of `key`
     * @api public
     */
    Cache.prototype.get = function (key) {
        key = toObjectPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = getValue(ctx, key);
        this.emit('get', key, val);
        return val;
    };
    /**
     * Return true if app has a stored value for `key`,
     * false only if value is `undefined`.
     *
     * ```js
     * app.set('foo', 'bar');
     * app.has('foo');
     * //=> true
     * ```
     *
     * @name .has
     * @emits `has` with `key` and true or false as arguments.
     * @param {String} `key`
     * @return {Boolean}
     * @api public
     */
    Cache.prototype.has = function (key) {
        key = toObjectPath(arguments);
        var ctx = prop ? this[prop] : this;
        var val = getValue(ctx, key);
        var has = typeof val !== 'undefined';
        this.emit('has', key, has);
        return has;
    };
    /**
     * Delete one or more properties from the instance.
     *
     * ```js
     * app.del(); // delete all
     * // or
     * app.del('foo');
     * // or
     * app.del(['foo', 'bar']);
     * ```
     * @name .del
     * @emits `del` with the `key` as the only argument.
     * @param {String|Array} `key` Property name or array of property names.
     * @return {Object} Returns the instance for chaining.
     * @api public
     */
    Cache.prototype.del = function (key) {
        if (Array.isArray(key)) {
            this.visit('del', key);
        }
        else {
            unsetValue(prop ? this[prop] : this, key);
            this.emit('del', key);
        }
        return this;
    };
    /**
     * Reset the entire cache to an empty object.
     *
     * ```js
     * app.clear();
     * ```
     * @api public
     */
    Cache.prototype.clear = function () {
        if (prop) {
            this[prop] = {};
        }
    };
    /**
     * Visit `method` over the properties in the given object, or map
     * visit over the object-elements in an array.
     *
     * @name .visit
     * @param {String} `method` The name of the `base` method to call.
     * @param {Object|Array} `val` The object or array to iterate over.
     * @return {Object} Returns the instance for chaining.
     * @api public
     */
    Cache.prototype.visit = function (method, val) {
        collectionVisit(this, method, val);
        return this;
    };
    return Cache;
}
/**
 * Cast val to an array
 */
function arrayify$1(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
}
/**
 * Expose `Cache`
 */
var cacheBase = namespace();
/**
 * Expose `Cache.namespace`
 */
var namespace_1 = namespace;
cacheBase.namespace = namespace_1;

var isExtendable$2 = function isExtendable(val) {
    return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var forIn = function forIn(obj, fn, thisArg) {
    for (var key in obj) {
        if (fn.call(thisArg, obj[key], key, obj) === false) {
            break;
        }
    }
};

function mixinDeep(target, objects) {
    var len = arguments.length, i = 0;
    while (++i < len) {
        var obj = arguments[i];
        if (isObject$4(obj)) {
            forIn(obj, copy, target);
        }
    }
    return target;
}
/**
 * Copy properties from the source object to the
 * target object.
 *
 * @param  {*} `val`
 * @param  {String} `key`
 */
function copy(val, key) {
    if (key === '__proto__') {
        return;
    }
    var obj = this[key];
    if (isObject$4(val) && isObject$4(obj)) {
        mixinDeep(obj, val);
    }
    else {
        this[key] = val;
    }
}
/**
 * Returns true if `val` is an object or function.
 *
 * @param  {any} val
 * @return {Boolean}
 */
function isObject$4(val) {
    return isExtendable$2(val) && !Array.isArray(val);
}
/**
 * Expose `mixinDeep`
 */
var mixinDeep_1 = mixinDeep;

/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
function pascalcase(str) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string.');
    }
    str = str.replace(/([A-Z])/g, ' $1');
    if (str.length === 1) {
        return str.toUpperCase();
    }
    str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
    str = str.charAt(0).toUpperCase() + str.slice(1);
    return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
        return ch.toUpperCase();
    });
}
var pascalcase_1 = pascalcase;

var toString$7 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$4 = function kindOf(val) {
    var type = typeof val;
    // primitivies
    if (type === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (type === 'string' || val instanceof String) {
        return 'string';
    }
    if (type === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (type === 'function' || val instanceof Function) {
        if (typeof val.constructor.name !== 'undefined' && val.constructor.name.slice(0, 9) === 'Generator') {
            return 'generatorfunction';
        }
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    type = toString$7.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    if (type === '[object Promise]') {
        return 'promise';
    }
    // buffer
    if (isBuffer$2(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    if (type === '[object Map Iterator]') {
        return 'mapiterator';
    }
    if (type === '[object Set Iterator]') {
        return 'setiterator';
    }
    if (type === '[object String Iterator]') {
        return 'stringiterator';
    }
    if (type === '[object Array Iterator]') {
        return 'arrayiterator';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};
/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */
function isBuffer$2(val) {
    return val.constructor
        && typeof val.constructor.isBuffer === 'function'
        && val.constructor.isBuffer(val);
}

var toString$8 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$5 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$8.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

// accessor descriptor properties
var accessor$3 = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
};
function isAccessorDescriptor$3(obj, prop) {
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (kindOf$5(obj) !== 'object') {
        return false;
    }
    if (has$4(obj, 'value') || has$4(obj, 'writable')) {
        return false;
    }
    if (!has$4(obj, 'get') || typeof obj.get !== 'function') {
        return false;
    }
    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has$4(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
        return false;
    }
    for (var key in obj) {
        if (!accessor$3.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf$5(obj[key]) === accessor$3[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
function has$4(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
/**
 * Expose `isAccessorDescriptor`
 */
var isAccessorDescriptor_1$3 = isAccessorDescriptor$3;

var toString$9 = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$6 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$9.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

// data descriptor properties
var data = {
    configurable: 'boolean',
    enumerable: 'boolean',
    writable: 'boolean'
};
function isDataDescriptor$3(obj, prop) {
    if (kindOf$6(obj) !== 'object') {
        return false;
    }
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (!('value' in obj) && !('writable' in obj)) {
        return false;
    }
    for (var key in obj) {
        if (key === 'value')
            continue;
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf$6(obj[key]) === data[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
/**
 * Expose `isDataDescriptor`
 */
var isDataDescriptor_1 = isDataDescriptor$3;

var isDescriptor$3 = function isDescriptor(obj, key) {
    if (kindOf$4(obj) !== 'object') {
        return false;
    }
    if ('get' in obj) {
        return isAccessorDescriptor_1$3(obj, key);
    }
    return isDataDescriptor_1(obj, key);
};

var defineProperty$3 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$3(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

var toString$a = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */
var kindOf$7 = function kindOf(val) {
    // primitivies
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    // functions
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    // array
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    // other objects
    var type = toString$a.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    // buffer
    if (isBuffer_1(val)) {
        return 'buffer';
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    // typed arrays
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    // must be a plain object
    return 'object';
};

/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {
 *   this.cache = {};
 * }
 * App.prototype.set = function(key, val) {
 *   this.cache[key] = val;
 *   return this;
 * };
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this.cache).length;
 *   }
 * });
 *
 * copy(App.prototype, 'count', 'len');
 *
 * // create an instance
 * var app = new App();
 *
 * app.set('a', true);
 * app.set('b', true);
 * app.set('c', true);
 *
 * console.log(app.count);
 * //=> 3
 * console.log(app.len);
 * //=> 3
 * ```
 * @name copy
 * @param {Object} `receiver` The target object
 * @param {Object} `provider` The provider object
 * @param {String} `from` The key to copy on provider.
 * @param {String} `to` Optionally specify a new key name to use.
 * @return {Object}
 * @api public
 */
var copyDescriptor = function copyDescriptor(receiver, provider, from, to) {
    if (!isObject$5(provider) && typeof provider !== 'function') {
        to = from;
        from = provider;
        provider = receiver;
    }
    if (!isObject$5(receiver) && typeof receiver !== 'function') {
        throw new TypeError('expected the first argument to be an object');
    }
    if (!isObject$5(provider) && typeof provider !== 'function') {
        throw new TypeError('expected provider to be an object');
    }
    if (typeof to !== 'string') {
        to = from;
    }
    if (typeof from !== 'string') {
        throw new TypeError('expected key to be a string');
    }
    if (!(from in provider)) {
        throw new Error('property "' + from + '" does not exist');
    }
    var val = Object.getOwnPropertyDescriptor(provider, from);
    if (val)
        Object.defineProperty(receiver, to, val);
};
function isObject$5(val) {
    return {}.toString.call(val) === '[object Object]';
}

var defineProperty$4 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$3(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

/**
 * Copy static properties, prototype properties, and descriptors from one object to another.
 *
 * ```js
 * function App() {}
 * var proto = App.prototype;
 * App.prototype.set = function() {};
 * App.prototype.get = function() {};
 *
 * var obj = {};
 * copy(obj, proto);
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */
function copy$1(receiver, provider, omit) {
    if (!isObject$6(receiver)) {
        throw new TypeError('expected receiving object to be an object.');
    }
    if (!isObject$6(provider)) {
        throw new TypeError('expected providing object to be an object.');
    }
    var props = nativeKeys(provider);
    var keys = Object.keys(provider);
    var len = props.length;
    omit = arrayify$2(omit);
    while (len--) {
        var key = props[len];
        if (has$5(keys, key)) {
            defineProperty$4(receiver, key, provider[key]);
        }
        else if (!(key in receiver) && !has$5(omit, key)) {
            copyDescriptor(receiver, provider, key);
        }
    }
}
/**
 * Return true if the given value is an object or function
 */
function isObject$6(val) {
    return kindOf$7(val) === 'object' || typeof val === 'function';
}
/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 */
function has$5(obj, val) {
    val = arrayify$2(val);
    var len = val.length;
    if (isObject$6(obj)) {
        for (var key in obj) {
            if (val.indexOf(key) > -1) {
                return true;
            }
        }
        var keys = nativeKeys(obj);
        return has$5(keys, val);
    }
    if (Array.isArray(obj)) {
        var arr = obj;
        while (len--) {
            if (arr.indexOf(val[len]) > -1) {
                return true;
            }
        }
        return false;
    }
    throw new TypeError('expected an array or object.');
}
/**
 * Cast the given value to an array.
 *
 * ```js
 * arrayify('foo');
 * //=> ['foo']
 *
 * arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 */
function arrayify$2(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
}
/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * hasConstructor({});
 * //=> true
 *
 * hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 */
function hasConstructor(val) {
    return isObject$6(val) && typeof val.constructor !== 'undefined';
}
/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 */
function nativeKeys(val) {
    if (!hasConstructor(val))
        return [];
    return Object.getOwnPropertyNames(val);
}
/**
 * Expose `copy`
 */
var objectCopy = copy$1;
/**
 * Expose `copy.has` for tests
 */
var has_1 = has$5;
objectCopy.has = has_1;

var defineProperty$5 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$3(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = require('static-extend');
 * Parent.extend = extend(Parent);
 *
 * // optionally pass a custom merge function as the second arg
 * Parent.extend = extend(Parent, function(Child) {
 *   Child.prototype.mixin = function(key, val) {
 *     Child.prototype[key] = val;
 *   };
 * });
 *
 * // extend "child" constructors
 * Parent.extend(Child);
 *
 * // optionally define prototype methods as the second arg
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */
function extend(Parent, extendFn) {
    if (typeof Parent !== 'function') {
        throw new TypeError('expected Parent to be a function.');
    }
    return function (Ctor, proto) {
        if (typeof Ctor !== 'function') {
            throw new TypeError('expected Ctor to be a function.');
        }
        util$2.inherits(Ctor, Parent);
        objectCopy(Ctor, Parent);
        // proto can be null or a plain object
        if (typeof proto === 'object') {
            var obj = Object.create(proto);
            for (var k in obj) {
                Ctor.prototype[k] = obj[k];
            }
        }
        // keep a reference to the parent prototype
        defineProperty$5(Ctor.prototype, '_parent_', {
            configurable: true,
            set: function () { },
            get: function () {
                return Parent.prototype;
            }
        });
        if (typeof extendFn === 'function') {
            extendFn(Ctor, Parent);
        }
        Ctor.extend = extend(Ctor, extendFn);
    };
}
/**
 * Expose `extend`
 */
var staticExtend = extend;

var classUtils = createCommonjsModule(function (module) {
    /**
     * Expose class utils
     */
    var cu = module.exports;
    /**
     * Expose class utils: `cu`
     */
    cu.isObject = function isObject(val) {
        return isobject(val) || typeof val === 'function';
    };
    /**
     * Returns true if an array has any of the given elements, or an
     * object has any of the give keys.
     *
     * ```js
     * cu.has(['a', 'b', 'c'], 'c');
     * //=> true
     *
     * cu.has(['a', 'b', 'c'], ['c', 'z']);
     * //=> true
     *
     * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
     * //=> true
     * ```
     * @param {Object} `obj`
     * @param {String|Array} `val`
     * @return {Boolean}
     * @api public
     */
    cu.has = function has(obj, val) {
        val = cu.arrayify(val);
        var len = val.length;
        if (cu.isObject(obj)) {
            for (var key in obj) {
                if (val.indexOf(key) > -1) {
                    return true;
                }
            }
            var keys = cu.nativeKeys(obj);
            return cu.has(keys, val);
        }
        if (Array.isArray(obj)) {
            var arr = obj;
            while (len--) {
                if (arr.indexOf(val[len]) > -1) {
                    return true;
                }
            }
            return false;
        }
        throw new TypeError('expected an array or object.');
    };
    /**
     * Returns true if an array or object has all of the given values.
     *
     * ```js
     * cu.hasAll(['a', 'b', 'c'], 'c');
     * //=> true
     *
     * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
     * //=> false
     *
     * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
     * //=> false
     * ```
     * @param {Object|Array} `val`
     * @param {String|Array} `values`
     * @return {Boolean}
     * @api public
     */
    cu.hasAll = function hasAll(val, values) {
        values = cu.arrayify(values);
        var len = values.length;
        while (len--) {
            if (!cu.has(val, values[len])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Cast the given value to an array.
     *
     * ```js
     * cu.arrayify('foo');
     * //=> ['foo']
     *
     * cu.arrayify(['foo']);
     * //=> ['foo']
     * ```
     *
     * @param {String|Array} `val`
     * @return {Array}
     * @api public
     */
    cu.arrayify = function arrayify(val) {
        return val ? (Array.isArray(val) ? val : [val]) : [];
    };
    /**
     * Noop
     */
    cu.noop = function noop() {
        return;
    };
    /**
     * Returns the first argument passed to the function.
     */
    cu.identity = function identity(val) {
        return val;
    };
    /**
     * Returns true if a value has a `contructor`
     *
     * ```js
     * cu.hasConstructor({});
     * //=> true
     *
     * cu.hasConstructor(Object.create(null));
     * //=> false
     * ```
     * @param  {Object} `value`
     * @return {Boolean}
     * @api public
     */
    cu.hasConstructor = function hasConstructor(val) {
        return cu.isObject(val) && typeof val.constructor !== 'undefined';
    };
    /**
     * Get the native `ownPropertyNames` from the constructor of the
     * given `object`. An empty array is returned if the object does
     * not have a constructor.
     *
     * ```js
     * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
     * //=> ['a', 'b', 'c']
     *
     * cu.nativeKeys(function(){})
     * //=> ['length', 'caller']
     * ```
     *
     * @param  {Object} `obj` Object that has a `constructor`.
     * @return {Array} Array of keys.
     * @api public
     */
    cu.nativeKeys = function nativeKeys(val) {
        if (!cu.hasConstructor(val))
            return [];
        var keys = Object.getOwnPropertyNames(val);
        if ('caller' in val)
            keys.push('caller');
        return keys;
    };
    /**
     * Returns property descriptor `key` if it's an "own" property
     * of the given object.
     *
     * ```js
     * function App() {}
     * Object.defineProperty(App.prototype, 'count', {
     *   get: function() {
     *     return Object.keys(this).length;
     *   }
     * });
     * cu.getDescriptor(App.prototype, 'count');
     * // returns:
     * // {
     * //   get: [Function],
     * //   set: undefined,
     * //   enumerable: false,
     * //   configurable: false
     * // }
     * ```
     *
     * @param {Object} `obj`
     * @param {String} `key`
     * @return {Object} Returns descriptor `key`
     * @api public
     */
    cu.getDescriptor = function getDescriptor(obj, key) {
        if (!cu.isObject(obj)) {
            throw new TypeError('expected an object.');
        }
        if (typeof key !== 'string') {
            throw new TypeError('expected key to be a string.');
        }
        return Object.getOwnPropertyDescriptor(obj, key);
    };
    /**
     * Copy a descriptor from one object to another.
     *
     * ```js
     * function App() {}
     * Object.defineProperty(App.prototype, 'count', {
     *   get: function() {
     *     return Object.keys(this).length;
     *   }
     * });
     * var obj = {};
     * cu.copyDescriptor(obj, App.prototype, 'count');
     * ```
     * @param {Object} `receiver`
     * @param {Object} `provider`
     * @param {String} `name`
     * @return {Object}
     * @api public
     */
    cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
        if (!cu.isObject(receiver)) {
            throw new TypeError('expected receiving object to be an object.');
        }
        if (!cu.isObject(provider)) {
            throw new TypeError('expected providing object to be an object.');
        }
        if (typeof name !== 'string') {
            throw new TypeError('expected name to be a string.');
        }
        var val = cu.getDescriptor(provider, name);
        if (val)
            Object.defineProperty(receiver, name, val);
    };
    /**
     * Copy static properties, prototype properties, and descriptors
     * from one object to another.
     *
     * @param {Object} `receiver`
     * @param {Object} `provider`
     * @param {String|Array} `omit` One or more properties to omit
     * @return {Object}
     * @api public
     */
    cu.copy = function copy(receiver, provider, omit) {
        if (!cu.isObject(receiver)) {
            throw new TypeError('expected receiving object to be an object.');
        }
        if (!cu.isObject(provider)) {
            throw new TypeError('expected providing object to be an object.');
        }
        var props = Object.getOwnPropertyNames(provider);
        var keys = Object.keys(provider);
        var len = props.length, key;
        omit = cu.arrayify(omit);
        while (len--) {
            key = props[len];
            if (cu.has(keys, key)) {
                defineProperty$3(receiver, key, provider[key]);
            }
            else if (!(key in receiver) && !cu.has(omit, key)) {
                cu.copyDescriptor(receiver, provider, key);
            }
        }
    };
    /**
     * Inherit the static properties, prototype properties, and descriptors
     * from of an object.
     *
     * @param {Object} `receiver`
     * @param {Object} `provider`
     * @param {String|Array} `omit` One or more properties to omit
     * @return {Object}
     * @api public
     */
    cu.inherit = function inherit(receiver, provider, omit) {
        if (!cu.isObject(receiver)) {
            throw new TypeError('expected receiving object to be an object.');
        }
        if (!cu.isObject(provider)) {
            throw new TypeError('expected providing object to be an object.');
        }
        var keys = [];
        for (var key in provider) {
            keys.push(key);
            receiver[key] = provider[key];
        }
        keys = keys.concat(cu.arrayify(omit));
        var a = provider.prototype || provider;
        var b = receiver.prototype || receiver;
        cu.copy(b, a, keys);
    };
    /**
     * Returns a function for extending the static properties,
     * prototype properties, and descriptors from the `Parent`
     * constructor onto `Child` constructors.
     *
     * ```js
     * var extend = cu.extend(Parent);
     * Parent.extend(Child);
     *
     * // optional methods
     * Parent.extend(Child, {
     *   foo: function() {},
     *   bar: function() {}
     * });
     * ```
     * @param {Function} `Parent` Parent ctor
     * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
     *   @param {Function} `Child` Child ctor
     *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
     *   @return {Object}
     * @api public
     */
    cu.extend = function () {
        // keep it lazy, instead of assigning to `cu.extend`
        return staticExtend.apply(null, arguments);
    };
    /**
     * Bubble up events emitted from static methods on the Parent ctor.
     *
     * @param {Object} `Parent`
     * @param {Array} `events` Event names to bubble up
     * @api public
     */
    cu.bubble = function (Parent, events) {
        events = events || [];
        Parent.bubble = function (Child, arr) {
            if (Array.isArray(arr)) {
                events = arrUnion([], events, arr);
            }
            var len = events.length;
            var idx = -1;
            while (++idx < len) {
                var name = events[idx];
                Parent.on(name, Child.emit.bind(Child, name));
            }
            cu.bubble(Child, events);
        };
    };
});

/**
 * Optionally define a custom `cache` namespace to use.
 */
function namespace$1(name) {
    var Cache = name ? cacheBase.namespace(name) : cacheBase;
    var fns = [];
    /**
     * Create an instance of `Base` with the given `config` and `options`.
     *
     * ```js
     * // initialize with `config` and `options`
     * var app = new Base({isApp: true}, {abc: true});
     * app.set('foo', 'bar');
     *
     * // values defined with the given `config` object will be on the root of the instance
     * console.log(app.baz); //=> undefined
     * console.log(app.foo); //=> 'bar'
     * // or use `.get`
     * console.log(app.get('isApp')); //=> true
     * console.log(app.get('foo')); //=> 'bar'
     *
     * // values defined with the given `options` object will be on `app.options
     * console.log(app.options.abc); //=> true
     * ```
     *
     * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
     * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
     * @api public
     */
    function Base(config, options) {
        if (!(this instanceof Base)) {
            return new Base(config, options);
        }
        Cache.call(this, config);
        this.is('base');
        this.initBase(config, options);
    }
    /**
     * Inherit cache-base
     */
    util$2.inherits(Base, Cache);
    /**
     * Add static emitter methods
     */
    componentEmitter(Base);
    /**
     * Initialize `Base` defaults with the given `config` object
     */
    Base.prototype.initBase = function (config, options) {
        this.options = mixinDeep_1({}, this.options, options);
        this.cache = this.cache || {};
        this.define('registered', {});
        if (name)
            this[name] = {};
        // make `app._callbacks` non-enumerable
        this.define('_callbacks', this._callbacks);
        if (isobject(config)) {
            this.visit('set', config);
        }
        Base.run(this, 'use', fns);
    };
    /**
     * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
     * lookups in plugins.
     *
     * ```js
     * app.is('foo');
     * console.log(app._name);
     * //=> 'foo'
     * console.log(app.isFoo);
     * //=> true
     * app.is('bar');
     * console.log(app.isFoo);
     * //=> true
     * console.log(app.isBar);
     * //=> true
     * console.log(app._name);
     * //=> 'bar'
     * ```
     * @name .is
     * @param {String} `name`
     * @return {Boolean}
     * @api public
     */
    Base.prototype.is = function (name) {
        if (typeof name !== 'string') {
            throw new TypeError('expected name to be a string');
        }
        this.define('is' + pascalcase_1(name), true);
        this.define('_name', name);
        this.define('_appname', name);
        return this;
    };
    /**
     * Returns true if a plugin has already been registered on an instance.
     *
     * Plugin implementors are encouraged to use this first thing in a plugin
     * to prevent the plugin from being called more than once on the same
     * instance.
     *
     * ```js
     * var base = new Base();
     * base.use(function(app) {
     *   if (app.isRegistered('myPlugin')) return;
     *   // do stuff to `app`
     * });
     *
     * // to also record the plugin as being registered
     * base.use(function(app) {
     *   if (app.isRegistered('myPlugin', true)) return;
     *   // do stuff to `app`
     * });
     * ```
     * @name .isRegistered
     * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
     * @param {String} `name` The plugin name.
     * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
     * @return {Boolean} Returns true if a plugin is already registered.
     * @api public
     */
    Base.prototype.isRegistered = function (name, register) {
        if (this.registered.hasOwnProperty(name)) {
            return true;
        }
        if (register !== false) {
            this.registered[name] = true;
            this.emit('plugin', name);
        }
        return false;
    };
    /**
     * Define a plugin function to be called immediately upon init. Plugins are chainable
     * and expose the following arguments to the plugin function:
     *
     * - `app`: the current instance of `Base`
     * - `base`: the [first ancestor instance](#base) of `Base`
     *
     * ```js
     * var app = new Base()
     *   .use(foo)
     *   .use(bar)
     *   .use(baz)
     * ```
     * @name .use
     * @param {Function} `fn` plugin function to call
     * @return {Object} Returns the item instance for chaining.
     * @api public
     */
    Base.prototype.use = function (fn) {
        fn.call(this, this);
        return this;
    };
    /**
     * The `.define` method is used for adding non-enumerable property on the instance.
     * Dot-notation is **not supported** with `define`.
     *
     * ```js
     * // arbitrary `render` function using lodash `template`
     * app.define('render', function(str, locals) {
     *   return _.template(str)(locals);
     * });
     * ```
     * @name .define
     * @param {String} `key` The name of the property to define.
     * @param {any} `value`
     * @return {Object} Returns the instance for chaining.
     * @api public
     */
    Base.prototype.define = function (key, val) {
        if (isobject(key)) {
            return this.visit('define', key);
        }
        defineProperty$2(this, key, val);
        return this;
    };
    /**
     * Mix property `key` onto the Base prototype. If base is inherited using
     * `Base.extend` this method will be overridden by a new `mixin` method that will
     * only add properties to the prototype of the inheriting application.
     *
     * ```js
     * app.mixin('foo', function() {
     *   // do stuff
     * });
     * ```
     * @name .mixin
     * @param {String} `key`
     * @param {Object|Array} `val`
     * @return {Object} Returns the `base` instance for chaining.
     * @api public
     */
    Base.prototype.mixin = function (key, val) {
        Base.prototype[key] = val;
        return this;
    };
    /**
     * Non-enumberable mixin array, used by the static [Base.mixin]() method.
     */
    Base.prototype.mixins = Base.prototype.mixins || [];
    /**
     * Getter/setter used when creating nested instances of `Base`, for storing a reference
     * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
     * property of a "child" instance. The `base` property defaults to the current instance if
     * no `parent` property is defined.
     *
     * ```js
     * // create an instance of `Base`, this is our first ("base") instance
     * var first = new Base();
     * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
     *
     * // create another instance
     * var second = new Base();
     * // create a reference to the first instance (`first`)
     * second.parent = first;
     *
     * // create another instance
     * var third = new Base();
     * // create a reference to the previous instance (`second`)
     * // repeat this pattern every time a "child" instance is created
     * third.parent = second;
     *
     * // we can always access the first instance using the `base` property
     * console.log(first.base.foo);
     * //=> 'bar'
     * console.log(second.base.foo);
     * //=> 'bar'
     * console.log(third.base.foo);
     * //=> 'bar'
     * // and now you know how to get to third base ;)
     * ```
     * @name .base
     * @api public
     */
    Object.defineProperty(Base.prototype, 'base', {
        configurable: true,
        get: function () {
            return this.parent ? this.parent.base : this;
        }
    });
    /**
     * Static method for adding global plugin functions that will
     * be added to an instance when created.
     *
     * ```js
     * Base.use(function(app) {
     *   app.foo = 'bar';
     * });
     * var app = new Base();
     * console.log(app.foo);
     * //=> 'bar'
     * ```
     * @name #use
     * @param {Function} `fn` Plugin function to use on each instance.
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */
    defineProperty$2(Base, 'use', function (fn) {
        fns.push(fn);
        return Base;
    });
    /**
     * Run an array of functions by passing each function
     * to a method on the given object specified by the given property.
     *
     * @param  {Object} `obj` Object containing method to use.
     * @param  {String} `prop` Name of the method on the object to use.
     * @param  {Array} `arr` Array of functions to pass to the method.
     */
    defineProperty$2(Base, 'run', function (obj, prop, arr) {
        var len = arr.length, i = 0;
        while (len--) {
            obj[prop](arr[i++]);
        }
        return Base;
    });
    /**
     * Static method for inheriting the prototype and static methods of the `Base` class.
     * This method greatly simplifies the process of creating inheritance-based applications.
     * See [static-extend][] for more details.
     *
     * ```js
     * var extend = cu.extend(Parent);
     * Parent.extend(Child);
     *
     * // optional methods
     * Parent.extend(Child, {
     *   foo: function() {},
     *   bar: function() {}
     * });
     * ```
     * @name #extend
     * @param {Function} `Ctor` constructor to extend
     * @param {Object} `methods` Optional prototype properties to mix in.
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */
    defineProperty$2(Base, 'extend', classUtils.extend(Base, function (Ctor, Parent) {
        Ctor.prototype.mixins = Ctor.prototype.mixins || [];
        defineProperty$2(Ctor, 'mixin', function (fn) {
            var mixin = fn(Ctor.prototype, Ctor);
            if (typeof mixin === 'function') {
                Ctor.prototype.mixins.push(mixin);
            }
            return Ctor;
        });
        defineProperty$2(Ctor, 'mixins', function (Child) {
            Base.run(Child, 'mixin', Ctor.prototype.mixins);
            return Ctor;
        });
        Ctor.prototype.mixin = function (key, value) {
            Ctor.prototype[key] = value;
            return this;
        };
        return Base;
    }));
    /**
     * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
     * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
     * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
     * called (e.g. `Base.mixins(Child)`).
     *
     * ```js
     * Base.mixin(function(proto) {
     *   proto.foo = function(msg) {
     *     return 'foo ' + msg;
     *   };
     * });
     * ```
     * @name #mixin
     * @param {Function} `fn` Function to call
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */
    defineProperty$2(Base, 'mixin', function (fn) {
        var mixin = fn(Base.prototype, Base);
        if (typeof mixin === 'function') {
            Base.prototype.mixins.push(mixin);
        }
        return Base;
    });
    /**
     * Static method for running global mixin functions against a child constructor.
     * Mixins must be registered before calling this method.
     *
     * ```js
     * Base.extend(Child);
     * Base.mixins(Child);
     * ```
     * @name #mixins
     * @param {Function} `Child` Constructor function of a child class
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */
    defineProperty$2(Base, 'mixins', function (Child) {
        Base.run(Child, 'mixin', Base.prototype.mixins);
        return Base;
    });
    /**
     * Similar to `util.inherit`, but copies all static properties, prototype properties, and
     * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
     *
     * ```js
     * Base.inherit(Foo, Bar);
     * ```
     * @name #inherit
     * @param {Function} `Receiver` Receiving (child) constructor
     * @param {Function} `Provider` Providing (parent) constructor
     * @return {Object} Returns the `Base` constructor for chaining
     * @api public
     */
    defineProperty$2(Base, 'inherit', classUtils.inherit);
    defineProperty$2(Base, 'bubble', classUtils.bubble);
    return Base;
}
/**
 * Expose `Base` with default settings
 */
var base$2 = namespace$1();
/**
 * Allow users to define a namespace
 */
var namespace_1$1 = namespace$1;
base$2.namespace = namespace_1$1;

var defineProperty$6 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$3(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var use = function base(app, options) {
    if (!isObject$7(app) && typeof app !== 'function') {
        throw new TypeError('expected an object or function');
    }
    var opts = isObject$7(options) ? options : {};
    var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';
    if (!Array.isArray(app[prop])) {
        define$1(app, prop, []);
    }
    /**
     * Define a plugin function to be passed to use. The only
     * parameter exposed to the plugin is `app`, the object or function.
     * passed to `use(app)`. `app` is also exposed as `this` in plugins.
     *
     * Additionally, **if a plugin returns a function, the function will
     * be pushed onto the `fns` array**, allowing the plugin to be
     * called at a later point by the `run` method.
     *
     * ```js
     * var use = require('use');
     *
     * // define a plugin
     * function foo(app) {
     *   // do stuff
     * }
     *
     * var app = function(){};
     * use(app);
     *
     * // register plugins
     * app.use(foo);
     * app.use(bar);
     * app.use(baz);
     * ```
     * @name .use
     * @param {Function} `fn` plugin function to call
     * @api public
     */
    define$1(app, 'use', use);
    /**
     * Run all plugins on `fns`. Any plugin that returns a function
     * when called by `use` is pushed onto the `fns` array.
     *
     * ```js
     * var config = {};
     * app.run(config);
     * ```
     * @name .run
     * @param {Object} `value` Object to be modified by plugins.
     * @return {Object} Returns the object passed to `run`
     * @api public
     */
    define$1(app, 'run', function (val) {
        if (!isObject$7(val))
            return;
        if (!val.use || !val.run) {
            define$1(val, prop, val[prop] || []);
            define$1(val, 'use', use);
        }
        if (!val[prop] || val[prop].indexOf(base) === -1) {
            val.use(base);
        }
        var self = this || app;
        var fns = self[prop];
        var len = fns.length;
        var idx = -1;
        while (++idx < len) {
            val.use(fns[idx]);
        }
        return val;
    });
    /**
     * Call plugin `fn`. If a function is returned push it into the
     * `fns` array to be called by the `run` method.
     */
    function use(type, fn, options) {
        var offset = 1;
        if (typeof type === 'string' || Array.isArray(type)) {
            fn = wrap(type, fn);
            offset++;
        }
        else {
            options = fn;
            fn = type;
        }
        if (typeof fn !== 'function') {
            throw new TypeError('expected a function');
        }
        var self = this || app;
        var fns = self[prop];
        var args = [].slice.call(arguments, offset);
        args.unshift(self);
        if (typeof opts.hook === 'function') {
            opts.hook.apply(self, args);
        }
        var val = fn.apply(self, args);
        if (typeof val === 'function' && fns.indexOf(val) === -1) {
            fns.push(val);
        }
        return self;
    }
    /**
     * Wrap a named plugin function so that it's only called on objects of the
     * given `type`
     *
     * @param {String} `type`
     * @param {Function} `fn` Plugin function
     * @return {Function}
     */
    function wrap(type, fn) {
        return function plugin() {
            return this.type === type ? fn.apply(this, arguments) : plugin;
        };
    }
    return app;
};
function isObject$7(val) {
    return val && typeof val === 'object' && !Array.isArray(val);
}
function define$1(obj, key, val) {
    Object.defineProperty(obj, key, {
        configurable: true,
        writable: true,
        value: val
    });
}

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */
var ms = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    }
    else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
function fmtShort(ms) {
    if (ms >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
function fmtLong(ms) {
    return plural(ms, d, 'day') ||
        plural(ms, h, 'hour') ||
        plural(ms, m, 'minute') ||
        plural(ms, s, 'second') ||
        ms + ' ms';
}
/**
 * Pluralization helper.
 */
function plural(ms, n, name) {
    if (ms < n) {
        return;
    }
    if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;
    /**
     * The currently active debug mode names, and names to skip.
     */
    exports.names = [];
    exports.skips = [];
    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */
    exports.formatters = {};
    /**
     * Previous log timestamp.
     */
    var prevTime;
    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */
    function selectColor(namespace) {
        var hash = 0, i;
        for (i in namespace) {
            hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */
    function createDebug(namespace) {
        function debug() {
            // disabled?
            if (!debug.enabled)
                return;
            var self = debug;
            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            // turn the `arguments` into a proper Array
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
            }
            args[0] = exports.coerce(args[0]);
            if ('string' !== typeof args[0]) {
                // anything else let's inspect with %O
                args.unshift('%O');
            }
            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === '%%')
                    return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);
                    // now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // apply env-specific formatting (colors, etc.)
            exports.formatArgs.call(self, args);
            var logFn = debug.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.enabled = exports.enabled(namespace);
        debug.useColors = exports.useColors();
        debug.color = selectColor(namespace);
        // env-specific initialization logic for debug instances
        if ('function' === typeof exports.init) {
            exports.init(debug);
        }
        return debug;
    }
    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */
    function enable(namespaces) {
        exports.save(namespaces);
        exports.names = [];
        exports.skips = [];
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
            if (!split[i])
                continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            }
            else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }
    /**
     * Disable debug output.
     *
     * @api public
     */
    function disable() {
        exports.enable('');
    }
    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */
    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false;
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */
    function coerce(val) {
        if (val instanceof Error)
            return val.stack || val.message;
        return val;
    }
});

var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
        && 'undefined' != typeof chrome.storage
        ? chrome.storage.local
        : localstorage();
    /**
     * Colors.
     */
    exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
    ];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    function useColors() {
        // NB: In an Electron preload script, document will be defined but not fully
        // initialized. Since we know we're in Chrome, we'll just detect this case
        // explicitly
        if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
            return true;
        }
        // is webkit? http://stackoverflow.com/a/16459606/376773
        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
        return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
            // is firebug? http://stackoverflow.com/a/398120/376773
            (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
            // is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
            // double check webkit in userAgent just in case we are in a worker
            (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */
    exports.formatters.j = function (v) {
        try {
            return JSON.stringify(v);
        }
        catch (err) {
            return '[UnexpectedJSONParseError]: ' + err.message;
        }
    };
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */
    function formatArgs(args) {
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '')
            + this.namespace
            + (useColors ? ' %c' : ' ')
            + args[0]
            + (useColors ? '%c ' : ' ')
            + '+' + exports.humanize(this.diff);
        if (!useColors)
            return;
        var c = 'color: ' + this.color;
        args.splice(1, 0, c, 'color: inherit');
        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function (match) {
            if ('%%' === match)
                return;
            index++;
            if ('%c' === match) {
                // we only are interested in the *last* %c
                // (the user may have provided their own)
                lastC = index;
            }
        });
        args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    function log() {
        // this hackery is required for IE8/9, where
        // the `console.log` function doesn't have 'apply'
        return 'object' === typeof console
            && console.log
            && Function.prototype.apply.call(console.log, console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
        try {
            if (null == namespaces) {
                exports.storage.removeItem('debug');
            }
            else {
                exports.storage.debug = namespaces;
            }
        }
        catch (e) { }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
        var r;
        try {
            r = exports.storage.debug;
        }
        catch (e) { }
        // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
        if (!r && typeof process !== 'undefined' && 'env' in process) {
            r = process.env.DEBUG;
        }
        return r;
    }
    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */
    exports.enable(load());
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */
    function localstorage() {
        try {
            return window.localStorage;
        }
        catch (e) { }
    }
});

var node = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    exports = module.exports = debug;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    /**
     * Colors.
     */
    exports.colors = [6, 2, 3, 4, 5, 1];
    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */
    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
        return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
        // camel-case
        var prop = key
            .substring(6)
            .toLowerCase()
            .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase(); });
        // coerce string value into JS value
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val))
            val = true;
        else if (/^(no|off|false|disabled)$/i.test(val))
            val = false;
        else if (val === 'null')
            val = null;
        else
            val = Number(val);
        obj[prop] = val;
        return obj;
    }, {});
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
        util$2.deprecate(function () { }, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
    }
    var stream = 1 === fd ? process.stdout :
        2 === fd ? process.stderr :
            createWritableStdioStream(fd);
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    function useColors() {
        return 'colors' in exports.inspectOpts
            ? Boolean(exports.inspectOpts.colors)
            : tty.isatty(fd);
    }
    /**
     * Map %o to `util.inspect()`, all on a single line.
     */
    exports.formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util$2.inspect(v, this.inspectOpts)
            .split('\n').map(function (str) {
            return str.trim();
        }).join(' ');
    };
    /**
     * Map %o to `util.inspect()`, allowing multiple lines if needed.
     */
    exports.formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util$2.inspect(v, this.inspectOpts);
    };
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    function formatArgs(args) {
        var name = this.namespace;
        var useColors = this.useColors;
        if (useColors) {
            var c = this.color;
            var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';
            args[0] = prefix + args[0].split('\n').join('\n' + prefix);
            args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
        }
        else {
            args[0] = new Date().toUTCString()
                + ' ' + name + ' ' + args[0];
        }
    }
    /**
     * Invokes `util.format()` with the specified arguments and writes to `stream`.
     */
    function log() {
        return stream.write(util$2.format.apply(util$2, arguments) + '\n');
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
        if (null == namespaces) {
            // If you set a process.env field to null or undefined, it gets cast to the
            // string 'null' or 'undefined'. Just delete instead.
            delete process.env.DEBUG;
        }
        else {
            process.env.DEBUG = namespaces;
        }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
        return process.env.DEBUG;
    }
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    function createWritableStdioStream(fd) {
        var stream;
        var tty_wrap = process.binding('tty_wrap');
        // Note stream._type is used for test-module-load-list.js
        switch (tty_wrap.guessHandleType(fd)) {
            case 'TTY':
                stream = new tty.WriteStream(fd);
                stream._type = 'tty';
                // Hack to have stream not keep the event loop alive.
                // See https://github.com/joyent/node/issues/1726
                if (stream._handle && stream._handle.unref) {
                    stream._handle.unref();
                }
                break;
            case 'FILE':
                var fs = fs__default;
                stream = new fs.SyncWriteStream(fd, { autoClose: false });
                stream._type = 'fs';
                break;
            case 'PIPE':
            case 'TCP':
                var net$1 = net;
                stream = new net$1.Socket({
                    fd: fd,
                    readable: false,
                    writable: true
                });
                // FIXME Should probably have an option in net.Socket to create a
                // stream from an existing fd which is writable only. But for now
                // we'll just add this hack and set the `readable` member to false.
                // Test: ./node test/fixtures/echo.js < /etc/passwd
                stream.readable = false;
                stream.read = null;
                stream._type = 'pipe';
                // FIXME Hack to have stream not keep the event loop alive.
                // See https://github.com/joyent/node/issues/1726
                if (stream._handle && stream._handle.unref) {
                    stream._handle.unref();
                }
                break;
            default:
                // Probably an error on in uv_guess_handle()
                throw new Error('Implement me. Unknown stream file type!');
        }
        // For supporting legacy API we put the FD here.
        stream.fd = fd;
        stream._isStdio = true;
        return stream;
    }
    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */
    function init(debug) {
        debug.inspectOpts = {};
        var keys = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys.length; i++) {
            debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
    }
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    exports.enable(load());
});

var src = createCommonjsModule(function (module) {
    /**
     * Detect Electron renderer process, which is node, but we should
     * treat as a browser.
     */
    if (typeof process !== 'undefined' && process.type === 'renderer') {
        module.exports = browser;
    }
    else {
        module.exports = node;
    }
});

var extendShallow$5 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$5(o, obj);
        }
    }
    return o;
};
function assign$5(a, b) {
    for (var key in b) {
        if (hasOwn$5(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$5(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
var encode$1 = function (number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
var decode$1 = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return (charCode - bigA);
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return (charCode - littleA + littleOffset);
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return (charCode - zero + numberOffset);
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
var base64 = {
    encode: encode$1,
    decode: decode$1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
    return aValue < 0
        ? ((-aValue) << 1) + 1
        : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
        ? -shifted
        : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */
var encode$2 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
var decode$2 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
var base64Vlq = {
    encode: encode$2,
    decode: decode$2
};

var util$1 = createCommonjsModule(function (module, exports) {
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
            return aArgs[aName];
        }
        else if (arguments.length === 3) {
            return aDefaultValue;
        }
        else {
            throw new Error('"' + aName + '" is a required argument.');
        }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
            return null;
        }
        return {
            scheme: match[1],
            auth: match[2],
            host: match[3],
            port: match[4],
            path: match[5]
        };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
            url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
            url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
            url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
            url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
            url += aParsedUrl.path;
        }
        return url;
    }
    exports.urlGenerate = urlGenerate;
    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */
    function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
            if (!url.path) {
                return aPath;
            }
            path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
            part = parts[i];
            if (part === '.') {
                parts.splice(i, 1);
            }
            else if (part === '..') {
                up++;
            }
            else if (up > 0) {
                if (part === '') {
                    // The first part is blank if the path is absolute. Trying to go
                    // above the root is a no-op. Therefore we can remove all '..' parts
                    // directly after the root.
                    parts.splice(i + 1, up);
                    up = 0;
                }
                else {
                    parts.splice(i, 2);
                    up--;
                }
            }
        }
        path = parts.join('/');
        if (path === '') {
            path = isAbsolute ? '/' : '.';
        }
        if (url) {
            url.path = path;
            return urlGenerate(url);
        }
        return path;
    }
    exports.normalize = normalize;
    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */
    function join(aRoot, aPath) {
        if (aRoot === "") {
            aRoot = ".";
        }
        if (aPath === "") {
            aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
            aRoot = aRootUrl.path || '/';
        }
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
                aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
        }
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === '/'
            ? aPath
            : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
        if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
        }
        return joined;
    }
    exports.join = join;
    exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
    };
    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */
    function relative(aRoot, aPath) {
        if (aRoot === "") {
            aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, '');
        // It is possible for the path to be above the root. In this case, simply
        // checking whether the root is a prefix of the path won't work. Instead, we
        // need to remove components from the root one by one, until either we find
        // a prefix that fits, or we run out of components to remove.
        var level = 0;
        while (aPath.indexOf(aRoot + '/') !== 0) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0) {
                return aPath;
            }
            // If the only part of the root that is left is the scheme (i.e. http://,
            // file:///, etc.), one or more slashes (/), or simply nothing at all, we
            // have exhausted all components, so the path is not relative to the root.
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                return aPath;
            }
            ++level;
        }
        // Make sure we add a "../" for each component we removed from the root.
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = (function () {
        var obj = Object.create(null);
        return !('__proto__' in obj);
    }());
    function identity(s) {
        return s;
    }
    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */
    function toSetString(aStr) {
        if (isProtoString(aStr)) {
            return '$' + aStr;
        }
        return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
        if (isProtoString(aStr)) {
            return aStr.slice(1);
        }
        return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
        if (!s) {
            return false;
        }
        var length = s.length;
        if (length < 9 /* "__proto__".length */) {
            return false;
        }
        if (s.charCodeAt(length - 1) !== 95 /* '_' */ ||
            s.charCodeAt(length - 2) !== 95 /* '_' */ ||
            s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 4) !== 116 /* 't' */ ||
            s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
            s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
            s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
            s.charCodeAt(length - 8) !== 95 /* '_' */ ||
            s.charCodeAt(length - 9) !== 95 /* '_' */) {
            return false;
        }
        for (var i = length - 10; i >= 0; i--) {
            if (s.charCodeAt(i) !== 36 /* '$' */) {
                return false;
            }
        }
        return true;
    }
    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }
        return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
        }
        cmp = mappingA.source - mappingB.source;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
            return cmp;
        }
        return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
            return 0;
        }
        if (aStr1 > aStr2) {
            return 1;
        }
        return -1;
    }
    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
            return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
            return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
});

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var has$6 = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$1.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has$6.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        }
        else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    }
    else {
        var sStr = util$1.toSetString(aStr);
        return has$6.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    }
    else {
        var sStr = util$1.toSetString(aStr);
        if (has$6.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
var ArraySet_1 = ArraySet;
var arraySet = {
    ArraySet: ArraySet_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
        util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = { generatedLine: -1, generatedColumn: 0 };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
    };
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    }
    else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util$1.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
var MappingList_1 = MappingList;
var mappingList = {
    MappingList: MappingList_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var ArraySet$1 = arraySet.ArraySet;
var MappingList$1 = mappingList.MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util$1.getArg(aArgs, 'file', null);
    this._sourceRoot = util$1.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util$1.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList$1();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
        });
        aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
                generated: {
                    line: mapping.generatedLine,
                    column: mapping.generatedColumn
                }
            };
            if (mapping.source != null) {
                newMapping.source = mapping.source;
                if (sourceRoot != null) {
                    newMapping.source = util$1.relative(sourceRoot, newMapping.source);
                }
                newMapping.original = {
                    line: mapping.originalLine,
                    column: mapping.originalColumn
                };
                if (mapping.name != null) {
                    newMapping.name = mapping.name;
                }
            }
            generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
                generator.setSourceContent(sourceFile, content);
            }
        });
        return generator;
    };
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
        var generated = util$1.getArg(aArgs, 'generated');
        var original = util$1.getArg(aArgs, 'original', null);
        var source = util$1.getArg(aArgs, 'source', null);
        var name = util$1.getArg(aArgs, 'name', null);
        if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
                this._sources.add(source);
            }
        }
        if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
                this._names.add(name);
            }
        }
        this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
        });
    };
/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
            source = util$1.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
                this._sourcesContents = Object.create(null);
            }
            this._sourcesContents[util$1.toSetString(source)] = aSourceContent;
        }
        else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util$1.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
                this._sourcesContents = null;
            }
        }
    };
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        // If aSourceFile is omitted, we will use the file property of the SourceMap
        if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
                throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                    'or the source map\'s "file" property. Both were omitted.');
            }
            sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        // Make "sourceFile" relative if an absolute Url is passed.
        if (sourceRoot != null) {
            sourceFile = util$1.relative(sourceRoot, sourceFile);
        }
        // Applying the SourceMap can add and remove items from the sources and
        // the names array.
        var newSources = new ArraySet$1();
        var newNames = new ArraySet$1();
        // Find mappings for the "sourceFile"
        this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
                // Check if it can be mapped by the source map, then update the mapping.
                var original = aSourceMapConsumer.originalPositionFor({
                    line: mapping.originalLine,
                    column: mapping.originalColumn
                });
                if (original.source != null) {
                    // Copy mapping
                    mapping.source = original.source;
                    if (aSourceMapPath != null) {
                        mapping.source = util$1.join(aSourceMapPath, mapping.source);
                    }
                    if (sourceRoot != null) {
                        mapping.source = util$1.relative(sourceRoot, mapping.source);
                    }
                    mapping.originalLine = original.line;
                    mapping.originalColumn = original.column;
                    if (original.name != null) {
                        mapping.name = original.name;
                    }
                }
            }
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
                newSources.add(source);
            }
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
                newNames.add(name);
            }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        // Copy sourcesContents of applied map.
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
                if (aSourceMapPath != null) {
                    sourceFile = util$1.join(aSourceMapPath, sourceFile);
                }
                if (sourceRoot != null) {
                    sourceFile = util$1.relative(sourceRoot, sourceFile);
                }
                this.setSourceContent(sourceFile, content);
            }
        }, this);
    };
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        // When aOriginal is truthy but has empty values for .line and .column,
        // it is most likely a programmer error. In this case we throw a very
        // specific error message to try to guide them the right way.
        // For example: https://github.com/Polymer/polymer-bundler/pull/519
        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
            throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' +
                'the original mapping entirely and only map the generated position. If so, pass ' +
                'null for the original mapping instead of an object with empty or null values.');
        }
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
            && aGenerated.line > 0 && aGenerated.column >= 0
            && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
        }
        else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
            && aOriginal && 'line' in aOriginal && 'column' in aOriginal
            && aGenerated.line > 0 && aGenerated.column >= 0
            && aOriginal.line > 0 && aOriginal.column >= 0
            && aSource) {
            // Cases 2 and 3.
            return;
        }
        else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
                generated: aGenerated,
                source: aSource,
                original: aOriginal,
                name: aName
            }));
        }
    };
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
            next = '';
            if (mapping.generatedLine !== previousGeneratedLine) {
                previousGeneratedColumn = 0;
                while (mapping.generatedLine !== previousGeneratedLine) {
                    next += ';';
                    previousGeneratedLine++;
                }
            }
            else {
                if (i > 0) {
                    if (!util$1.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                        continue;
                    }
                    next += ',';
                }
            }
            next += base64Vlq.encode(mapping.generatedColumn
                - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
            if (mapping.source != null) {
                sourceIdx = this._sources.indexOf(mapping.source);
                next += base64Vlq.encode(sourceIdx - previousSource);
                previousSource = sourceIdx;
                // lines are stored 0-based in SourceMap spec version 3
                next += base64Vlq.encode(mapping.originalLine - 1
                    - previousOriginalLine);
                previousOriginalLine = mapping.originalLine - 1;
                next += base64Vlq.encode(mapping.originalColumn
                    - previousOriginalColumn);
                previousOriginalColumn = mapping.originalColumn;
                if (mapping.name != null) {
                    nameIdx = this._names.indexOf(mapping.name);
                    next += base64Vlq.encode(nameIdx - previousName);
                    previousName = nameIdx;
                }
            }
            result += next;
        }
        return result;
    };
SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
            if (!this._sourcesContents) {
                return null;
            }
            if (aSourceRoot != null) {
                source = util$1.relative(aSourceRoot, source);
            }
            var key = util$1.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
                ? this._sourcesContents[key]
                : null;
        }, this);
    };
/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
        var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
        };
        if (this._file != null) {
            map.file = this._file;
        }
        if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
    };
/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
    };
var SourceMapGenerator_1 = SourceMapGenerator;
var sourceMapGenerator = {
    SourceMapGenerator: SourceMapGenerator_1
};

var binarySearch = createCommonjsModule(function (module, exports) {
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the index of
        //      the next-closest element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element than the one we are searching for, so we return -1.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
            // Found the element we are looking for.
            return mid;
        }
        else if (cmp > 0) {
            // Our needle is greater than aHaystack[mid].
            if (aHigh - mid > 1) {
                // The element is in the upper half.
                return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
            }
            // The exact needle element was not found in this haystack. Determine if
            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
                return aHigh < aHaystack.length ? aHigh : -1;
            }
            else {
                return mid;
            }
        }
        else {
            // Our needle is less than aHaystack[mid].
            if (mid - aLow > 1) {
                // The element is in the lower half.
                return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
            }
            // we are in termination case (3) or (2) and return the appropriate thing.
            if (aBias == exports.LEAST_UPPER_BOUND) {
                return mid;
            }
            else {
                return aLow < 0 ? -1 : aLow;
            }
        }
    }
    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
            return -1;
        }
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) {
            return -1;
        }
        // We have found either the exact element, or the next-closest element than
        // the one we are searching for. However, there may be more than one such
        // element. Make sure we always return the smallest of these.
        while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                break;
            }
            --index;
        }
        return index;
    };
});

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.
    if (p < r) {
        // (1) Partitioning.
        //
        // The partitioning chooses a pivot between `p` and `r` and moves all
        // elements that are less than or equal to the pivot to the before it, and
        // all the elements that are greater than it after it. The effect is that
        // once partition is done, the pivot is in the exact place it will be when
        // the array is put in sorted order, and it will not need to be moved
        // again. This runs in O(n) time.
        // Always choose a random pivot so that an input array which is reverse
        // sorted does not cause O(n^2) running time.
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        // Immediately after `j` is incremented in this loop, the following hold
        // true:
        //
        //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
        //
        //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
        for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
                i += 1;
                swap(ary, i, j);
            }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        // (2) Recurse on each half.
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
    }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
};
var quickSort = {
    quickSort: quickSort_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var ArraySet$2 = arraySet.ArraySet;
var quickSort$1 = quickSort.quickSort;
function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    return sourceMap.sections != null
        ? new IndexedSourceMapConsumer(sourceMap)
        : new BasicSourceMapConsumer(sourceMap);
}
SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
};
/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;
// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
    };
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
    };
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
            case SourceMapConsumer.GENERATED_ORDER:
                mappings = this._generatedMappings;
                break;
            case SourceMapConsumer.ORIGINAL_ORDER:
                mappings = this._originalMappings;
                break;
            default:
                throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            if (source != null && sourceRoot != null) {
                source = util$1.join(sourceRoot, source);
            }
            return {
                source: source,
                generatedLine: mapping.generatedLine,
                generatedColumn: mapping.generatedColumn,
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: mapping.name === null ? null : this._names.at(mapping.name)
            };
        }, this).forEach(aCallback, context);
    };
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util$1.getArg(aArgs, 'line');
        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
        // returns the index of the closest mapping less than the needle. By
        // setting needle.originalColumn to 0, we thus find the last mapping for
        // the given line, provided such a mapping exists.
        var needle = {
            source: util$1.getArg(aArgs, 'source'),
            originalLine: line,
            originalColumn: util$1.getArg(aArgs, 'column', 0)
        };
        if (this.sourceRoot != null) {
            needle.source = util$1.relative(this.sourceRoot, needle.source);
        }
        if (!this._sources.has(needle.source)) {
            return [];
        }
        needle.source = this._sources.indexOf(needle.source);
        var mappings = [];
        var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
        if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (aArgs.column === undefined) {
                var originalLine = mapping.originalLine;
                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we found. Since
                // mappings are sorted, this is guaranteed to find all mappings for
                // the line we found.
                while (mapping && mapping.originalLine === originalLine) {
                    mappings.push({
                        line: util$1.getArg(mapping, 'generatedLine', null),
                        column: util$1.getArg(mapping, 'generatedColumn', null),
                        lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
                    });
                    mapping = this._originalMappings[++index];
                }
            }
            else {
                var originalColumn = mapping.originalColumn;
                // Iterate until either we run out of mappings, or we run into
                // a mapping for a different line than the one we were searching for.
                // Since mappings are sorted, this is guaranteed to find all mappings for
                // the line we are searching for.
                while (mapping &&
                    mapping.originalLine === line &&
                    mapping.originalColumn == originalColumn) {
                    mappings.push({
                        line: util$1.getArg(mapping, 'generatedLine', null),
                        column: util$1.getArg(mapping, 'generatedColumn', null),
                        lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
                    });
                    mapping = this._originalMappings[++index];
                }
            }
        }
        return mappings;
    };
var SourceMapConsumer_1 = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    var version = util$1.getArg(sourceMap, 'version');
    var sources = util$1.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util$1.getArg(sourceMap, 'names', []);
    var sourceRoot = util$1.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util$1.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util$1.getArg(sourceMap, 'mappings');
    var file = util$1.getArg(sourceMap, 'file', null);
    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util$1.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function (source) {
        return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source)
            ? util$1.relative(sourceRoot, source)
            : source;
    });
    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet$2.fromArray(names.map(String), true);
    this._sources = ArraySet$2.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
        smc.file = aSourceMap._file;
        // Because we are modifying the entries (by converting string sources and
        // names to indices into the sources and names ArraySets), we have to make
        // a copy of the entry or else bad things happen. Shared mutable state
        // strikes again! See github issue #191.
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i];
            var destMapping = new Mapping;
            destMapping.generatedLine = srcMapping.generatedLine;
            destMapping.generatedColumn = srcMapping.generatedColumn;
            if (srcMapping.source) {
                destMapping.source = sources.indexOf(srcMapping.source);
                destMapping.originalLine = srcMapping.originalLine;
                destMapping.originalColumn = srcMapping.originalColumn;
                if (srcMapping.name) {
                    destMapping.name = names.indexOf(srcMapping.name);
                }
                destOriginalMappings.push(destMapping);
            }
            destGeneratedMappings.push(destMapping);
        }
        quickSort$1(smc.__originalMappings, util$1.compareByOriginalPositions);
        return smc;
    };
/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
        return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util$1.join(this.sourceRoot, s) : s;
        }, this);
    }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
            if (aStr.charAt(index) === ';') {
                generatedLine++;
                index++;
                previousGeneratedColumn = 0;
            }
            else if (aStr.charAt(index) === ',') {
                index++;
            }
            else {
                mapping = new Mapping();
                mapping.generatedLine = generatedLine;
                // Because each offset is encoded relative to the previous one,
                // many segments often have the same encoding. We can exploit this
                // fact by caching the parsed variable length fields of each segment,
                // allowing us to avoid a second parse if we encounter the same
                // segment again.
                for (end = index; end < length; end++) {
                    if (this._charIsMappingSeparator(aStr, end)) {
                        break;
                    }
                }
                str = aStr.slice(index, end);
                segment = cachedSegments[str];
                if (segment) {
                    index += str.length;
                }
                else {
                    segment = [];
                    while (index < end) {
                        base64Vlq.decode(aStr, index, temp);
                        value = temp.value;
                        index = temp.rest;
                        segment.push(value);
                    }
                    if (segment.length === 2) {
                        throw new Error('Found a source, but no line and column');
                    }
                    if (segment.length === 3) {
                        throw new Error('Found a source and line, but no column');
                    }
                    cachedSegments[str] = segment;
                }
                // Generated column.
                mapping.generatedColumn = previousGeneratedColumn + segment[0];
                previousGeneratedColumn = mapping.generatedColumn;
                if (segment.length > 1) {
                    // Original source.
                    mapping.source = previousSource + segment[1];
                    previousSource += segment[1];
                    // Original line.
                    mapping.originalLine = previousOriginalLine + segment[2];
                    previousOriginalLine = mapping.originalLine;
                    // Lines are stored 0-based
                    mapping.originalLine += 1;
                    // Original column.
                    mapping.originalColumn = previousOriginalColumn + segment[3];
                    previousOriginalColumn = mapping.originalColumn;
                    if (segment.length > 4) {
                        // Original name.
                        mapping.name = previousName + segment[4];
                        previousName += segment[4];
                    }
                }
                generatedMappings.push(mapping);
                if (typeof mapping.originalLine === 'number') {
                    originalMappings.push(mapping);
                }
            }
        }
        quickSort$1(generatedMappings, util$1.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort$1(originalMappings, util$1.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
    };
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        // To return the position we are searching for, we must first find the
        // mapping for the given position and then return the opposite position it
        // points to. Because the mappings are sorted, we can use binary search to
        // find the best mapping.
        if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
            // Mappings do not contain a field for the last generated columnt. We
            // can come up with an optimistic estimate, however, by assuming that
            // mappings are contiguous (i.e. given two consecutive mappings, the
            // first mapping ends where the second one starts).
            if (index + 1 < this._generatedMappings.length) {
                var nextMapping = this._generatedMappings[index + 1];
                if (mapping.generatedLine === nextMapping.generatedLine) {
                    mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                    continue;
                }
            }
            // The last mapping for each line spans the entire line.
            mapping.lastGeneratedColumn = Infinity;
        }
    };
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
            generatedLine: util$1.getArg(aArgs, 'line'),
            generatedColumn: util$1.getArg(aArgs, 'column')
        };
        var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
            var mapping = this._generatedMappings[index];
            if (mapping.generatedLine === needle.generatedLine) {
                var source = util$1.getArg(mapping, 'source', null);
                if (source !== null) {
                    source = this._sources.at(source);
                    if (this.sourceRoot != null) {
                        source = util$1.join(this.sourceRoot, source);
                    }
                }
                var name = util$1.getArg(mapping, 'name', null);
                if (name !== null) {
                    name = this._names.at(name);
                }
                return {
                    source: source,
                    line: util$1.getArg(mapping, 'originalLine', null),
                    column: util$1.getArg(mapping, 'originalColumn', null),
                    name: name
                };
            }
        }
        return {
            source: null,
            line: null,
            column: null,
            name: null
        };
    };
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
            return false;
        }
        return this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (sc) { return sc == null; });
    };
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
            return null;
        }
        if (this.sourceRoot != null) {
            aSource = util$1.relative(this.sourceRoot, aSource);
        }
        if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
        }
        var url;
        if (this.sourceRoot != null
            && (url = util$1.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
                return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            }
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
                return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
        }
        // This function is used recursively from
        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
        // don't want to throw if we can't find the source - we just want to
        // return null, so we provide a flag to exit gracefully.
        if (nullOnMissing) {
            return null;
        }
        else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
    };
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util$1.getArg(aArgs, 'source');
        if (this.sourceRoot != null) {
            source = util$1.relative(this.sourceRoot, source);
        }
        if (!this._sources.has(source)) {
            return {
                line: null,
                column: null,
                lastColumn: null
            };
        }
        source = this._sources.indexOf(source);
        var needle = {
            source: source,
            originalLine: util$1.getArg(aArgs, 'line'),
            originalColumn: util$1.getArg(aArgs, 'column')
        };
        var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (mapping.source === needle.source) {
                return {
                    line: util$1.getArg(mapping, 'generatedLine', null),
                    column: util$1.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
                };
            }
        }
        return {
            line: null,
            column: null,
            lastColumn: null
        };
    };
var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }
    var version = util$1.getArg(sourceMap, 'version');
    var sections = util$1.getArg(sourceMap, 'sections');
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet$2();
    this._names = new ArraySet$2();
    var lastOffset = {
        line: -1,
        column: 0
    };
    this._sections = sections.map(function (s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util$1.getArg(s, 'offset');
        var offsetLine = util$1.getArg(offset, 'line');
        var offsetColumn = util$1.getArg(offset, 'column');
        if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util$1.getArg(s, 'map'))
        };
    });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
            generatedLine: util$1.getArg(aArgs, 'line'),
            generatedColumn: util$1.getArg(aArgs, 'column')
        };
        // Find the section containing the generated position we're trying to map
        // to an original position.
        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
            if (cmp) {
                return cmp;
            }
            return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
        });
        var section = this._sections[sectionIndex];
        if (!section) {
            return {
                source: null,
                line: null,
                column: null,
                name: null
            };
        }
        return section.consumer.originalPositionFor({
            line: needle.generatedLine -
                (section.generatedOffset.generatedLine - 1),
            column: needle.generatedColumn -
                (section.generatedOffset.generatedLine === needle.generatedLine
                    ? section.generatedOffset.generatedColumn - 1
                    : 0),
            bias: aArgs.bias
        });
    };
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function (s) {
            return s.consumer.hasContentsOfAllSources();
        });
    };
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
                return content;
            }
        }
        if (nullOnMissing) {
            return null;
        }
        else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
    };
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            // Only consider this section if the requested source is in the list of
            // sources of the consumer.
            if (section.consumer.sources.indexOf(util$1.getArg(aArgs, 'source')) === -1) {
                continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
                var ret = {
                    line: generatedPosition.line +
                        (section.generatedOffset.generatedLine - 1),
                    column: generatedPosition.column +
                        (section.generatedOffset.generatedLine === generatedPosition.line
                            ? section.generatedOffset.generatedColumn - 1
                            : 0)
                };
                return ret;
            }
        }
        return {
            line: null,
            column: null
        };
    };
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
                var mapping = sectionMappings[j];
                var source = section.consumer._sources.at(mapping.source);
                if (section.consumer.sourceRoot !== null) {
                    source = util$1.join(section.consumer.sourceRoot, source);
                }
                this._sources.add(source);
                source = this._sources.indexOf(source);
                var name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
                // The mappings coming from the consumer for the section have
                // generated positions relative to the start of the section, so we
                // need to offset them to be relative to the start of the concatenated
                // generated file.
                var adjustedMapping = {
                    source: source,
                    generatedLine: mapping.generatedLine +
                        (section.generatedOffset.generatedLine - 1),
                    generatedColumn: mapping.generatedColumn +
                        (section.generatedOffset.generatedLine === mapping.generatedLine
                            ? section.generatedOffset.generatedColumn - 1
                            : 0),
                    originalLine: mapping.originalLine,
                    originalColumn: mapping.originalColumn,
                    name: name
                };
                this.__generatedMappings.push(adjustedMapping);
                if (typeof adjustedMapping.originalLine === 'number') {
                    this.__originalMappings.push(adjustedMapping);
                }
            }
        }
        quickSort$1(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
        quickSort$1(this.__originalMappings, util$1.compareByOriginalPositions);
    };
var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
var sourceMapConsumer = {
    SourceMapConsumer: SourceMapConsumer_1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
};

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;
// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;
// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
        this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        // The SourceNode we want to fill with the generated code
        // and the SourceMap
        var node = new SourceNode();
        // All even indices of this array are one line of the generated code,
        // while all odd indices are the newlines between two adjacent lines
        // (since `REGEX_NEWLINE` captures its match).
        // Processed fragments are accessed by calling `shiftNextLine`.
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function () {
            var lineContents = getNextLine();
            // The last line of a file might not have a newline.
            var newLine = getNextLine() || "";
            return lineContents + newLine;
            function getNextLine() {
                return remainingLinesIndex < remainingLines.length ?
                    remainingLines[remainingLinesIndex++] : undefined;
            }
        };
        // We need to remember the position of "remainingLines"
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        // The generate SourceNodes we need a code range.
        // To extract it current and last mapping is used.
        // Here we store the last mapping.
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
                // We add the code from "lastMapping" to "mapping":
                // First check if there is a new line in between.
                if (lastGeneratedLine < mapping.generatedLine) {
                    // Associate first line with "lastMapping"
                    addMappingWithCode(lastMapping, shiftNextLine());
                    lastGeneratedLine++;
                    lastGeneratedColumn = 0;
                    // The remaining code is added without mapping
                }
                else {
                    // There is no new line in between.
                    // Associate the code between "lastGeneratedColumn" and
                    // "mapping.generatedColumn" with "lastMapping"
                    var nextLine = remainingLines[remainingLinesIndex];
                    var code = nextLine.substr(0, mapping.generatedColumn -
                        lastGeneratedColumn);
                    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                        lastGeneratedColumn);
                    lastGeneratedColumn = mapping.generatedColumn;
                    addMappingWithCode(lastMapping, code);
                    // No more remaining code, continue
                    lastMapping = mapping;
                    return;
                }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
                node.add(shiftNextLine());
                lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
                var nextLine = remainingLines[remainingLinesIndex];
                node.add(nextLine.substr(0, mapping.generatedColumn));
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
        }, this);
        // We have processed all mappings.
        if (remainingLinesIndex < remainingLines.length) {
            if (lastMapping) {
                // Associate the remaining code in the current line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        // Copy sourcesContent into SourceNode
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
                if (aRelativePath != null) {
                    sourceFile = util$1.join(aRelativePath, sourceFile);
                }
                node.setSourceContent(sourceFile, content);
            }
        });
        return node;
        function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
                node.add(code);
            }
            else {
                var source = aRelativePath
                    ? util$1.join(aRelativePath, mapping.source)
                    : mapping.source;
                node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
            }
        }
    };
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
        aChunk.forEach(function (chunk) {
            this.add(chunk);
        }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
            this.children.push(aChunk);
        }
    }
    else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
        }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
    }
    else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
            chunk.walk(aFn);
        }
        else {
            if (chunk !== '') {
                aFn(chunk, { source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name });
            }
        }
    }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
    }
    return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
        this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util$1.toSetString(aSourceFile)] = aSourceContent;
    };
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
                this.children[i].walkSourceContents(aFn);
            }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util$1.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
    };
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
        str += chunk;
    });
    return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
        generated.code += chunk;
        if (original.source !== null
            && original.line !== null
            && original.column !== null) {
            if (lastOriginalSource !== original.source
                || lastOriginalLine !== original.line
                || lastOriginalColumn !== original.column
                || lastOriginalName !== original.name) {
                map.addMapping({
                    source: original.source,
                    original: {
                        line: original.line,
                        column: original.column
                    },
                    generated: {
                        line: generated.line,
                        column: generated.column
                    },
                    name: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
        }
        else if (sourceMappingActive) {
            map.addMapping({
                generated: {
                    line: generated.line,
                    column: generated.column
                }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                // Mappings end at eol
                if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                }
                else if (sourceMappingActive) {
                    map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                }
            }
            else {
                generated.column++;
            }
        }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map };
};
var SourceNode_1 = SourceNode;
var sourceNode = {
    SourceNode: SourceNode_1
};

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
var SourceNode$1 = sourceNode.SourceNode;
var sourceMap = {
    SourceMapGenerator: SourceMapGenerator$2,
    SourceMapConsumer: SourceMapConsumer$1,
    SourceNode: SourceNode$1
};

var sourceMapUrl = createCommonjsModule(function (module, exports) {
    // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    void (function (root, factory) {
        {
            module.exports = factory();
        }
    }(commonjsGlobal, function () {
        var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/;
        var regex = RegExp("(?:" +
            "/\\*" +
            "(?:\\s*\r?\n(?://)?)?" +
            "(?:" + innerRegex.source + ")" +
            "\\s*" +
            "\\*/" +
            "|" +
            "//(?:" + innerRegex.source + ")" +
            ")" +
            "\\s*");
        return {
            regex: regex,
            _innerRegex: innerRegex,
            getFrom: function (code) {
                var match = code.match(regex);
                return (match ? match[1] || match[2] || "" : null);
            },
            existsIn: function (code) {
                return regex.test(code);
            },
            removeFrom: function (code) {
                return code.replace(regex, "");
            },
            insertBefore: function (code, string) {
                var match = code.match(regex);
                if (match) {
                    return code.slice(0, match.index) + string + code.slice(match.index);
                }
                else {
                    return code + string;
                }
            }
        };
    }));
});

// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)
function resolveUrl( /* ...urls */) {
    return Array.prototype.reduce.call(arguments, function (resolved, nextUrl) {
        return url.resolve(resolved, nextUrl);
    });
}
var resolveUrl_1 = resolveUrl;

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return decodeURIComponent(components.join(''));
    }
    catch (err) {
        // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode$3(input) {
    try {
        return decodeURIComponent(input);
    }
    catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher);
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while (match) {
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        }
        catch (err) {
            var result = decode$3(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
var decodeUriComponent = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    }
    catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};

// Copyright 2017 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)
function customDecodeUriComponent(string) {
    // `decodeUriComponent` turns `+` into ` `, but that's not wanted.
    return decodeUriComponent(string.replace(/\+/g, "%2B"));
}
var decodeUriComponent_1 = customDecodeUriComponent;

function urix(aPath) {
    if (path.sep === "\\") {
        return aPath
            .replace(/\\/g, "/")
            .replace(/^[a-z]:\/?/i, "/");
    }
    return aPath;
}
var urix_1 = urix;

function atob(str) {
    return Buffer.from(str, 'base64').toString('binary');
}
var nodeAtob = atob.atob = atob;

// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)
function callbackAsync(callback, error, result) {
    setImmediate(function () { callback(error, result); });
}
function parseMapToJSON(string, data) {
    try {
        return JSON.parse(string.replace(/^\)\]\}'/, ""));
    }
    catch (error) {
        error.sourceMapData = data;
        throw error;
    }
}
function readSync(read, url, data) {
    var readUrl = decodeUriComponent_1(url);
    try {
        return String(read(readUrl));
    }
    catch (error) {
        error.sourceMapData = data;
        throw error;
    }
}
function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData;
    try {
        mapData = resolveSourceMapHelper(code, codeUrl);
    }
    catch (error) {
        return callbackAsync(callback, error);
    }
    if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData);
    }
    var readUrl = decodeUriComponent_1(mapData.url);
    read(readUrl, function (error, result) {
        if (error) {
            error.sourceMapData = mapData;
            return callback(error);
        }
        mapData.map = String(result);
        try {
            mapData.map = parseMapToJSON(mapData.map, mapData);
        }
        catch (error) {
            return callback(error);
        }
        callback(null, mapData);
    });
}
function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl);
    if (!mapData || mapData.map) {
        return mapData;
    }
    mapData.map = readSync(read, mapData.url, mapData);
    mapData.map = parseMapToJSON(mapData.map, mapData);
    return mapData;
}
var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;
var jsonMimeTypeRegex = /^(?:application|text)\/json$/;
function resolveSourceMapHelper(code, codeUrl) {
    codeUrl = urix_1(codeUrl);
    var url = sourceMapUrl.getFrom(code);
    if (!url) {
        return null;
    }
    var dataUri = url.match(dataUriRegex);
    if (dataUri) {
        var mimeType = dataUri[1];
        var lastParameter = dataUri[2] || "";
        var encoded = dataUri[3] || "";
        var data = {
            sourceMappingURL: url,
            url: null,
            sourcesRelativeTo: codeUrl,
            map: encoded
        };
        if (!jsonMimeTypeRegex.test(mimeType)) {
            var error = new Error("Unuseful data uri mime type: " + (mimeType || "text/plain"));
            error.sourceMapData = data;
            throw error;
        }
        data.map = parseMapToJSON(lastParameter === ";base64" ? nodeAtob(encoded) : decodeURIComponent(encoded), data);
        return data;
    }
    var mapUrl = resolveUrl_1(codeUrl, url);
    return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
    };
}
function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    var pending = map.sources ? map.sources.length : 0;
    var result = {
        sourcesResolved: [],
        sourcesContent: []
    };
    if (pending === 0) {
        callbackAsync(callback, null, result);
        return;
    }
    var done = function () {
        pending--;
        if (pending === 0) {
            callback(null, result);
        }
    };
    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent;
            callbackAsync(done, null);
        }
        else {
            var readUrl = decodeUriComponent_1(fullUrl);
            read(readUrl, function (error, source) {
                result.sourcesContent[index] = error ? error : String(source);
                done();
            });
        }
    });
}
function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
        sourcesResolved: [],
        sourcesContent: []
    };
    if (!map.sources || map.sources.length === 0) {
        return result;
    }
    resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl;
        if (read !== null) {
            if (typeof sourceContent === "string") {
                result.sourcesContent[index] = sourceContent;
            }
            else {
                var readUrl = decodeUriComponent_1(fullUrl);
                try {
                    result.sourcesContent[index] = String(read(readUrl));
                }
                catch (error) {
                    result.sourcesContent[index] = error;
                }
            }
        }
    });
    return result;
}
var endingSlash = /\/?$/;
function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {};
    mapUrl = urix_1(mapUrl);
    var fullUrl;
    var sourceContent;
    var sourceRoot;
    for (var index = 0, len = map.sources.length; index < len; index++) {
        sourceRoot = null;
        if (typeof options.sourceRoot === "string") {
            sourceRoot = options.sourceRoot;
        }
        else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
            sourceRoot = map.sourceRoot;
        }
        // If the sourceRoot is the empty string, it is equivalent to not setting
        // the property at all.
        if (sourceRoot === null || sourceRoot === '') {
            fullUrl = resolveUrl_1(mapUrl, map.sources[index]);
        }
        else {
            // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
            // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
            // does not make sense.
            fullUrl = resolveUrl_1(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index]);
        }
        sourceContent = (map.sourcesContent || [])[index];
        fn(fullUrl, sourceContent, index);
    }
}
function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (code === null) {
        var mapUrl = codeUrl;
        var data = {
            sourceMappingURL: null,
            url: mapUrl,
            sourcesRelativeTo: mapUrl,
            map: null
        };
        var readUrl = decodeUriComponent_1(mapUrl);
        read(readUrl, function (error, result) {
            if (error) {
                error.sourceMapData = data;
                return callback(error);
            }
            data.map = String(result);
            try {
                data.map = parseMapToJSON(data.map, data);
            }
            catch (error) {
                return callback(error);
            }
            _resolveSources(data);
        });
    }
    else {
        resolveSourceMap(code, codeUrl, read, function (error, mapData) {
            if (error) {
                return callback(error);
            }
            if (!mapData) {
                return callback(null, null);
            }
            _resolveSources(mapData);
        });
    }
    function _resolveSources(mapData) {
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {
            if (error) {
                return callback(error);
            }
            mapData.sourcesResolved = result.sourcesResolved;
            mapData.sourcesContent = result.sourcesContent;
            callback(null, mapData);
        });
    }
}
function resolveSync(code, codeUrl, read, options) {
    var mapData;
    if (code === null) {
        var mapUrl = codeUrl;
        mapData = {
            sourceMappingURL: null,
            url: mapUrl,
            sourcesRelativeTo: mapUrl,
            map: null
        };
        mapData.map = readSync(read, mapUrl, mapData);
        mapData.map = parseMapToJSON(mapData.map, mapData);
    }
    else {
        mapData = resolveSourceMapSync(code, codeUrl, read);
        if (!mapData) {
            return null;
        }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);
    mapData.sourcesResolved = result.sourcesResolved;
    mapData.sourcesContent = result.sourcesContent;
    return mapData;
}
var sourceMapResolveNode = {
    resolveSourceMap: resolveSourceMap,
    resolveSourceMapSync: resolveSourceMapSync,
    resolveSources: resolveSources,
    resolveSourcesSync: resolveSourcesSync,
    resolve: resolve,
    resolveSync: resolveSync,
    parseMapToJSON: parseMapToJSON
};

/**
 * Module dependencies
 */
var extend$1 = extendShallow$5;
var SourceMap$1 = sourceMap;
var sourceMapResolve = sourceMapResolveNode;
/**
 * Convert backslash in the given string to forward slashes
 */
var unixify = function (fp) {
    return fp.split(/\\+/).join('/');
};
/**
 * Return true if `val` is a non-empty string
 *
 * @param {String} `str`
 * @return {Boolean}
 */
var isString$1 = function (str) {
    return str && typeof str === 'string';
};
/**
 * Cast `val` to an array
 * @return {Array}
 */
var arrayify$3 = function (val) {
    if (typeof val === 'string')
        return [val];
    return val ? (Array.isArray(val) ? val : [val]) : [];
};
/**
 * Get the last `n` element from the given `array`
 * @param {Array} `array`
 * @return {*}
 */
var last = function (arr, n) {
    return arr[arr.length - (n || 1)];
};
var utils$1 = {
    extend: extend$1,
    SourceMap: SourceMap$1,
    sourceMapResolve: sourceMapResolve,
    unixify: unixify,
    isString: isString$1,
    arrayify: arrayify$3,
    last: last
};

var sourceMaps = createCommonjsModule(function (module, exports) {
    /**
     * Expose `mixin()`.
     * This code is based on `source-maps-support.js` in reworkcss/css
     * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
     * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
     */
    module.exports = mixin;
    /**
     * Mixin source map support into `compiler`.
     *
     * @param {Object} `compiler`
     * @api public
     */
    function mixin(compiler) {
        defineProperty$6(compiler, '_comment', compiler.comment);
        compiler.map = new utils$1.SourceMap.SourceMapGenerator();
        compiler.position = { line: 1, column: 1 };
        compiler.content = {};
        compiler.files = {};
        for (var key in exports) {
            defineProperty$6(compiler, key, exports[key]);
        }
    }
    /**
     * Update position.
     *
     * @param {String} str
     */
    exports.updatePosition = function (str) {
        var lines = str.match(/\n/g);
        if (lines)
            this.position.line += lines.length;
        var i = str.lastIndexOf('\n');
        this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    /**
     * Emit `str` with `position`.
     *
     * @param {String} str
     * @param {Object} [pos]
     * @return {String}
     */
    exports.emit = function (str, node) {
        var position = node.position || {};
        var source = position.source;
        if (source) {
            if (position.filepath) {
                source = utils$1.unixify(position.filepath);
            }
            this.map.addMapping({
                source: source,
                generated: {
                    line: this.position.line,
                    column: Math.max(this.position.column - 1, 0)
                },
                original: {
                    line: position.start.line,
                    column: position.start.column - 1
                }
            });
            if (position.content) {
                this.addContent(source, position);
            }
            if (position.filepath) {
                this.addFile(source, position);
            }
            this.updatePosition(str);
            this.output += str;
        }
        return str;
    };
    /**
     * Adds a file to the source map output if it has not already been added
     * @param {String} `file`
     * @param {Object} `pos`
     */
    exports.addFile = function (file, position) {
        if (typeof position.content !== 'string')
            return;
        if (Object.prototype.hasOwnProperty.call(this.files, file))
            return;
        this.files[file] = position.content;
    };
    /**
     * Adds a content source to the source map output if it has not already been added
     * @param {String} `source`
     * @param {Object} `position`
     */
    exports.addContent = function (source, position) {
        if (typeof position.content !== 'string')
            return;
        if (Object.prototype.hasOwnProperty.call(this.content, source))
            return;
        this.map.setSourceContent(source, position.content);
    };
    /**
     * Applies any original source maps to the output and embeds the source file
     * contents in the source map.
     */
    exports.applySourceMaps = function () {
        Object.keys(this.files).forEach(function (file) {
            var content = this.files[file];
            this.map.setSourceContent(file, content);
            if (this.options.inputSourcemaps === true) {
                var originalMap = utils$1.sourceMapResolve.resolveSync(content, file, fs__default.readFileSync);
                if (originalMap) {
                    var map = new utils$1.SourceMap.SourceMapConsumer(originalMap.map);
                    var relativeTo = originalMap.sourcesRelativeTo;
                    this.map.applySourceMap(map, file, utils$1.unixify(path.dirname(relativeTo)));
                }
            }
        }, this);
    };
    /**
     * Process comments, drops sourceMap comments.
     * @param {Object} node
     */
    exports.comment = function (node) {
        if (/^# sourceMappingURL=/.test(node.comment)) {
            return this.emit('', node.position);
        }
        return this._comment(node);
    };
});

var debug$1 = src('snapdragon:compiler');
/**
 * Create a new `Compiler` with the given `options`.
 * @param {Object} `options`
 */
function Compiler(options, state) {
    debug$1('initializing', __filename);
    this.options = utils$1.extend({ source: 'string' }, options);
    this.state = state || {};
    this.compilers = {};
    this.output = '';
    this.set('eos', function (node) {
        return this.emit(node.val, node);
    });
    this.set('noop', function (node) {
        return this.emit(node.val, node);
    });
    this.set('bos', function (node) {
        return this.emit(node.val, node);
    });
    use(this);
}
/**
 * Prototype methods
 */
Compiler.prototype = {
    /**
     * Throw an error message with details including the cursor position.
     * @param {String} `msg` Message to use in the Error.
     */
    error: function (msg, node) {
        var pos = node.position || { start: { column: 0 } };
        var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;
        var err = new Error(message);
        err.reason = msg;
        err.column = pos.start.column;
        err.source = this.pattern;
        if (this.options.silent) {
            this.errors.push(err);
        }
        else {
            throw err;
        }
    },
    /**
     * Define a non-enumberable property on the `Compiler` instance.
     *
     * ```js
     * compiler.define('foo', 'bar');
     * ```
     * @name .define
     * @param {String} `key` propery name
     * @param {any} `val` property value
     * @return {Object} Returns the Compiler instance for chaining.
     * @api public
     */
    define: function (key, val) {
        defineProperty$6(this, key, val);
        return this;
    },
    /**
     * Emit `node.val`
     */
    emit: function (str, node) {
        this.output += str;
        return str;
    },
    /**
     * Add a compiler `fn` with the given `name`
     */
    set: function (name, fn) {
        this.compilers[name] = fn;
        return this;
    },
    /**
     * Get compiler `name`.
     */
    get: function (name) {
        return this.compilers[name];
    },
    /**
     * Get the previous AST node.
     */
    prev: function (n) {
        return this.ast.nodes[this.idx - (n || 1)] || { type: 'bos', val: '' };
    },
    /**
     * Get the next AST node.
     */
    next: function (n) {
        return this.ast.nodes[this.idx + (n || 1)] || { type: 'eos', val: '' };
    },
    /**
     * Visit `node`.
     */
    visit: function (node, nodes, i) {
        var fn = this.compilers[node.type];
        this.idx = i;
        if (typeof fn !== 'function') {
            throw this.error('compiler "' + node.type + '" is not registered', node);
        }
        return fn.call(this, node, nodes, i);
    },
    /**
     * Map visit over array of `nodes`.
     */
    mapVisit: function (nodes) {
        if (!Array.isArray(nodes)) {
            throw new TypeError('expected an array');
        }
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
            this.visit(nodes[idx], nodes, idx);
        }
        return this;
    },
    /**
     * Compile `ast`.
     */
    compile: function (ast, options) {
        var opts = utils$1.extend({}, this.options, options);
        this.ast = ast;
        this.parsingErrors = this.ast.errors;
        this.output = '';
        // source map support
        if (opts.sourcemap) {
            var sourcemaps = sourceMaps;
            sourcemaps(this);
            this.mapVisit(this.ast.nodes);
            this.applySourceMaps();
            this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
            return this;
        }
        this.mapVisit(this.ast.nodes);
        return this;
    }
};
/**
 * Expose `Compiler`
 */
var compiler = Compiler;

/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var hasOwn$6 = Object.prototype.hasOwnProperty;
/**
 * Expose `MapCache`
 */
var mapCache = MapCache;
/**
 * Creates a cache object to store key/value pairs.
 *
 * ```js
 * var cache = new MapCache();
 * ```
 *
 * @api public
 */
function MapCache(data) {
    this.__data__ = data || {};
}
/**
 * Adds `value` to `key` on the cache.
 *
 * ```js
 * cache.set('foo', 'bar');
 * ```
 *
 * @param {String} `key` The key of the value to cache.
 * @param {*} `value` The value to cache.
 * @returns {Object} Returns the `Cache` object for chaining.
 * @api public
 */
MapCache.prototype.set = function mapSet(key, value) {
    if (key !== '__proto__') {
        this.__data__[key] = value;
    }
    return this;
};
/**
 * Gets the cached value for `key`.
 *
 * ```js
 * cache.get('foo');
 * //=> 'bar'
 * ```
 *
 * @param {String} `key` The key of the value to get.
 * @returns {*} Returns the cached value.
 * @api public
 */
MapCache.prototype.get = function mapGet(key) {
    return key === '__proto__' ? undefined : this.__data__[key];
};
/**
 * Checks if a cached value for `key` exists.
 *
 * ```js
 * cache.has('foo');
 * //=> true
 * ```
 *
 * @param {String} `key` The key of the entry to check.
 * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
 * @api public
 */
MapCache.prototype.has = function mapHas(key) {
    return key !== '__proto__' && hasOwn$6.call(this.__data__, key);
};
/**
 * Removes `key` and its value from the cache.
 *
 * ```js
 * cache.del('foo');
 * ```
 * @title .del
 * @param {String} `key` The key of the value to remove.
 * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
 * @api public
 */
MapCache.prototype.del = function mapDelete(key) {
    return this.has(key) && delete this.__data__[key];
};

/**
 * Store position for a node
 */
var position = function Position(start, parser) {
    this.start = start;
    this.end = { line: parser.line, column: parser.column };
    defineProperty$6(this, 'content', parser.orig);
    defineProperty$6(this, 'source', parser.options.source);
};

var debug$2 = src('snapdragon:parser');
/**
 * Create a new `Parser` with the given `input` and `options`.
 * @param {String} `input`
 * @param {Object} `options`
 * @api public
 */
function Parser(options) {
    debug$2('initializing', __filename);
    this.options = utils$1.extend({ source: 'string' }, options);
    this.init(this.options);
    use(this);
}
/**
 * Prototype methods
 */
Parser.prototype = {
    constructor: Parser,
    init: function (options) {
        this.orig = '';
        this.input = '';
        this.parsed = '';
        this.column = 1;
        this.line = 1;
        this.regex = new mapCache();
        this.errors = this.errors || [];
        this.parsers = this.parsers || {};
        this.types = this.types || [];
        this.sets = this.sets || {};
        this.fns = this.fns || [];
        this.currentType = 'root';
        var pos = this.position();
        this.bos = pos({ type: 'bos', val: '' });
        this.ast = {
            type: 'root',
            errors: this.errors,
            nodes: [this.bos]
        };
        defineProperty$6(this.bos, 'parent', this.ast);
        this.nodes = [this.ast];
        this.count = 0;
        this.setCount = 0;
        this.stack = [];
    },
    /**
     * Throw a formatted error with the cursor column and `msg`.
     * @param {String} `msg` Message to use in the Error.
     */
    error: function (msg, node) {
        var pos = node.position || { start: { column: 0, line: 0 } };
        var line = pos.start.line;
        var column = pos.start.column;
        var source = this.options.source;
        var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
        var err = new Error(message);
        err.source = source;
        err.reason = msg;
        err.pos = pos;
        if (this.options.silent) {
            this.errors.push(err);
        }
        else {
            throw err;
        }
    },
    /**
     * Define a non-enumberable property on the `Parser` instance.
     *
     * ```js
     * parser.define('foo', 'bar');
     * ```
     * @name .define
     * @param {String} `key` propery name
     * @param {any} `val` property value
     * @return {Object} Returns the Parser instance for chaining.
     * @api public
     */
    define: function (key, val) {
        defineProperty$6(this, key, val);
        return this;
    },
    /**
     * Mark position and patch `node.position`.
     */
    position: function () {
        var start = { line: this.line, column: this.column };
        var self = this;
        return function (node) {
            defineProperty$6(node, 'position', new position(start, self));
            return node;
        };
    },
    /**
     * Set parser `name` with the given `fn`
     * @param {String} `name`
     * @param {Function} `fn`
     * @api public
     */
    set: function (type, fn) {
        if (this.types.indexOf(type) === -1) {
            this.types.push(type);
        }
        this.parsers[type] = fn.bind(this);
        return this;
    },
    /**
     * Get parser `name`
     * @param {String} `name`
     * @api public
     */
    get: function (name) {
        return this.parsers[name];
    },
    /**
     * Push a `token` onto the `type` stack.
     *
     * @param {String} `type`
     * @return {Object} `token`
     * @api public
     */
    push: function (type, token) {
        this.sets[type] = this.sets[type] || [];
        this.count++;
        this.stack.push(token);
        return this.sets[type].push(token);
    },
    /**
     * Pop a token off of the `type` stack
     * @param {String} `type`
     * @returns {Object} Returns a token
     * @api public
     */
    pop: function (type) {
        this.sets[type] = this.sets[type] || [];
        this.count--;
        this.stack.pop();
        return this.sets[type].pop();
    },
    /**
     * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
     *
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    isInside: function (type) {
        this.sets[type] = this.sets[type] || [];
        return this.sets[type].length > 0;
    },
    /**
     * Return true if `node` is the given `type`.
     *
     * ```js
     * parser.isType(node, 'brace');
     * ```
     * @param {Object} `node`
     * @param {String} `type`
     * @return {Boolean}
     * @api public
     */
    isType: function (node, type) {
        return node && node.type === type;
    },
    /**
     * Get the previous AST node
     * @return {Object}
     */
    prev: function (n) {
        return this.stack.length > 0
            ? utils$1.last(this.stack, n)
            : utils$1.last(this.nodes, n);
    },
    /**
     * Update line and column based on `str`.
     */
    consume: function (len) {
        this.input = this.input.substr(len);
    },
    /**
     * Update column based on `str`.
     */
    updatePosition: function (str, len) {
        var lines = str.match(/\n/g);
        if (lines)
            this.line += lines.length;
        var i = str.lastIndexOf('\n');
        this.column = ~i ? len - i : this.column + len;
        this.parsed += str;
        this.consume(len);
    },
    /**
     * Match `regex`, return captures, and update the cursor position by `match[0]` length.
     * @param {RegExp} `regex`
     * @return {Object}
     */
    match: function (regex) {
        var m = regex.exec(this.input);
        if (m) {
            this.updatePosition(m[0], m[0].length);
            return m;
        }
    },
    /**
     * Capture `type` with the given regex.
     * @param {String} `type`
     * @param {RegExp} `regex`
     * @return {Function}
     */
    capture: function (type, regex) {
        if (typeof regex === 'function') {
            return this.set.apply(this, arguments);
        }
        this.regex.set(type, regex);
        this.set(type, function () {
            var parsed = this.parsed;
            var pos = this.position();
            var m = this.match(regex);
            if (!m || !m[0])
                return;
            var prev = this.prev();
            var node = pos({
                type: type,
                val: m[0],
                parsed: parsed,
                rest: this.input
            });
            if (m[1]) {
                node.inner = m[1];
            }
            defineProperty$6(node, 'inside', this.stack.length > 0);
            defineProperty$6(node, 'parent', prev);
            prev.nodes.push(node);
        }.bind(this));
        return this;
    },
    /**
     * Create a parser with open and close for parens,
     * brackets or braces
     */
    capturePair: function (type, openRegex, closeRegex, fn) {
        this.sets[type] = this.sets[type] || [];
        /**
         * Open
         */
        this.set(type + '.open', function () {
            var parsed = this.parsed;
            var pos = this.position();
            var m = this.match(openRegex);
            if (!m || !m[0])
                return;
            var val = m[0];
            this.setCount++;
            this.specialChars = true;
            var open = pos({
                type: type + '.open',
                val: val,
                rest: this.input
            });
            if (typeof m[1] !== 'undefined') {
                open.inner = m[1];
            }
            var prev = this.prev();
            var node = pos({
                type: type,
                nodes: [open]
            });
            defineProperty$6(node, 'rest', this.input);
            defineProperty$6(node, 'parsed', parsed);
            defineProperty$6(node, 'prefix', m[1]);
            defineProperty$6(node, 'parent', prev);
            defineProperty$6(open, 'parent', node);
            if (typeof fn === 'function') {
                fn.call(this, open, node);
            }
            this.push(type, node);
            prev.nodes.push(node);
        });
        /**
         * Close
         */
        this.set(type + '.close', function () {
            var pos = this.position();
            var m = this.match(closeRegex);
            if (!m || !m[0])
                return;
            var parent = this.pop(type);
            var node = pos({
                type: type + '.close',
                rest: this.input,
                suffix: m[1],
                val: m[0]
            });
            if (!this.isType(parent, type)) {
                if (this.options.strict) {
                    throw new Error('missing opening "' + type + '"');
                }
                this.setCount--;
                node.escaped = true;
                return node;
            }
            if (node.suffix === '\\') {
                parent.escaped = true;
                node.escaped = true;
            }
            parent.nodes.push(node);
            defineProperty$6(node, 'parent', parent);
        });
        return this;
    },
    /**
     * Capture end-of-string
     */
    eos: function () {
        var pos = this.position();
        if (this.input)
            return;
        var prev = this.prev();
        while (prev.type !== 'root' && !prev.visited) {
            if (this.options.strict === true) {
                throw new SyntaxError('invalid syntax:' + util$2.inspect(prev, null, 2));
            }
            if (!hasDelims(prev)) {
                prev.parent.escaped = true;
                prev.escaped = true;
            }
            visit(prev, function (node) {
                if (!hasDelims(node.parent)) {
                    node.parent.escaped = true;
                    node.escaped = true;
                }
            });
            prev = prev.parent;
        }
        var tok = pos({
            type: 'eos',
            val: this.append || ''
        });
        defineProperty$6(tok, 'parent', this.ast);
        return tok;
    },
    /**
     * Run parsers to advance the cursor position
     */
    next: function () {
        var parsed = this.parsed;
        var len = this.types.length;
        var idx = -1;
        var tok;
        while (++idx < len) {
            if ((tok = this.parsers[this.types[idx]].call(this))) {
                defineProperty$6(tok, 'rest', this.input);
                defineProperty$6(tok, 'parsed', parsed);
                this.last = tok;
                return tok;
            }
        }
    },
    /**
     * Parse the given string.
     * @return {Array}
     */
    parse: function (input) {
        if (typeof input !== 'string') {
            throw new TypeError('expected a string');
        }
        this.init(this.options);
        this.orig = input;
        this.input = input;
        var self = this;
        function parse() {
            // check input before calling `.next()`
            input = self.input;
            // get the next AST ndoe
            var node = self.next();
            if (node) {
                var prev = self.prev();
                if (prev) {
                    defineProperty$6(node, 'parent', prev);
                    if (prev.nodes) {
                        prev.nodes.push(node);
                    }
                }
                if (self.sets.hasOwnProperty(prev.type)) {
                    self.currentType = prev.type;
                }
            }
            // if we got here but input is not changed, throw an error
            if (self.input && input === self.input) {
                throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
            }
        }
        while (this.input)
            parse();
        if (this.stack.length && this.options.strict) {
            var node = this.stack.pop();
            throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
        }
        var eos = this.eos();
        var tok = this.prev();
        if (tok.type !== 'eos') {
            this.ast.nodes.push(eos);
        }
        return this.ast;
    }
};
/**
 * Visit `node` with the given `fn`
 */
function visit(node, fn) {
    if (!node.visited) {
        defineProperty$6(node, 'visited', true);
        return node.nodes ? mapVisit$1(node.nodes, fn) : fn(node);
    }
    return node;
}
/**
 * Map visit over array of `nodes`.
 */
function mapVisit$1(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
        visit(nodes[idx], fn);
    }
}
function hasOpen(node) {
    return node.nodes && node.nodes[0].type === (node.type + '.open');
}
function hasClose(node) {
    return node.nodes && utils$1.last(node.nodes).type === (node.type + '.close');
}
function hasDelims(node) {
    return hasOpen(node) && hasClose(node);
}
/**
 * Expose `Parser`
 */
var parser = Parser;

/**
 * Create a new instance of `Snapdragon` with the given `options`.
 *
 * ```js
 * var snapdragon = new Snapdragon();
 * ```
 *
 * @param {Object} `options`
 * @api public
 */
function Snapdragon(options) {
    base$2.call(this, null, options);
    this.options = utils$1.extend({ source: 'string' }, this.options);
    this.compiler = new compiler(this.options);
    this.parser = new parser(this.options);
    Object.defineProperty(this, 'compilers', {
        get: function () {
            return this.compiler.compilers;
        }
    });
    Object.defineProperty(this, 'parsers', {
        get: function () {
            return this.parser.parsers;
        }
    });
    Object.defineProperty(this, 'regex', {
        get: function () {
            return this.parser.regex;
        }
    });
}
/**
 * Inherit Base
 */
base$2.extend(Snapdragon);
/**
 * Add a parser to `snapdragon.parsers` for capturing the given `type` using
 * the specified regex or parser function. A function is useful if you need
 * to customize how the token is created and/or have access to the parser
 * instance to check options, etc.
 *
 * ```js
 * snapdragon
 *   .capture('slash', /^\//)
 *   .capture('dot', function() {
 *     var pos = this.position();
 *     var m = this.match(/^\./);
 *     if (!m) return;
 *     return pos({
 *       type: 'dot',
 *       val: m[0]
 *     });
 *   });
 * ```
 * @param {String} `type`
 * @param {RegExp|Function} `regex`
 * @return {Object} Returns the parser instance for chaining
 * @api public
 */
Snapdragon.prototype.capture = function () {
    return this.parser.capture.apply(this.parser, arguments);
};
/**
 * Register a plugin `fn`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * snapdragon.use(function() {
 *   console.log(this);          //<= snapdragon instance
 *   console.log(this.parser);   //<= parser instance
 *   console.log(this.compiler); //<= compiler instance
 * });
 * ```
 * @param {Object} `fn`
 * @api public
 */
Snapdragon.prototype.use = function (fn) {
    fn.call(this, this);
    return this;
};
/**
 * Parse the given `str`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register parsers
 * snapdragon.parser.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 * console.log(ast);
 * ```
 * @param {String} `str`
 * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
 * @return {Object} Returns an AST.
 * @api public
 */
Snapdragon.prototype.parse = function (str, options) {
    this.options = utils$1.extend({}, this.options, options);
    var parsed = this.parser.parse(str, this.options);
    // add non-enumerable parser reference
    defineProperty$6(parsed, 'parser', this.parser);
    return parsed;
};
/**
 * Compile the given `AST`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register plugins
 * snapdragon.use(function() {});
 * // register parser plugins
 * snapdragon.parser.use(function() {});
 * // register compiler plugins
 * snapdragon.compiler.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 *
 * // compile
 * var res = snapdragon.compile(ast);
 * console.log(res.output);
 * ```
 * @param {Object} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object with an `output` property with the rendered string.
 * @api public
 */
Snapdragon.prototype.compile = function (ast, options) {
    this.options = utils$1.extend({}, this.options, options);
    var compiled = this.compiler.compile(ast, this.options);
    // add non-enumerable compiler reference
    defineProperty$6(compiled, 'compiler', this.compiler);
    return compiled;
};
/**
 * Expose `Snapdragon`
 */
var snapdragon = Snapdragon;
/**
 * Expose `Parser` and `Compiler`
 */
var Compiler_1 = compiler;
var Parser_1 = parser;
snapdragon.Compiler = Compiler_1;
snapdragon.Parser = Parser_1;

/**
 * Customize Snapdragon parser and renderer
 */
function Braces(options) {
    this.options = extendShallow$1({}, options);
}
/**
 * Initialize braces
 */
Braces.prototype.init = function (options) {
    if (this.isInitialized)
        return;
    this.isInitialized = true;
    var opts = utils_1.createOptions({}, this.options, options);
    this.snapdragon = this.options.snapdragon || new snapdragon(opts);
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;
    compilers(this.snapdragon, opts);
    parsers(this.snapdragon, opts);
    /**
     * Call Snapdragon `.parse` method. When AST is returned, we check to
     * see if any unclosed braces are left on the stack and, if so, we iterate
     * over the stack and correct the AST so that compilers are called in the correct
     * order and unbalance braces are properly escaped.
     */
    utils_1.define(this.snapdragon, 'parse', function (pattern, options) {
        var parsed = snapdragon.prototype.parse.apply(this, arguments);
        this.parser.ast.input = pattern;
        var stack = this.parser.stack;
        while (stack.length) {
            addParent({ type: 'brace.close', val: '' }, stack.pop());
        }
        function addParent(node, parent) {
            utils_1.define(node, 'parent', parent);
            parent.nodes.push(node);
        }
        // add non-enumerable parser reference
        utils_1.define(parsed, 'parser', this.parser);
        return parsed;
    });
};
/**
 * Decorate `.parse` method
 */
Braces.prototype.parse = function (ast, options) {
    if (ast && typeof ast === 'object' && ast.nodes)
        return ast;
    this.init(options);
    return this.snapdragon.parse(ast, options);
};
/**
 * Decorate `.compile` method
 */
Braces.prototype.compile = function (ast, options) {
    if (typeof ast === 'string') {
        ast = this.parse(ast, options);
    }
    else {
        this.init(options);
    }
    return this.snapdragon.compile(ast, options);
};
/**
 * Expand
 */
Braces.prototype.expand = function (pattern) {
    var ast = this.parse(pattern, { expand: true });
    return this.compile(ast, { expand: true });
};
/**
 * Optimize
 */
Braces.prototype.optimize = function (pattern) {
    var ast = this.parse(pattern, { optimize: true });
    return this.compile(ast, { optimize: true });
};
/**
 * Expose `Braces`
 */
var braces = Braces;

/**
 * Module dependencies
 */
/**
 * Local dependencies
 */
var MAX_LENGTH$1 = 1024 * 64;
var cache$3 = {};
/**
 * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces('{a,b,c}'));
 * //=> ['(a|b|c)']
 *
 * console.log(braces('{a,b,c}', {expand: true}));
 * //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */
function braces$1(pattern, options) {
    var key = utils_1.createKey(String(pattern), options);
    var arr = [];
    var disabled = options && options.cache === false;
    if (!disabled && cache$3.hasOwnProperty(key)) {
        return cache$3[key];
    }
    if (Array.isArray(pattern)) {
        for (var i = 0; i < pattern.length; i++) {
            arr.push.apply(arr, braces$1.create(pattern[i], options));
        }
    }
    else {
        arr = braces$1.create(pattern, options);
    }
    if (options && options.nodupes === true) {
        arr = arrayUnique(arr);
    }
    if (!disabled) {
        cache$3[key] = arr;
    }
    return arr;
}
/**
 * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
braces$1.expand = function (pattern, options) {
    return braces$1.create(pattern, extendShallow$1({}, options, { expand: true }));
};
/**
 * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
braces$1.optimize = function (pattern, options) {
    return braces$1.create(pattern, options);
};
/**
 * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */
braces$1.create = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    var maxLength = (options && options.maxLength) || MAX_LENGTH$1;
    if (pattern.length >= maxLength) {
        throw new Error('expected pattern to be less than ' + maxLength + ' characters');
    }
    function create() {
        if (pattern === '' || pattern.length < 3) {
            return [pattern];
        }
        if (utils_1.isEmptySets(pattern)) {
            return [];
        }
        if (utils_1.isQuotedString(pattern)) {
            return [pattern.slice(1, -1)];
        }
        var proto = new braces(options);
        var result = !options || options.expand !== true
            ? proto.optimize(pattern, options)
            : proto.expand(pattern, options);
        // get the generated pattern(s)
        var arr = result.output;
        // filter out empty strings if specified
        if (options && options.noempty === true) {
            arr = arr.filter(Boolean);
        }
        // filter out duplicates if specified
        if (options && options.nodupes === true) {
            arr = arrayUnique(arr);
        }
        Object.defineProperty(arr, 'result', {
            enumerable: false,
            value: result
        });
        return arr;
    }
    return memoize$1('create', pattern, options, create);
};
/**
 * Create a regular expression from the given string `pattern`.
 *
 * ```js
 * var braces = require('braces');
 *
 * console.log(braces.makeRe('id-{200..300}'));
 * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
braces$1.makeRe = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    var maxLength = (options && options.maxLength) || MAX_LENGTH$1;
    if (pattern.length >= maxLength) {
        throw new Error('expected pattern to be less than ' + maxLength + ' characters');
    }
    function makeRe() {
        var arr = braces$1(pattern, options);
        var opts = extendShallow$1({ strictErrors: false }, options);
        return toRegex$1(arr, opts);
    }
    return memoize$1('makeRe', pattern, options, makeRe);
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `pattern` Brace pattern to parse
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */
braces$1.parse = function (pattern, options) {
    var proto = new braces(options);
    return proto.parse(pattern, options);
};
/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(braces.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */
braces$1.compile = function (ast, options) {
    var proto = new braces(options);
    return proto.compile(ast, options);
};
/**
 * Clear the regex cache.
 *
 * ```js
 * braces.clearCache();
 * ```
 * @api public
 */
braces$1.clearCache = function () {
    cache$3 = braces$1.cache = {};
};
/**
 * Memoize a generated regex or function. A unique key is generated
 * from the method name, pattern, and user-defined options. Set
 * options.memoize to false to disable.
 */
function memoize$1(type, pattern, options, fn) {
    var key = utils_1.createKey(type + ':' + pattern, options);
    var disabled = options && options.cache === false;
    if (disabled) {
        braces$1.clearCache();
        return fn(pattern, options);
    }
    if (cache$3.hasOwnProperty(key)) {
        return cache$3[key];
    }
    var res = fn(pattern, options);
    cache$3[key] = res;
    return res;
}
/**
 * Expose `Braces` constructor and methods
 * @type {Function}
 */
braces$1.Braces = braces;
braces$1.compilers = compilers;
braces$1.parsers = parsers;
braces$1.cache = cache$3;
/**
 * Expose `braces`
 * @type {Function}
 */
var braces_1 = braces$1;

/**
* Nanomatch compilers
*/
var compilers$1 = function (nanomatch, options) {
    function slash() {
        if (options && typeof options.slash === 'string') {
            return options.slash;
        }
        if (options && typeof options.slash === 'function') {
            return options.slash.call(nanomatch);
        }
        return '\\\\/';
    }
    function star() {
        if (options && typeof options.star === 'string') {
            return options.star;
        }
        if (options && typeof options.star === 'function') {
            return options.star.call(nanomatch);
        }
        return '[^' + slash() + ']*?';
    }
    var ast = nanomatch.ast = nanomatch.parser.ast;
    ast.state = nanomatch.parser.state;
    nanomatch.compiler.state = ast.state;
    nanomatch.compiler
        /**
         * Negation / escaping
         */
        .set('not', function (node) {
        var prev = this.prev();
        if (this.options.nonegate === true || prev.type !== 'bos') {
            return this.emit('\\' + node.val, node);
        }
        return this.emit(node.val, node);
    })
        .set('escape', function (node) {
        if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
            return this.emit(node.val, node);
        }
        return this.emit('\\' + node.val, node);
    })
        .set('quoted', function (node) {
        return this.emit(node.val, node);
    })
        /**
         * Regex
         */
        .set('dollar', function (node) {
        if (node.parent.type === 'bracket') {
            return this.emit(node.val, node);
        }
        return this.emit('\\' + node.val, node);
    })
        /**
         * Dot: "."
         */
        .set('dot', function (node) {
        if (node.dotfiles === true)
            this.dotfiles = true;
        return this.emit('\\' + node.val, node);
    })
        /**
         * Slashes: "/" and "\"
         */
        .set('backslash', function (node) {
        return this.emit(node.val, node);
    })
        .set('slash', function (node, nodes, i) {
        var val = '[' + slash() + ']';
        var parent = node.parent;
        var prev = this.prev();
        // set "node.hasSlash" to true on all ancestor parens nodes
        while (parent.type === 'paren' && !parent.hasSlash) {
            parent.hasSlash = true;
            parent = parent.parent;
        }
        if (prev.addQmark) {
            val += '?';
        }
        // word boundary
        if (node.rest.slice(0, 2) === '\\b') {
            return this.emit(val, node);
        }
        // globstars
        if (node.parsed === '**' || node.parsed === './**') {
            this.output = '(?:' + this.output;
            return this.emit(val + ')?', node);
        }
        // negation
        if (node.parsed === '!**' && this.options.nonegate !== true) {
            return this.emit(val + '?\\b', node);
        }
        return this.emit(val, node);
    })
        /**
         * Square brackets
         */
        .set('bracket', function (node) {
        var close = node.close;
        var open = !node.escaped ? '[' : '\\[';
        var negated = node.negated;
        var inner = node.inner;
        var val = node.val;
        if (node.escaped === true) {
            inner = inner.replace(/\\?(\W)/g, '\\$1');
            negated = '';
        }
        if (inner === ']-') {
            inner = '\\]\\-';
        }
        if (negated && inner.indexOf('.') === -1) {
            inner += '.';
        }
        if (negated && inner.indexOf('/') === -1) {
            inner += '/';
        }
        val = open + negated + inner + close;
        return this.emit(val, node);
    })
        /**
         * Square: "[.]" (only matches a single character in brackets)
         */
        .set('square', function (node) {
        var val = (/^\W/.test(node.val) ? '\\' : '') + node.val;
        return this.emit(val, node);
    })
        /**
         * Question mark: "?"
         */
        .set('qmark', function (node) {
        var prev = this.prev();
        // don't use "slash" variable so that we always avoid
        // matching backslashes and slashes with a qmark
        var val = '[^.\\\\/]';
        if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {
            val = '[^\\\\/]';
        }
        if (node.parsed.slice(-1) === '(') {
            var ch = node.rest.charAt(0);
            if (ch === '!' || ch === '=' || ch === ':') {
                return this.emit(node.val, node);
            }
        }
        if (node.val.length > 1) {
            val += '{' + node.val.length + '}';
        }
        return this.emit(val, node);
    })
        /**
         * Plus
         */
        .set('plus', function (node) {
        var prev = node.parsed.slice(-1);
        if (prev === ']' || prev === ')') {
            return this.emit(node.val, node);
        }
        if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
            return this.emit('\\+', node);
        }
        var ch = this.output.slice(-1);
        if (/\w/.test(ch) && !node.inside) {
            return this.emit('+\\+?', node);
        }
        return this.emit('+', node);
    })
        /**
         * globstar: '**'
         */
        .set('globstar', function (node, nodes, i) {
        if (!this.output) {
            this.state.leadingGlobstar = true;
        }
        var prev = this.prev();
        var before = this.prev(2);
        var next = this.next();
        var after = this.next(2);
        var type = prev.type;
        var val = node.val;
        if (prev.type === 'slash' && next.type === 'slash') {
            if (before.type === 'text') {
                this.output += '?';
                if (after.type !== 'text') {
                    this.output += '\\b';
                }
            }
        }
        var parsed = node.parsed;
        if (parsed.charAt(0) === '!') {
            parsed = parsed.slice(1);
        }
        var isInside = node.isInside.paren || node.isInside.brace;
        if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {
            val = star();
        }
        else {
            val = this.options.dot !== true
                ? '(?:(?!(?:[' + slash() + ']|^)\\.).)*?'
                : '(?:(?!(?:[' + slash() + ']|^)(?:\\.{1,2})($|[' + slash() + ']))(?!\\.{2}).)*?';
        }
        if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {
            val = '(?!\\.)' + val;
        }
        if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {
            if (after.type === 'text' || after.type === 'star') {
                node.addQmark = true;
            }
        }
        if (this.options.capture) {
            val = '(' + val + ')';
        }
        return this.emit(val, node);
    })
        /**
         * Star: "*"
         */
        .set('star', function (node, nodes, i) {
        var prior = nodes[i - 2] || {};
        var prev = this.prev();
        var next = this.next();
        var type = prev.type;
        function isStart(n) {
            return n.type === 'bos' || n.type === 'slash';
        }
        if (this.output === '' && this.options.contains !== true) {
            this.output = '(?![' + slash() + '])';
        }
        if (type === 'bracket' && this.options.bash === false) {
            var str = next && next.type === 'bracket' ? star() : '*?';
            if (!prev.nodes || prev.nodes[1].type !== 'posix') {
                return this.emit(str, node);
            }
        }
        var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
            ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\.)')
            : '';
        if (isStart(prev) || (isStart(prior) && type === 'not')) {
            if (prefix !== '(?!\\.)') {
                prefix += '(?!(\\.{2}|\\.[' + slash() + ']))(?=.)';
            }
            else {
                prefix += '(?=.)';
            }
        }
        else if (prefix === '(?!\\.)') {
            prefix = '';
        }
        if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {
            this.output = '(?!\\.)' + this.output;
        }
        var output = prefix + star();
        if (this.options.capture) {
            output = '(' + output + ')';
        }
        return this.emit(output, node);
    })
        /**
         * Text
         */
        .set('text', function (node) {
        return this.emit(node.val, node);
    })
        /**
         * End-of-string
         */
        .set('eos', function (node) {
        var prev = this.prev();
        var val = node.val;
        this.output = '(?:\\.[' + slash() + '](?=.))?' + this.output;
        if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {
            val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');
        }
        return this.emit(val, node);
    });
    /**
     * Allow custom compilers to be passed on options
     */
    if (options && typeof options.compilers === 'function') {
        options.compilers(nanomatch.compiler);
    }
};

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */
var cached;
var NOT_REGEX = '[\\[!*+?$^"\'.\\\\/]+';
var not$1 = createTextRegex(NOT_REGEX);
/**
 * Nanomatch parsers
 */
var parsers$1 = function (nanomatch, options) {
    var parser = nanomatch.parser;
    var opts = parser.options;
    parser.state = {
        slashes: 0,
        paths: []
    };
    parser.ast.state = parser.state;
    parser
        /**
         * Beginning-of-string
         */
        .capture('prefix', function () {
        if (this.parsed)
            return;
        var m = this.match(/^\.[\\/]/);
        if (!m)
            return;
        this.state.strictOpen = !!this.options.strictOpen;
        this.state.addPrefix = true;
    })
        /**
         * Escape: "\\."
         */
        .capture('escape', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(/^(?:\\(.)|([$^]))/);
        if (!m)
            return;
        return pos({
            type: 'escape',
            val: m[2] || m[1]
        });
    })
        /**
         * Quoted strings
         */
        .capture('quoted', function () {
        var pos = this.position();
        var m = this.match(/^["']/);
        if (!m)
            return;
        var quote = m[0];
        if (this.input.indexOf(quote) === -1) {
            return pos({
                type: 'escape',
                val: quote
            });
        }
        var tok = advanceTo(this.input, quote);
        this.consume(tok.len);
        return pos({
            type: 'quoted',
            val: tok.esc
        });
    })
        /**
         * Negations: "!"
         */
        .capture('not', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(this.notRegex || /^!+/);
        if (!m)
            return;
        var val = m[0];
        var isNegated = (val.length % 2) === 1;
        if (parsed === '' && !isNegated) {
            val = '';
        }
        // if nothing has been parsed, we know `!` is at the start,
        // so we need to wrap the result in a negation regex
        if (parsed === '' && isNegated && this.options.nonegate !== true) {
            this.bos.val = '(?!^(?:';
            this.append = ')$).*';
            val = '';
        }
        return pos({
            type: 'not',
            val: val
        });
    })
        /**
         * Dot: "."
         */
        .capture('dot', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\.+/);
        if (!m)
            return;
        var val = m[0];
        this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');
        return pos({
            type: 'dot',
            dotfiles: this.state.dot,
            val: val
        });
    })
        /**
         * Plus: "+"
         */
        .capture('plus', /^\+(?!\()/)
        /**
         * Question mark: "?"
         */
        .capture('qmark', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
            return;
        this.state.metachar = true;
        this.state.qmark = true;
        return pos({
            type: 'qmark',
            parsed: parsed,
            val: m[0]
        });
    })
        /**
         * Globstar: "**"
         */
        .capture('globstar', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
        if (!m)
            return;
        var type = opts.noglobstar !== true ? 'globstar' : 'star';
        var node = pos({ type: type, parsed: parsed });
        this.state.metachar = true;
        while (this.input.slice(0, 4) === '/**/') {
            this.input = this.input.slice(3);
        }
        node.isInside = {
            brace: this.isInside('brace'),
            paren: this.isInside('paren')
        };
        if (type === 'globstar') {
            this.state.globstar = true;
            node.val = '**';
        }
        else {
            this.state.star = true;
            node.val = '*';
        }
        return node;
    })
        /**
         * Star: "*"
         */
        .capture('star', function () {
        var pos = this.position();
        var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
        var m = this.match(starRe);
        if (!m)
            return;
        this.state.metachar = true;
        this.state.star = true;
        return pos({
            type: 'star',
            val: m[0]
        });
    })
        /**
         * Slash: "/"
         */
        .capture('slash', function () {
        var pos = this.position();
        var m = this.match(/^\//);
        if (!m)
            return;
        this.state.slashes++;
        return pos({
            type: 'slash',
            val: m[0]
        });
    })
        /**
         * Backslash: "\\"
         */
        .capture('backslash', function () {
        var pos = this.position();
        var m = this.match(/^\\(?![*+?(){}[\]'"])/);
        if (!m)
            return;
        var val = m[0];
        if (this.isInside('bracket')) {
            val = '\\';
        }
        else if (val.length > 1) {
            val = '\\\\';
        }
        return pos({
            type: 'backslash',
            val: val
        });
    })
        /**
         * Square: "[.]"
         */
        .capture('square', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(/^\[([^!^\\])\]/);
        if (!m)
            return;
        return pos({
            type: 'square',
            val: m[1]
        });
    })
        /**
         * Brackets: "[...]" (basic, this can be overridden by other parsers)
         */
        .capture('bracket', function () {
        var pos = this.position();
        var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
        if (!m)
            return;
        var val = m[0];
        var negated = m[1] ? '^' : '';
        var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
        var close = m[3] || '';
        if (m[2] && inner.length < m[2].length) {
            val = val.replace(/\\\\+/, '\\\\');
        }
        var esc = this.input.slice(0, 2);
        if (inner === '' && esc === '\\]') {
            inner += esc;
            this.consume(2);
            var str = this.input;
            var idx = -1;
            var ch;
            while ((ch = str[++idx])) {
                this.consume(1);
                if (ch === ']') {
                    close = ch;
                    break;
                }
                inner += ch;
            }
        }
        return pos({
            type: 'bracket',
            val: val,
            escaped: close !== ']',
            negated: negated,
            inner: inner,
            close: close
        });
    })
        /**
         * Text
         */
        .capture('text', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(not$1);
        if (!m || !m[0])
            return;
        return pos({
            type: 'text',
            val: m[0]
        });
    });
    /**
     * Allow custom parsers to be passed on options
     */
    if (options && typeof options.parsers === 'function') {
        options.parsers(nanomatch.parser);
    }
};
/**
 * Advance to the next non-escaped character
 */
function advanceTo(input, endChar) {
    var ch = input.charAt(0);
    var tok = { len: 1, val: '', esc: '' };
    var idx = 0;
    function advance() {
        if (ch !== '\\') {
            tok.esc += '\\' + ch;
            tok.val += ch;
        }
        ch = input.charAt(++idx);
        tok.len++;
        if (ch === '\\') {
            advance();
            advance();
        }
    }
    while (ch && ch !== endChar) {
        advance();
    }
    return tok;
}
/**
 * Create text regex
 */
function createTextRegex(pattern) {
    if (cached)
        return cached;
    var opts = { contains: true, strictClose: false };
    var not = regexNot.create(pattern, opts);
    var re = toRegex$1('^(?:[*]\\((?=.)|' + not + ')', opts);
    return (cached = re);
}
/**
 * Expose negation string
 */
var not_1 = NOT_REGEX;
parsers$1.not = not_1;

var fragmentCache = createCommonjsModule(function (module, exports) {
    /**
     * Create a new `FragmentCache` with an optional object to use for `caches`.
     *
     * ```js
     * var fragment = new FragmentCache();
     * ```
     * @name FragmentCache
     * @param {String} `cacheName`
     * @return {Object} Returns the [map-cache][] instance.
     * @api public
     */
    function FragmentCache(caches) {
        this.caches = caches || {};
    }
    /**
     * Prototype
     */
    FragmentCache.prototype = {
        /**
         * Get cache `name` from the `fragment.caches` object. Creates a new
         * `MapCache` if it doesn't already exist.
         *
         * ```js
         * var cache = fragment.cache('files');
         * console.log(fragment.caches.hasOwnProperty('files'));
         * //=> true
         * ```
         * @name .cache
         * @param {String} `cacheName`
         * @return {Object} Returns the [map-cache][] instance.
         * @api public
         */
        cache: function (cacheName) {
            return this.caches[cacheName] || (this.caches[cacheName] = new mapCache());
        },
        /**
         * Set a value for property `key` on cache `name`
         *
         * ```js
         * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
         * ```
         * @name .set
         * @param {String} `name`
         * @param {String} `key` Property name to set
         * @param {any} `val` The value of `key`
         * @return {Object} The cache instance for chaining
         * @api public
         */
        set: function (cacheName, key, val) {
            var cache = this.cache(cacheName);
            cache.set(key, val);
            return cache;
        },
        /**
         * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
         *
         * ```js
         * var cache = fragment.cache('files');
         * cache.set('somefile.js');
         *
         * console.log(cache.has('somefile.js'));
         * //=> true
         *
         * console.log(cache.has('some-other-file.js'));
         * //=> false
         * ```
         * @name .has
         * @param {String} `name` Cache name
         * @param {String} `key` Optionally specify a property to check for on cache `name`
         * @return {Boolean}
         * @api public
         */
        has: function (cacheName, key) {
            return typeof this.get(cacheName, key) !== 'undefined';
        },
        /**
         * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
         * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
         * the entire cache (`name`) is returned.
         *
         * ```js
         * var Vinyl = require('vinyl');
         * var cache = fragment.cache('files');
         * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
         * console.log(cache.get('somefile.js'));
         * //=> <File "somefile.js">
         * ```
         * @name .get
         * @param {String} `name`
         * @return {Object} Returns cache `name`, or the value of `key` if specified
         * @api public
         */
        get: function (name, key) {
            var cache = this.cache(name);
            if (typeof key === 'string') {
                return cache.get(key);
            }
            return cache;
        }
    };
    /**
     * Expose `FragmentCache`
     */
    exports = module.exports = FragmentCache;
});

var cache$4 = new (fragmentCache)();

var isWindows = createCommonjsModule(function (module, exports) {
    /*!
     * is-windows <https://github.com/jonschlinkert/is-windows>
     *
     * Copyright © 2015-2018, Jon Schlinkert.
     * Released under the MIT License.
     */
    (function (factory) {
        if (exports && 'object' === 'object' && 'object' !== 'undefined') {
            module.exports = factory();
        }
        else if (typeof window !== 'undefined') {
            window.isWindows = factory();
        }
        else if (typeof commonjsGlobal !== 'undefined') {
            commonjsGlobal.isWindows = factory();
        }
        else if (typeof self !== 'undefined') {
            self.isWindows = factory();
        }
        else {
            this.isWindows = factory();
        }
    })(function () {
        return function isWindows() {
            return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
        };
    });
});

/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var arrDiff = function diff(arr /*, arrays*/) {
    var len = arguments.length;
    var idx = 0;
    while (++idx < len) {
        arr = diffArray(arr, arguments[idx]);
    }
    return arr;
};
function diffArray(one, two) {
    if (!Array.isArray(two)) {
        return one.slice();
    }
    var tlen = two.length;
    var olen = one.length;
    var idx = -1;
    var arr = [];
    while (++idx < olen) {
        var ele = one[idx];
        var hasEle = false;
        for (var i = 0; i < tlen; i++) {
            var val = two[i];
            if (ele === val) {
                hasEle = true;
                break;
            }
        }
        if (hasEle === false) {
            arr.push(ele);
        }
    }
    return arr;
}

var object_pick = function pick(obj, keys) {
    if (!isobject(obj) && typeof obj !== 'function') {
        return {};
    }
    var res = {};
    if (typeof keys === 'string') {
        if (keys in obj) {
            res[keys] = obj[keys];
        }
        return res;
    }
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
        var key = keys[idx];
        if (key in obj) {
            res[key] = obj[key];
        }
    }
    return res;
};

var utils_1$1 = createCommonjsModule(function (module) {
    var utils = module.exports;
    /**
     * Module dependencies
     */
    var isWindows$1 = isWindows();
    utils.define = defineProperty;
    utils.diff = arrDiff;
    utils.extend = extendShallow;
    utils.pick = object_pick;
    utils.typeOf = kindOf;
    utils.unique = arrayUnique;
    /**
     * Returns true if the given value is effectively an empty string
     */
    utils.isEmptyString = function (val) {
        return String(val) === '' || String(val) === './';
    };
    /**
     * Returns true if the platform is windows, or `path.sep` is `\\`.
     * This is defined as a function to allow `path.sep` to be set in unit tests,
     * or by the user, if there is a reason to do so.
     * @return {Boolean}
     */
    utils.isWindows = function () {
        return path.sep === '\\' || isWindows$1 === true;
    };
    /**
     * Return the last element from an array
     */
    utils.last = function (arr, n) {
        return arr[arr.length - (n || 1)];
    };
    /**
     * Get the `Snapdragon` instance to use
     */
    utils.instantiate = function (ast, options) {
        var snapdragon$1;
        // if an instance was created by `.parse`, use that instance
        if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
            snapdragon$1 = ast.snapdragon;
            // if the user supplies an instance on options, use that instance
        }
        else if (utils.typeOf(options) === 'object' && options.snapdragon) {
            snapdragon$1 = options.snapdragon;
            // create a new instance
        }
        else {
            snapdragon$1 = new snapdragon(options);
        }
        utils.define(snapdragon$1, 'parse', function (str, options) {
            var parsed = snapdragon.prototype.parse.call(this, str, options);
            parsed.input = str;
            // escape unmatched brace/bracket/parens
            var last = this.parser.stack.pop();
            if (last && this.options.strictErrors !== true) {
                var open = last.nodes[0];
                var inner = last.nodes[1];
                if (last.type === 'bracket') {
                    if (inner.val.charAt(0) === '[') {
                        inner.val = '\\' + inner.val;
                    }
                }
                else {
                    open.val = '\\' + open.val;
                    var sibling = open.parent.nodes[1];
                    if (sibling.type === 'star') {
                        sibling.loose = true;
                    }
                }
            }
            // add non-enumerable parser reference
            utils.define(parsed, 'parser', this.parser);
            return parsed;
        });
        return snapdragon$1;
    };
    /**
     * Create the key to use for memoization. The key is generated
     * by iterating over the options and concatenating key-value pairs
     * to the pattern string.
     */
    utils.createKey = function (pattern, options) {
        if (typeof options === 'undefined') {
            return pattern;
        }
        var key = pattern;
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                key += ';' + prop + '=' + String(options[prop]);
            }
        }
        return key;
    };
    /**
     * Cast `val` to an array
     * @return {Array}
     */
    utils.arrayify = function (val) {
        if (typeof val === 'string')
            return [val];
        return val ? (Array.isArray(val) ? val : [val]) : [];
    };
    /**
     * Return true if `val` is a non-empty string
     */
    utils.isString = function (val) {
        return typeof val === 'string';
    };
    /**
     * Return true if `val` is a non-empty string
     */
    utils.isRegex = function (val) {
        return utils.typeOf(val) === 'regexp';
    };
    /**
     * Return true if `val` is a non-empty string
     */
    utils.isObject = function (val) {
        return utils.typeOf(val) === 'object';
    };
    /**
     * Escape regex characters in the given string
     */
    utils.escapeRegex = function (str) {
        return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, '\\$&');
    };
    /**
     * Combines duplicate characters in the provided `input` string.
     * @param {String} `input`
     * @returns {String}
     */
    utils.combineDupes = function (input, patterns) {
        patterns = utils.arrayify(patterns).join('|').split('|');
        patterns = patterns.map(function (s) {
            return s.replace(/\\?([+*\\/])/g, '\\$1');
        });
        var substr = patterns.join('|');
        var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
        return input.replace(regex, '');
    };
    /**
     * Returns true if the given `str` has special characters
     */
    utils.hasSpecialChars = function (str) {
        return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
    };
    /**
     * Normalize slashes in the given filepath.
     *
     * @param {String} `filepath`
     * @return {String}
     */
    utils.toPosixPath = function (str) {
        return str.replace(/\\+/g, '/');
    };
    /**
     * Strip backslashes before special characters in a string.
     *
     * @param {String} `str`
     * @return {String}
     */
    utils.unescape = function (str) {
        return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
    };
    /**
     * Strip the drive letter from a windows filepath
     * @param {String} `fp`
     * @return {String}
     */
    utils.stripDrive = function (fp) {
        return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, '/') : fp;
    };
    /**
     * Strip the prefix from a filepath
     * @param {String} `fp`
     * @return {String}
     */
    utils.stripPrefix = function (str) {
        if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) {
            return str.slice(2);
        }
        return str;
    };
    /**
     * Returns true if `str` is a common character that doesn't need
     * to be processed to be used for matching.
     * @param {String} `str`
     * @return {Boolean}
     */
    utils.isSimpleChar = function (str) {
        return str.trim() === '' || str === '.';
    };
    /**
     * Returns true if the given str is an escaped or
     * unescaped path character
     */
    utils.isSlash = function (str) {
        return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
    };
    /**
     * Returns a function that returns true if the given
     * pattern matches or contains a `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.matchPath = function (pattern, options) {
        return (options && options.contains)
            ? utils.containsPattern(pattern, options)
            : utils.equalsPattern(pattern, options);
    };
    /**
     * Returns true if the given (original) filepath or unixified path are equal
     * to the given pattern.
     */
    utils._equals = function (filepath, unixPath, pattern) {
        return pattern === filepath || pattern === unixPath;
    };
    /**
     * Returns true if the given (original) filepath or unixified path contain
     * the given pattern.
     */
    utils._contains = function (filepath, unixPath, pattern) {
        return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    /**
     * Returns a function that returns true if the given
     * pattern is the same as a given `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.equalsPattern = function (pattern, options) {
        var unixify = utils.unixify(options);
        options = options || {};
        return function fn(filepath) {
            var equal = utils._equals(filepath, unixify(filepath), pattern);
            if (equal === true || options.nocase !== true) {
                return equal;
            }
            var lower = filepath.toLowerCase();
            return utils._equals(lower, unixify(lower), pattern);
        };
    };
    /**
     * Returns a function that returns true if the given
     * pattern contains a `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.containsPattern = function (pattern, options) {
        var unixify = utils.unixify(options);
        options = options || {};
        return function (filepath) {
            var contains = utils._contains(filepath, unixify(filepath), pattern);
            if (contains === true || options.nocase !== true) {
                return contains;
            }
            var lower = filepath.toLowerCase();
            return utils._contains(lower, unixify(lower), pattern);
        };
    };
    /**
     * Returns a function that returns true if the given
     * regex matches the `filename` of a file path.
     *
     * @param {RegExp} `re` Matching regex
     * @return {Function}
     */
    utils.matchBasename = function (re) {
        return function (filepath) {
            return re.test(filepath) || re.test(path.basename(filepath));
        };
    };
    /**
     * Returns the given value unchanced.
     * @return {any}
     */
    utils.identity = function (val) {
        return val;
    };
    /**
     * Determines the filepath to return based on the provided options.
     * @return {any}
     */
    utils.value = function (str, unixify, options) {
        if (options && options.unixify === false) {
            return str;
        }
        if (options && typeof options.unixify === 'function') {
            return options.unixify(str);
        }
        return unixify(str);
    };
    /**
     * Returns a function that normalizes slashes in a string to forward
     * slashes, strips `./` from beginning of paths, and optionally unescapes
     * special characters.
     * @return {Function}
     */
    utils.unixify = function (options) {
        var opts = options || {};
        return function (filepath) {
            if (opts.stripPrefix !== false) {
                filepath = utils.stripPrefix(filepath);
            }
            if (opts.unescape === true) {
                filepath = utils.unescape(filepath);
            }
            if (opts.unixify === true || utils.isWindows()) {
                filepath = utils.toPosixPath(filepath);
            }
            return filepath;
        };
    };
});

/**
 * Module dependencies
 */
/**
 * Local dependencies
 */
var MAX_LENGTH$2 = 1024 * 64;
/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm(list, patterns[, options]);
 *
 * console.log(nm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */
function nanomatch(list, patterns, options) {
    patterns = utils_1$1.arrayify(patterns);
    list = utils_1$1.arrayify(list);
    var len = patterns.length;
    if (list.length === 0 || len === 0) {
        return [];
    }
    if (len === 1) {
        return nanomatch.match(list, patterns[0], options);
    }
    var negated = false;
    var omit = [];
    var keep = [];
    var idx = -1;
    while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
            omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
            negated = true;
        }
        else {
            keep.push.apply(keep, nanomatch.match(list, pattern, options));
        }
    }
    // minimatch.match parity
    if (negated && keep.length === 0) {
        if (options && options.unixify === false) {
            keep = list.slice();
        }
        else {
            var unixify = utils_1$1.unixify(options);
            for (var i = 0; i < list.length; i++) {
                keep.push(unixify(list[i]));
            }
        }
    }
    var matches = utils_1$1.diff(keep, omit);
    if (!options || options.nodupes !== false) {
        return utils_1$1.unique(matches);
    }
    return matches;
}
/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.match(list, pattern[, options]);
 *
 * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */
nanomatch.match = function (list, pattern, options) {
    if (Array.isArray(pattern)) {
        throw new TypeError('expected pattern to be a string');
    }
    var unixify = utils_1$1.unixify(options);
    var isMatch = memoize$2('match', pattern, options, nanomatch.matcher);
    var matches = [];
    list = utils_1$1.arrayify(list);
    var len = list.length;
    var idx = -1;
    while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
            matches.push(utils_1$1.value(ele, unixify, options));
        }
    }
    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
        return utils_1$1.unique(matches);
    }
    if (matches.length === 0) {
        if (options.failglob === true) {
            throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
            return [options.unescape ? utils_1$1.unescape(pattern) : pattern];
        }
    }
    // if `opts.ignore` was defined, diff ignored list
    if (options.ignore) {
        matches = nanomatch.not(matches, options.ignore, options);
    }
    return options.nodupes !== false ? utils_1$1.unique(matches) : matches;
};
/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.isMatch(string, pattern[, options]);
 *
 * console.log(nm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(nm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */
nanomatch.isMatch = function (str, pattern, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (utils_1$1.isEmptyString(str) || utils_1$1.isEmptyString(pattern)) {
        return false;
    }
    var equals = utils_1$1.equalsPattern(options);
    if (equals(str)) {
        return true;
    }
    var isMatch = memoize$2('isMatch', pattern, options, nanomatch.matcher);
    return isMatch(str);
};
/**
 * Returns true if some of the elements in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.some(list, patterns[, options]);
 *
 * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
nanomatch.some = function (list, patterns, options) {
    if (typeof list === 'string') {
        list = [list];
    }
    for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length === 1) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if every element in the given `list` matches
 * at least one of the given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.every(list, patterns[, options]);
 *
 * console.log(nm.every('foo.js', ['foo.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
nanomatch.every = function (list, patterns, options) {
    if (typeof list === 'string') {
        list = [list];
    }
    for (var i = 0; i < list.length; i++) {
        if (nanomatch(list[i], patterns, options).length !== 1) {
            return false;
        }
    }
    return true;
};
/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.any(string, patterns[, options]);
 *
 * console.log(nm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(nm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
nanomatch.any = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (utils_1$1.isEmptyString(str) || utils_1$1.isEmptyString(patterns)) {
        return false;
    }
    if (typeof patterns === 'string') {
        patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
        if (nanomatch.isMatch(str, patterns[i], options)) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if **all** of the given `patterns`
 * match the specified string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.all(string, patterns[, options]);
 *
 * console.log(nm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
nanomatch.all = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (typeof patterns === 'string') {
        patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
        if (!nanomatch.isMatch(str, patterns[i], options)) {
            return false;
        }
    }
    return true;
};
/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.not(list, patterns[, options]);
 *
 * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */
nanomatch.not = function (list, patterns, options) {
    var opts = extendShallow({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;
    list = utils_1$1.arrayify(list);
    var matches = utils_1$1.diff(list, nanomatch(list, patterns, opts));
    if (ignore) {
        matches = utils_1$1.diff(matches, nanomatch(list, ignore));
    }
    return opts.nodupes !== false ? utils_1$1.unique(matches) : matches;
};
/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.contains(string, pattern[, options]);
 *
 * console.log(nm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(nm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */
nanomatch.contains = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (typeof patterns === 'string') {
        if (utils_1$1.isEmptyString(str) || utils_1$1.isEmptyString(patterns)) {
            return false;
        }
        var equals = utils_1$1.equalsPattern(patterns, options);
        if (equals(str)) {
            return true;
        }
        var contains = utils_1$1.containsPattern(patterns, options);
        if (contains(str)) {
            return true;
        }
    }
    var opts = extendShallow({}, options, { contains: true });
    return nanomatch.any(str, patterns, opts);
};
/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */
nanomatch.matchBase = function (pattern, options) {
    if (pattern && pattern.indexOf('/') !== -1 || !options)
        return false;
    return options.basename === true || options.matchBase === true;
};
/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(nm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */
nanomatch.matchKeys = function (obj, patterns, options) {
    if (!utils_1$1.isObject(obj)) {
        throw new TypeError('expected the first argument to be an object');
    }
    var keys = nanomatch(Object.keys(obj), patterns, options);
    return utils_1$1.pick(obj, keys);
};
/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matcher(pattern[, options]);
 *
 * var isMatch = nm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */
nanomatch.matcher = function matcher(pattern, options) {
    if (utils_1$1.isEmptyString(pattern)) {
        return function () {
            return false;
        };
    }
    if (Array.isArray(pattern)) {
        return compose(pattern, options, matcher);
    }
    // if pattern is a regex
    if (pattern instanceof RegExp) {
        return test(pattern);
    }
    // if pattern is invalid
    if (!utils_1$1.isString(pattern)) {
        throw new TypeError('expected pattern to be an array, string or regex');
    }
    // if pattern is a non-glob string
    if (!utils_1$1.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
            pattern = pattern.toLowerCase();
        }
        return utils_1$1.matchPath(pattern, options);
    }
    // if pattern is a glob string
    var re = nanomatch.makeRe(pattern, options);
    // if `options.matchBase` or `options.basename` is defined
    if (nanomatch.matchBase(pattern, options)) {
        return utils_1$1.matchBasename(re, options);
    }
    function test(regex) {
        var equals = utils_1$1.equalsPattern(options);
        var unixify = utils_1$1.unixify(options);
        return function (str) {
            if (equals(str)) {
                return true;
            }
            if (regex.test(unixify(str))) {
                return true;
            }
            return false;
        };
    }
    // create matcher function
    var matcherFn = test(re);
    // set result object from compiler on matcher function,
    // as a non-enumerable property. useful for debugging
    utils_1$1.define(matcherFn, 'result', re.result);
    return matcherFn;
};
/**
 * Returns an array of matches captured by `pattern` in `string, or
 * `null` if the pattern did not match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.capture(pattern, string[, options]);
 *
 * console.log(nm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(nm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */
nanomatch.capture = function (pattern, str, options) {
    var re = nanomatch.makeRe(pattern, extendShallow({ capture: true }, options));
    var unixify = utils_1$1.unixify(options);
    function match() {
        return function (string) {
            var match = re.exec(unixify(string));
            if (!match) {
                return null;
            }
            return match.slice(1);
        };
    }
    var capture = memoize$2('capture', pattern, options, match);
    return capture(str);
};
/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.makeRe(pattern[, options]);
 *
 * console.log(nm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */
nanomatch.makeRe = function (pattern, options) {
    if (pattern instanceof RegExp) {
        return pattern;
    }
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    if (pattern.length > MAX_LENGTH$2) {
        throw new Error('expected pattern to be less than ' + MAX_LENGTH$2 + ' characters');
    }
    function makeRe() {
        var opts = utils_1$1.extend({ wrap: false }, options);
        var result = nanomatch.create(pattern, opts);
        var regex = toRegex$1(result.output, opts);
        utils_1$1.define(regex, 'result', result);
        return regex;
    }
    return memoize$2('makeRe', pattern, options, makeRe);
};
/**
 * Parses the given glob `pattern` and returns an object with the compiled `output`
 * and optional source `map`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.create(pattern[, options]);
 *
 * console.log(nm.create('abc/*.js'));
 * // { options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */
nanomatch.create = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    function create() {
        return nanomatch.compile(nanomatch.parse(pattern, options), options);
    }
    return memoize$2('create', pattern, options, create);
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.parse(pattern[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */
nanomatch.parse = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    function parse() {
        var snapdragon = utils_1$1.instantiate(null, options);
        parsers$1(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils_1$1.define(ast, 'snapdragon', snapdragon);
        ast.input = pattern;
        return ast;
    }
    return memoize$2('parse', pattern, options, parse);
};
/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.compile(ast[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(nm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */
nanomatch.compile = function (ast, options) {
    if (typeof ast === 'string') {
        ast = nanomatch.parse(ast, options);
    }
    function compile() {
        var snapdragon = utils_1$1.instantiate(ast, options);
        compilers$1(snapdragon, options);
        return snapdragon.compile(ast, options);
    }
    return memoize$2('compile', ast.input, options, compile);
};
/**
 * Clear the regex cache.
 *
 * ```js
 * nm.clearCache();
 * ```
 * @api public
 */
nanomatch.clearCache = function () {
    nanomatch.cache.__data__ = {};
};
/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */
function compose(patterns, options, matcher) {
    var matchers;
    return memoize$2('compose', String(patterns), options, function () {
        return function (file) {
            // delay composition until it's invoked the first time,
            // after that it won't be called again
            if (!matchers) {
                matchers = [];
                for (var i = 0; i < patterns.length; i++) {
                    matchers.push(matcher(patterns[i], options));
                }
            }
            var len = matchers.length;
            while (len--) {
                if (matchers[len](file) === true) {
                    return true;
                }
            }
            return false;
        };
    });
}
/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */
function memoize$2(type, pattern, options, fn) {
    var key = utils_1$1.createKey(type + '=' + pattern, options);
    if (options && options.cache === false) {
        return fn(pattern, options);
    }
    if (cache$4.has(type, key)) {
        return cache$4.get(type, key);
    }
    var val = fn(pattern, options);
    cache$4.set(type, key, val);
    return val;
}
/**
 * Expose compiler, parser and cache on `nanomatch`
 */
nanomatch.compilers = compilers$1;
nanomatch.parsers = parsers$1;
nanomatch.cache = cache$4;
/**
 * Expose `nanomatch`
 * @type {Function}
 */
var nanomatch_1 = nanomatch;

var extendShallow$6 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$6(o, obj);
        }
    }
    return o;
};
function assign$6(a, b) {
    for (var key in b) {
        if (hasOwn$7(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$7(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

/**
 * POSIX character classes
 */
var posixCharacterClasses = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
};

var compilers$2 = function (brackets) {
    brackets.compiler
        /**
         * Escaped characters
         */
        .set('escape', function (node) {
        return this.emit('\\' + node.val.replace(/^\\/, ''), node);
    })
        /**
         * Text
         */
        .set('text', function (node) {
        return this.emit(node.val.replace(/([{}])/g, '\\$1'), node);
    })
        /**
         * POSIX character classes
         */
        .set('posix', function (node) {
        if (node.val === '[::]') {
            return this.emit('\\[::\\]', node);
        }
        var val = posixCharacterClasses[node.inner];
        if (typeof val === 'undefined') {
            val = '[' + node.inner + ']';
        }
        return this.emit(val, node);
    })
        /**
         * Non-posix brackets
         */
        .set('bracket', function (node) {
        return this.mapVisit(node.nodes);
    })
        .set('bracket.open', function (node) {
        return this.emit(node.val, node);
    })
        .set('bracket.inner', function (node) {
        var inner = node.val;
        if (inner === '[' || inner === ']') {
            return this.emit('\\' + node.val, node);
        }
        if (inner === '^]') {
            return this.emit('^\\]', node);
        }
        if (inner === '^') {
            return this.emit('^', node);
        }
        if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
            inner = inner.split('-').join('\\-');
        }
        var isNegated = inner.charAt(0) === '^';
        // add slashes to negated brackets, per spec
        if (isNegated && inner.indexOf('/') === -1) {
            inner += '/';
        }
        if (isNegated && inner.indexOf('.') === -1) {
            inner += '.';
        }
        // don't unescape `0` (octal literal)
        inner = inner.replace(/\\([1-9])/g, '$1');
        return this.emit(inner, node);
    })
        .set('bracket.close', function (node) {
        var val = node.val.replace(/^\\/, '');
        if (node.parent.escaped === true) {
            return this.emit('\\' + val, node);
        }
        return this.emit(val, node);
    });
};

var cached$1;
/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */
var last$1 = function (arr) {
    return arr[arr.length - 1];
};
/**
 * Create and cache regex to use for text nodes
 */
var createRegex = function (pattern, include) {
    if (cached$1)
        return cached$1;
    var opts = { contains: true, strictClose: false };
    var not = regexNot.create(pattern, opts);
    var re;
    if (typeof include === 'string') {
        re = toRegex$1('^(?:' + include + '|' + not + ')', opts);
    }
    else {
        re = toRegex$1(not, opts);
    }
    return (cached$1 = re);
};
var utils$2 = {
    last: last$1,
    createRegex: createRegex
};

var defineProperty$7 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$3(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

/**
 * Text regex
 */
var TEXT_REGEX = '(\\[(?=.*\\])|\\])+';
var not$2 = utils$2.createRegex(TEXT_REGEX);
/**
 * Brackets parsers
 */
function parsers$2(brackets) {
    brackets.state = brackets.state || {};
    brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
    brackets.parser
        .capture('escape', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
            return;
        return pos({
            type: 'escape',
            val: m[0]
        });
    })
        /**
         * Text parser
         */
        .capture('text', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(not$2);
        if (!m || !m[0])
            return;
        return pos({
            type: 'text',
            val: m[0]
        });
    })
        /**
         * POSIX character classes: "[[:alpha:][:digits:]]"
         */
        .capture('posix', function () {
        var pos = this.position();
        var m = this.match(/^\[:(.*?):\](?=.*\])/);
        if (!m)
            return;
        var inside = this.isInside('bracket');
        if (inside) {
            brackets.posix++;
        }
        return pos({
            type: 'posix',
            insideBracket: inside,
            inner: m[1],
            val: m[0]
        });
    })
        /**
         * Bracket (noop)
         */
        .capture('bracket', function () { })
        /**
         * Open: '['
         */
        .capture('bracket.open', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\[(?=.*\])/);
        if (!m)
            return;
        var prev = this.prev();
        var last = utils$2.last(prev.nodes);
        if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
            last.val = last.val.slice(0, last.val.length - 1);
            return pos({
                type: 'escape',
                val: m[0]
            });
        }
        var open = pos({
            type: 'bracket.open',
            val: m[0]
        });
        if (last.type === 'bracket.open' || this.isInside('bracket')) {
            open.val = '\\' + open.val;
            open.type = 'bracket.inner';
            open.escaped = true;
            return open;
        }
        var node = pos({
            type: 'bracket',
            nodes: [open]
        });
        defineProperty$7(node, 'parent', prev);
        defineProperty$7(open, 'parent', node);
        this.push('bracket', node);
        prev.nodes.push(node);
    })
        /**
         * Bracket text
         */
        .capture('bracket.inner', function () {
        if (!this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(not$2);
        if (!m || !m[0])
            return;
        var next = this.input.charAt(0);
        var val = m[0];
        var node = pos({
            type: 'bracket.inner',
            val: val
        });
        if (val === '\\\\') {
            return node;
        }
        var first = val.charAt(0);
        var last = val.slice(-1);
        if (first === '!') {
            val = '^' + val.slice(1);
        }
        if (last === '\\' || (val === '^' && next === ']')) {
            val += this.input[0];
            this.consume(1);
        }
        node.val = val;
        return node;
    })
        /**
         * Close: ']'
         */
        .capture('bracket.close', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\]/);
        if (!m)
            return;
        var prev = this.prev();
        var last = utils$2.last(prev.nodes);
        if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
            last.val = last.val.slice(0, last.val.length - 1);
            return pos({
                type: 'escape',
                val: m[0]
            });
        }
        var node = pos({
            type: 'bracket.close',
            rest: this.input,
            val: m[0]
        });
        if (last.type === 'bracket.open') {
            node.type = 'bracket.inner';
            node.escaped = true;
            return node;
        }
        var bracket = this.pop('bracket');
        if (!this.isType(bracket, 'bracket')) {
            if (this.options.strict) {
                throw new Error('missing opening "["');
            }
            node.type = 'bracket.inner';
            node.escaped = true;
            return node;
        }
        bracket.nodes.push(node);
        defineProperty$7(node, 'parent', bracket);
    });
}
/**
 * Brackets parsers
 */
var parsers_1 = parsers$2;
/**
 * Expose text regex
 */
var TEXT_REGEX_1 = TEXT_REGEX;
parsers_1.TEXT_REGEX = TEXT_REGEX_1;

var extendShallow$7 = function extend(o /*, objects*/) {
    if (!isExtendable$1(o)) {
        o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
        var obj = arguments[i];
        if (isExtendable$1(obj)) {
            assign$7(o, obj);
        }
    }
    return o;
};
function assign$7(a, b) {
    for (var key in b) {
        if (hasOwn$8(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */
function hasOwn$8(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

/**
 * Local dependencies
 */
/**
 * Module dependencies
 */
var debug$3 = src('expand-brackets');
/**
 * Parses the given POSIX character class `pattern` and returns a
 * string that can be used for creating regular expressions for matching.
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */
function brackets(pattern, options) {
    debug$3('initializing from <%s>', __filename);
    var res = brackets.create(pattern, options);
    return res.output;
}
/**
 * Takes an array of strings and a POSIX character class pattern, and returns a new
 * array with only the strings that matched the pattern.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
 * //=> ['a']
 *
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
 * //=> ['a', 'ab']
 * ```
 * @param {Array} `arr` Array of strings to match
 * @param {String} `pattern` POSIX character class pattern(s)
 * @param {Object} `options`
 * @return {Array}
 * @api public
 */
brackets.match = function (arr, pattern, options) {
    arr = [].concat(arr);
    var opts = extendShallow$7({}, options);
    var isMatch = brackets.matcher(pattern, opts);
    var len = arr.length;
    var idx = -1;
    var res = [];
    while (++idx < len) {
        var ele = arr[idx];
        if (isMatch(ele)) {
            res.push(ele);
        }
    }
    if (res.length === 0) {
        if (opts.failglob === true) {
            throw new Error('no matches found for "' + pattern + '"');
        }
        if (opts.nonull === true || opts.nullglob === true) {
            return [pattern.split('\\').join('')];
        }
    }
    return res;
};
/**
 * Returns true if the specified `string` matches the given
 * brackets `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 *
 * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
 * //=> true
 * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */
brackets.isMatch = function (str, pattern, options) {
    return brackets.matcher(pattern, options)(str);
};
/**
 * Takes a POSIX character class pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.A'));
 * //=> true
 * ```
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */
brackets.matcher = function (pattern, options) {
    var re = brackets.makeRe(pattern, options);
    return function (str) {
        return re.test(str);
    };
};
/**
 * Create a regular expression from the given `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var re = brackets.makeRe('[[:alpha:]]');
 * console.log(re);
 * //=> /^(?:[a-zA-Z])$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
brackets.makeRe = function (pattern, options) {
    var res = brackets.create(pattern, options);
    var opts = extendShallow$7({ strictErrors: false }, options);
    return toRegex$1(res.output, opts);
};
/**
 * Parses the given POSIX character class `pattern` and returns an object
 * with the compiled `output` and optional source `map`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets('[[:alpha:]]'));
 * // { options: { source: 'string' },
 * //   input: '[[:alpha:]]',
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      not: [Function],
 * //      escape: [Function],
 * //      text: [Function],
 * //      posix: [Function],
 * //      bracket: [Function],
 * //      'bracket.open': [Function],
 * //      'bracket.inner': [Function],
 * //      'bracket.literal': [Function],
 * //      'bracket.close': [Function] },
 * //   output: '[a-zA-Z]',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes: [ [Object], [Object], [Object] ] },
 * //   parsingErrors: [] }
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */
brackets.create = function (pattern, options) {
    var snapdragon$1 = (options && options.snapdragon) || new snapdragon(options);
    compilers$2(snapdragon$1);
    parsers_1(snapdragon$1);
    var ast = snapdragon$1.parse(pattern, options);
    ast.input = pattern;
    var res = snapdragon$1.compile(ast, options);
    res.input = pattern;
    return res;
};
/**
 * Expose `brackets` constructor, parsers and compilers
 */
brackets.compilers = compilers$2;
brackets.parsers = parsers_1;
/**
 * Expose `brackets`
 * @type {Function}
 */
var expandBrackets = brackets;

/**
 * Extglob compilers
 */
var compilers$3 = function (extglob) {
    function star() {
        if (typeof extglob.options.star === 'function') {
            return extglob.options.star.apply(this, arguments);
        }
        if (typeof extglob.options.star === 'string') {
            return extglob.options.star;
        }
        return '.*?';
    }
    /**
     * Use `expand-brackets` compilers
     */
    extglob.use(expandBrackets.compilers);
    extglob.compiler
        /**
         * Escaped: "\\*"
         */
        .set('escape', function (node) {
        return this.emit(node.val, node);
    })
        /**
         * Dot: "."
         */
        .set('dot', function (node) {
        return this.emit('\\' + node.val, node);
    })
        /**
         * Question mark: "?"
         */
        .set('qmark', function (node) {
        var val = '[^\\\\/.]';
        var prev = this.prev();
        if (node.parsed.slice(-1) === '(') {
            var ch = node.rest.charAt(0);
            if (ch !== '!' && ch !== '=' && ch !== ':') {
                return this.emit(val, node);
            }
            return this.emit(node.val, node);
        }
        if (prev.type === 'text' && prev.val) {
            return this.emit(val, node);
        }
        if (node.val.length > 1) {
            val += '{' + node.val.length + '}';
        }
        return this.emit(val, node);
    })
        /**
         * Plus: "+"
         */
        .set('plus', function (node) {
        var prev = node.parsed.slice(-1);
        if (prev === ']' || prev === ')') {
            return this.emit(node.val, node);
        }
        var ch = this.output.slice(-1);
        if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
            return this.emit('\\+', node);
        }
        if (/\w/.test(ch) && !node.inside) {
            return this.emit('+\\+?', node);
        }
        return this.emit('+', node);
    })
        /**
         * Star: "*"
         */
        .set('star', function (node) {
        var prev = this.prev();
        var prefix = prev.type !== 'text' && prev.type !== 'escape'
            ? '(?!\\.)'
            : '';
        return this.emit(prefix + star.call(this, node), node);
    })
        /**
         * Parens
         */
        .set('paren', function (node) {
        return this.mapVisit(node.nodes);
    })
        .set('paren.open', function (node) {
        var capture = this.options.capture ? '(' : '';
        switch (node.parent.prefix) {
            case '!':
            case '^':
                return this.emit(capture + '(?:(?!(?:', node);
            case '*':
            case '+':
            case '?':
            case '@':
                return this.emit(capture + '(?:', node);
            default: {
                var val = node.val;
                if (this.options.bash === true) {
                    val = '\\' + val;
                }
                else if (!this.options.capture && val === '(' && node.parent.rest[0] !== '?') {
                    val += '?:';
                }
                return this.emit(val, node);
            }
        }
    })
        .set('paren.close', function (node) {
        var capture = this.options.capture ? ')' : '';
        switch (node.prefix) {
            case '!':
            case '^':
                var prefix = /^(\)|$)/.test(node.rest) ? '$' : '';
                var str = star.call(this, node);
                // if the extglob has a slash explicitly defined, we know the user wants
                // to match slashes, so we need to ensure the "star" regex allows for it
                if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
                    str = '.*?';
                }
                return this.emit(prefix + ('))' + str + ')') + capture, node);
            case '*':
            case '+':
            case '?':
                return this.emit(')' + node.prefix + capture, node);
            case '@':
                return this.emit(')' + capture, node);
            default: {
                var val = (this.options.bash === true ? '\\' : '') + ')';
                return this.emit(val, node);
            }
        }
    })
        /**
         * Text
         */
        .set('text', function (node) {
        var val = node.val.replace(/[\[\]]/g, '\\$&');
        return this.emit(val, node);
    });
};

// accessor descriptor properties
var accessor$4 = {
    get: 'function',
    set: 'function',
    configurable: 'boolean',
    enumerable: 'boolean'
};
function isAccessorDescriptor$4(obj, prop) {
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (has$7(obj, 'value') || has$7(obj, 'writable')) {
        return false;
    }
    if (!has$7(obj, 'get') || typeof obj.get !== 'function') {
        return false;
    }
    // tldr: it's valid to have "set" be undefined
    // "set" might be undefined if `Object.getOwnPropertyDescriptor`
    // was used to get the value, and only `get` was defined by the user
    if (has$7(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
        return false;
    }
    for (var key in obj) {
        if (!accessor$4.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === accessor$4[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
}
function has$7(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
}
/**
 * Expose `isAccessorDescriptor`
 */
var isAccessorDescriptor_1$4 = isAccessorDescriptor$4;

var isDataDescriptor$4 = function isDataDescriptor(obj, prop) {
    // data descriptor properties
    var data = {
        configurable: 'boolean',
        enumerable: 'boolean',
        writable: 'boolean'
    };
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if (typeof prop === 'string') {
        var val = Object.getOwnPropertyDescriptor(obj, prop);
        return typeof val !== 'undefined';
    }
    if (!('value' in obj) && !('writable' in obj)) {
        return false;
    }
    for (var key in obj) {
        if (key === 'value')
            continue;
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        if (kindOf(obj[key]) === data[key]) {
            continue;
        }
        if (typeof obj[key] !== 'undefined') {
            return false;
        }
    }
    return true;
};

var isDescriptor$4 = function isDescriptor(obj, key) {
    if (kindOf(obj) !== 'object') {
        return false;
    }
    if ('get' in obj) {
        return isAccessorDescriptor_1$4(obj, key);
    }
    return isDataDescriptor$4(obj, key);
};

var defineProperty$8 = function defineProperty(obj, prop, val) {
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('expected an object or function.');
    }
    if (typeof prop !== 'string') {
        throw new TypeError('expected `prop` to be a string.');
    }
    if (isDescriptor$4(val) && ('set' in val || 'get' in val)) {
        return Object.defineProperty(obj, prop, val);
    }
    return Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val
    });
};

var utils_1$2 = createCommonjsModule(function (module) {
    /**
     * Utils
     */
    var utils = module.exports;
    var cache = utils.cache = new fragmentCache();
    /**
     * Cast `val` to an array
     * @return {Array}
     */
    utils.arrayify = function (val) {
        if (!Array.isArray(val)) {
            return [val];
        }
        return val;
    };
    /**
     * Memoize a generated regex or function
     */
    utils.memoize = function (type, pattern, options, fn) {
        var key = utils.createKey(type + pattern, options);
        if (cache.has(type, key)) {
            return cache.get(type, key);
        }
        var val = fn(pattern, options);
        if (options && options.cache === false) {
            return val;
        }
        cache.set(type, key, val);
        return val;
    };
    /**
     * Create the key to use for memoization. The key is generated
     * by iterating over the options and concatenating key-value pairs
     * to the pattern string.
     */
    utils.createKey = function (pattern, options) {
        var key = pattern;
        if (typeof options === 'undefined') {
            return key;
        }
        for (var prop in options) {
            key += ';' + prop + '=' + String(options[prop]);
        }
        return key;
    };
    /**
     * Create the regex to use for matching text
     */
    utils.createRegex = function (str) {
        var opts = { contains: true, strictClose: false };
        return regexNot(str, opts);
    };
});

/**
 * Characters to use in text regex (we want to "not" match
 * characters that are matched by other parsers)
 */
var TEXT_REGEX$1 = '([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+';
var not$3 = utils_1$2.createRegex(TEXT_REGEX$1);
/**
 * Extglob parsers
 */
function parsers$3(extglob) {
    extglob.state = extglob.state || {};
    /**
     * Use `expand-brackets` parsers
     */
    extglob.use(expandBrackets.parsers);
    extglob.parser.sets.paren = extglob.parser.sets.paren || [];
    extglob.parser
        /**
         * Extglob open: "*("
         */
        .capture('paren.open', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^([!@*?+])?\(/);
        if (!m)
            return;
        var prev = this.prev();
        var prefix = m[1];
        var val = m[0];
        var open = pos({
            type: 'paren.open',
            parsed: parsed,
            val: val
        });
        var node = pos({
            type: 'paren',
            prefix: prefix,
            nodes: [open]
        });
        // if nested negation extglobs, just cancel them out to simplify
        if (prefix === '!' && prev.type === 'paren' && prev.prefix === '!') {
            prev.prefix = '@';
            node.prefix = '@';
        }
        defineProperty$8(node, 'rest', this.input);
        defineProperty$8(node, 'parsed', parsed);
        defineProperty$8(node, 'parent', prev);
        defineProperty$8(open, 'parent', node);
        this.push('paren', node);
        prev.nodes.push(node);
    })
        /**
         * Extglob close: ")"
         */
        .capture('paren.close', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\)/);
        if (!m)
            return;
        var parent = this.pop('paren');
        var node = pos({
            type: 'paren.close',
            rest: this.input,
            parsed: parsed,
            val: m[0]
        });
        if (!this.isType(parent, 'paren')) {
            if (this.options.strict) {
                throw new Error('missing opening paren: "("');
            }
            node.escaped = true;
            return node;
        }
        node.prefix = parent.prefix;
        parent.nodes.push(node);
        defineProperty$8(node, 'parent', parent);
    })
        /**
         * Escape: "\\."
         */
        .capture('escape', function () {
        var pos = this.position();
        var m = this.match(/^\\(.)/);
        if (!m)
            return;
        return pos({
            type: 'escape',
            val: m[0],
            ch: m[1]
        });
    })
        /**
         * Question marks: "?"
         */
        .capture('qmark', function () {
        var parsed = this.parsed;
        var pos = this.position();
        var m = this.match(/^\?+(?!\()/);
        if (!m)
            return;
        extglob.state.metachar = true;
        return pos({
            type: 'qmark',
            rest: this.input,
            parsed: parsed,
            val: m[0]
        });
    })
        /**
         * Character parsers
         */
        .capture('star', /^\*(?!\()/)
        .capture('plus', /^\+(?!\()/)
        .capture('dot', /^\./)
        .capture('text', not$3);
}
/**
 * Expose text regex string
 */
var TEXT_REGEX_1$1 = TEXT_REGEX$1;
/**
 * Extglob parsers
 */
var parsers_1$1 = parsers$3;
parsers_1$1.TEXT_REGEX = TEXT_REGEX_1$1;

/**
 * Module dependencies
 */
/**
 * Local dependencies
 */
/**
 * Customize Snapdragon parser and renderer
 */
function Extglob(options) {
    this.options = extendShallow$6({ source: 'extglob' }, options);
    this.snapdragon = this.options.snapdragon || new snapdragon(this.options);
    this.snapdragon.patterns = this.snapdragon.patterns || {};
    this.compiler = this.snapdragon.compiler;
    this.parser = this.snapdragon.parser;
    compilers$3(this.snapdragon);
    parsers_1$1(this.snapdragon);
    /**
     * Override Snapdragon `.parse` method
     */
    defineProperty$8(this.snapdragon, 'parse', function (str, options) {
        var parsed = snapdragon.prototype.parse.apply(this, arguments);
        parsed.input = str;
        // escape unmatched brace/bracket/parens
        var last = this.parser.stack.pop();
        if (last && this.options.strict !== true) {
            var node = last.nodes[0];
            node.val = '\\' + node.val;
            var sibling = node.parent.nodes[1];
            if (sibling.type === 'star') {
                sibling.loose = true;
            }
        }
        // add non-enumerable parser reference
        defineProperty$8(parsed, 'parser', this.parser);
        return parsed;
    });
    /**
     * Decorate `.parse` method
     */
    defineProperty$8(this, 'parse', function (ast, options) {
        return this.snapdragon.parse.apply(this.snapdragon, arguments);
    });
    /**
     * Decorate `.compile` method
     */
    defineProperty$8(this, 'compile', function (ast, options) {
        return this.snapdragon.compile.apply(this.snapdragon, arguments);
    });
}
/**
 * Expose `Extglob`
 */
var extglob = Extglob;

/**
 * Module dependencies
 */
/**
 * Local dependencies
 */
var MAX_LENGTH$3 = 1024 * 64;
/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob('*.!(*a)'));
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */
function extglob$1(pattern, options) {
    return extglob$1.create(pattern, options).output;
}
/**
 * Takes an array of strings and an extglob pattern and returns a new
 * array that contains only the strings that match the pattern.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
 * //=> ['a.b', 'a.c']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Extglob pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of matches
 * @api public
 */
extglob$1.match = function (list, pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    list = utils_1$2.arrayify(list);
    var isMatch = extglob$1.matcher(pattern, options);
    var len = list.length;
    var idx = -1;
    var matches = [];
    while (++idx < len) {
        var ele = list[idx];
        if (isMatch(ele)) {
            matches.push(ele);
        }
    }
    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
        return arrayUnique(matches);
    }
    if (matches.length === 0) {
        if (options.failglob === true) {
            throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
            return [pattern.split('\\').join('')];
        }
    }
    return options.nodupes !== false ? arrayUnique(matches) : matches;
};
/**
 * Returns true if the specified `string` matches the given
 * extglob `pattern`.
 *
 * ```js
 * var extglob = require('extglob');
 *
 * console.log(extglob.isMatch('a.a', '*.!(*a)'));
 * //=> false
 * console.log(extglob.isMatch('a.b', '*.!(*a)'));
 * //=> true
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */
extglob$1.isMatch = function (str, pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    if (typeof str !== 'string') {
        throw new TypeError('expected a string');
    }
    if (pattern === str) {
        return true;
    }
    if (pattern === '' || pattern === ' ' || pattern === '.') {
        return pattern === str;
    }
    var isMatch = utils_1$2.memoize('isMatch', pattern, options, extglob$1.matcher);
    return isMatch(str);
};
/**
 * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
 * the pattern can match any part of the string.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(extglob.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options`
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */
extglob$1.contains = function (str, pattern, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string');
    }
    if (pattern === '' || pattern === ' ' || pattern === '.') {
        return pattern === str;
    }
    var opts = extendShallow$6({}, options, { contains: true });
    opts.strictClose = false;
    opts.strictOpen = false;
    return extglob$1.isMatch(str, pattern, opts);
};
/**
 * Takes an extglob pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var extglob = require('extglob');
 * var isMatch = extglob.matcher('*.!(*a)');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */
extglob$1.matcher = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    function matcher() {
        var re = extglob$1.makeRe(pattern, options);
        return function (str) {
            return re.test(str);
        };
    }
    return utils_1$2.memoize('matcher', pattern, options, matcher);
};
/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.create('*.!(*a)').output);
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */
extglob$1.create = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    function create() {
        var ext = new extglob(options);
        var ast = ext.parse(pattern, options);
        return ext.compile(ast, options);
    }
    return utils_1$2.memoize('create', pattern, options, create);
};
/**
 * Returns an array of matches captured by `pattern` in `string`, or `null`
 * if the pattern did not match.
 *
 * ```js
 * var extglob = require('extglob');
 * extglob.capture(pattern, string[, options]);
 *
 * console.log(extglob.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */
extglob$1.capture = function (pattern, str, options) {
    var re = extglob$1.makeRe(pattern, extendShallow$6({ capture: true }, options));
    function match() {
        return function (string) {
            var match = re.exec(string);
            if (!match) {
                return null;
            }
            return match.slice(1);
        };
    }
    var capture = utils_1$2.memoize('capture', pattern, options, match);
    return capture(str);
};
/**
 * Create a regular expression from the given `pattern` and `options`.
 *
 * ```js
 * var extglob = require('extglob');
 * var re = extglob.makeRe('*.!(*a)');
 * console.log(re);
 * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */
extglob$1.makeRe = function (pattern, options) {
    if (pattern instanceof RegExp) {
        return pattern;
    }
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    if (pattern.length > MAX_LENGTH$3) {
        throw new Error('expected pattern to be less than ' + MAX_LENGTH$3 + ' characters');
    }
    function makeRe() {
        var opts = extendShallow$6({ strictErrors: false }, options);
        if (opts.strictErrors === true)
            opts.strict = true;
        var res = extglob$1.create(pattern, opts);
        return toRegex$1(res.output, opts);
    }
    var regex = utils_1$2.memoize('makeRe', pattern, options, makeRe);
    if (regex.source.length > MAX_LENGTH$3) {
        throw new SyntaxError('potentially malicious regex detected');
    }
    return regex;
};
/**
 * Cache
 */
extglob$1.cache = utils_1$2.cache;
extglob$1.clearCache = function () {
    extglob$1.cache.__data__ = {};
};
/**
 * Expose `Extglob` constructor, parsers and compilers
 */
extglob$1.Extglob = extglob;
extglob$1.compilers = compilers$3;
extglob$1.parsers = parsers_1$1;
/**
 * Expose `extglob`
 * @type {Function}
 */
var extglob_1 = extglob$1;

var compilers$4 = function (snapdragon) {
    var compilers = snapdragon.compiler.compilers;
    var opts = snapdragon.options;
    // register nanomatch compilers
    snapdragon.use(nanomatch_1.compilers);
    // get references to some specific nanomatch compilers before they
    // are overridden by the extglob and/or custom compilers
    var escape = compilers.escape;
    var qmark = compilers.qmark;
    var slash = compilers.slash;
    var star = compilers.star;
    var text = compilers.text;
    var plus = compilers.plus;
    var dot = compilers.dot;
    // register extglob compilers or escape exglobs if disabled
    if (opts.extglob === false || opts.noext === true) {
        snapdragon.compiler.use(escapeExtglobs);
    }
    else {
        snapdragon.use(extglob_1.compilers);
    }
    snapdragon.use(function () {
        this.options.star = this.options.star || function ( /*node*/) {
            return '[^\\\\/]*?';
        };
    });
    // custom micromatch compilers
    snapdragon.compiler
        // reset referenced compiler
        .set('dot', dot)
        .set('escape', escape)
        .set('plus', plus)
        .set('slash', slash)
        .set('qmark', qmark)
        .set('star', star)
        .set('text', text);
};
function escapeExtglobs(compiler) {
    compiler.set('paren', function (node) {
        var val = '';
        visit(node, function (tok) {
            if (tok.val)
                val += (/^\W/.test(tok.val) ? '\\' : '') + tok.val;
        });
        return this.emit(val, node);
    });
    /**
     * Visit `node` with the given `fn`
     */
    function visit(node, fn) {
        return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
    }
    /**
     * Map visit over array of `nodes`.
     */
    function mapVisit(nodes, fn) {
        var len = nodes.length;
        var idx = -1;
        while (++idx < len) {
            visit(nodes[idx], fn);
        }
    }
}

var not$4;
/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */
var TEXT = '([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+';
var createNotRegex = function (opts) {
    return not$4 || (not$4 = textRegex(TEXT));
};
/**
 * Parsers
 */
var parsers$4 = function (snapdragon) {
    var parsers = snapdragon.parser.parsers;
    // register nanomatch parsers
    snapdragon.use(nanomatch_1.parsers);
    // get references to some specific nanomatch parsers before they
    // are overridden by the extglob and/or parsers
    var escape = parsers.escape;
    var slash = parsers.slash;
    var qmark = parsers.qmark;
    var plus = parsers.plus;
    var star = parsers.star;
    var dot = parsers.dot;
    // register extglob parsers
    snapdragon.use(extglob_1.parsers);
    // custom micromatch parsers
    snapdragon.parser
        .use(function () {
        // override "notRegex" created in nanomatch parser
        this.notRegex = /^\!+(?!\()/;
    })
        // reset the referenced parsers
        .capture('escape', escape)
        .capture('slash', slash)
        .capture('qmark', qmark)
        .capture('star', star)
        .capture('plus', plus)
        .capture('dot', dot)
        /**
         * Override `text` parser
         */
        .capture('text', function () {
        if (this.isInside('bracket'))
            return;
        var pos = this.position();
        var m = this.match(createNotRegex(this.options));
        if (!m || !m[0])
            return;
        // escape regex boundary characters and simple brackets
        var val = m[0].replace(/([[\]^$])/g, '\\$1');
        return pos({
            type: 'text',
            val: val
        });
    });
};
/**
 * Create text regex
 */
function textRegex(pattern) {
    var notStr = regexNot.create(pattern, { contains: true, strictClose: false });
    var prefix = '(?:[\\^]|\\\\|';
    return toRegex$1(prefix + notStr + ')', { strictClose: false });
}

var cache$5 = new (fragmentCache)();

var utils_1$3 = createCommonjsModule(function (module) {
    var utils = module.exports;
    /**
     * Module dependencies
     */
    utils.define = defineProperty;
    utils.diff = arrDiff;
    utils.extend = extendShallow;
    utils.pick = object_pick;
    utils.typeOf = kindOf;
    utils.unique = arrayUnique;
    /**
     * Returns true if the platform is windows, or `path.sep` is `\\`.
     * This is defined as a function to allow `path.sep` to be set in unit tests,
     * or by the user, if there is a reason to do so.
     * @return {Boolean}
     */
    utils.isWindows = function () {
        return path.sep === '\\' || process.platform === 'win32';
    };
    /**
     * Get the `Snapdragon` instance to use
     */
    utils.instantiate = function (ast, options) {
        var snapdragon$1;
        // if an instance was created by `.parse`, use that instance
        if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
            snapdragon$1 = ast.snapdragon;
            // if the user supplies an instance on options, use that instance
        }
        else if (utils.typeOf(options) === 'object' && options.snapdragon) {
            snapdragon$1 = options.snapdragon;
            // create a new instance
        }
        else {
            snapdragon$1 = new snapdragon(options);
        }
        utils.define(snapdragon$1, 'parse', function (str, options) {
            var parsed = snapdragon.prototype.parse.apply(this, arguments);
            parsed.input = str;
            // escape unmatched brace/bracket/parens
            var last = this.parser.stack.pop();
            if (last && this.options.strictErrors !== true) {
                var open = last.nodes[0];
                var inner = last.nodes[1];
                if (last.type === 'bracket') {
                    if (inner.val.charAt(0) === '[') {
                        inner.val = '\\' + inner.val;
                    }
                }
                else {
                    open.val = '\\' + open.val;
                    var sibling = open.parent.nodes[1];
                    if (sibling.type === 'star') {
                        sibling.loose = true;
                    }
                }
            }
            // add non-enumerable parser reference
            utils.define(parsed, 'parser', this.parser);
            return parsed;
        });
        return snapdragon$1;
    };
    /**
     * Create the key to use for memoization. The key is generated
     * by iterating over the options and concatenating key-value pairs
     * to the pattern string.
     */
    utils.createKey = function (pattern, options) {
        if (utils.typeOf(options) !== 'object') {
            return pattern;
        }
        var val = pattern;
        var keys = Object.keys(options);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            val += ';' + key + '=' + String(options[key]);
        }
        return val;
    };
    /**
     * Cast `val` to an array
     * @return {Array}
     */
    utils.arrayify = function (val) {
        if (typeof val === 'string')
            return [val];
        return val ? (Array.isArray(val) ? val : [val]) : [];
    };
    /**
     * Return true if `val` is a non-empty string
     */
    utils.isString = function (val) {
        return typeof val === 'string';
    };
    /**
     * Return true if `val` is a non-empty string
     */
    utils.isObject = function (val) {
        return utils.typeOf(val) === 'object';
    };
    /**
     * Returns true if the given `str` has special characters
     */
    utils.hasSpecialChars = function (str) {
        return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
    };
    /**
     * Escape regex characters in the given string
     */
    utils.escapeRegex = function (str) {
        return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, '\\$&');
    };
    /**
     * Normalize slashes in the given filepath.
     *
     * @param {String} `filepath`
     * @return {String}
     */
    utils.toPosixPath = function (str) {
        return str.replace(/\\+/g, '/');
    };
    /**
     * Strip backslashes before special characters in a string.
     *
     * @param {String} `str`
     * @return {String}
     */
    utils.unescape = function (str) {
        return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
    };
    /**
     * Strip the prefix from a filepath
     * @param {String} `fp`
     * @return {String}
     */
    utils.stripPrefix = function (str) {
        if (str.charAt(0) !== '.') {
            return str;
        }
        var ch = str.charAt(1);
        if (utils.isSlash(ch)) {
            return str.slice(2);
        }
        return str;
    };
    /**
     * Returns true if the given str is an escaped or
     * unescaped path character
     */
    utils.isSlash = function (str) {
        return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
    };
    /**
     * Returns a function that returns true if the given
     * pattern matches or contains a `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.matchPath = function (pattern, options) {
        return (options && options.contains)
            ? utils.containsPattern(pattern, options)
            : utils.equalsPattern(pattern, options);
    };
    /**
     * Returns true if the given (original) filepath or unixified path are equal
     * to the given pattern.
     */
    utils._equals = function (filepath, unixPath, pattern) {
        return pattern === filepath || pattern === unixPath;
    };
    /**
     * Returns true if the given (original) filepath or unixified path contain
     * the given pattern.
     */
    utils._contains = function (filepath, unixPath, pattern) {
        return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
    };
    /**
     * Returns a function that returns true if the given
     * pattern is the same as a given `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.equalsPattern = function (pattern, options) {
        var unixify = utils.unixify(options);
        options = options || {};
        return function fn(filepath) {
            var equal = utils._equals(filepath, unixify(filepath), pattern);
            if (equal === true || options.nocase !== true) {
                return equal;
            }
            var lower = filepath.toLowerCase();
            return utils._equals(lower, unixify(lower), pattern);
        };
    };
    /**
     * Returns a function that returns true if the given
     * pattern contains a `filepath`
     *
     * @param {String} `pattern`
     * @return {Function}
     */
    utils.containsPattern = function (pattern, options) {
        var unixify = utils.unixify(options);
        options = options || {};
        return function (filepath) {
            var contains = utils._contains(filepath, unixify(filepath), pattern);
            if (contains === true || options.nocase !== true) {
                return contains;
            }
            var lower = filepath.toLowerCase();
            return utils._contains(lower, unixify(lower), pattern);
        };
    };
    /**
     * Returns a function that returns true if the given
     * regex matches the `filename` of a file path.
     *
     * @param {RegExp} `re` Matching regex
     * @return {Function}
     */
    utils.matchBasename = function (re) {
        return function (filepath) {
            return re.test(path.basename(filepath));
        };
    };
    /**
     * Determines the filepath to return based on the provided options.
     * @return {any}
     */
    utils.value = function (str, unixify, options) {
        if (options && options.unixify === false) {
            return str;
        }
        return unixify(str);
    };
    /**
     * Returns a function that normalizes slashes in a string to forward
     * slashes, strips `./` from beginning of paths, and optionally unescapes
     * special characters.
     * @return {Function}
     */
    utils.unixify = function (options) {
        options = options || {};
        return function (filepath) {
            if (utils.isWindows() || options.unixify === true) {
                filepath = utils.toPosixPath(filepath);
            }
            if (options.stripPrefix !== false) {
                filepath = utils.stripPrefix(filepath);
            }
            if (options.unescape === true) {
                filepath = utils.unescape(filepath);
            }
            return filepath;
        };
    };
});

/**
 * Module dependencies
 */
/**
 * Local dependencies
 */
var MAX_LENGTH$4 = 1024 * 64;
/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var mm = require('micromatch');
 * mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */
function micromatch(list, patterns, options) {
    patterns = utils_1$3.arrayify(patterns);
    list = utils_1$3.arrayify(list);
    var len = patterns.length;
    if (list.length === 0 || len === 0) {
        return [];
    }
    if (len === 1) {
        return micromatch.match(list, patterns[0], options);
    }
    var omit = [];
    var keep = [];
    var idx = -1;
    while (++idx < len) {
        var pattern = patterns[idx];
        if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
            omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
        }
        else {
            keep.push.apply(keep, micromatch.match(list, pattern, options));
        }
    }
    var matches = utils_1$3.diff(keep, omit);
    if (!options || options.nodupes !== false) {
        return utils_1$3.unique(matches);
    }
    return matches;
}
/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.match(list, pattern[, options]);
 *
 * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */
micromatch.match = function (list, pattern, options) {
    if (Array.isArray(pattern)) {
        throw new TypeError('expected pattern to be a string');
    }
    var unixify = utils_1$3.unixify(options);
    var isMatch = memoize$3('match', pattern, options, micromatch.matcher);
    var matches = [];
    list = utils_1$3.arrayify(list);
    var len = list.length;
    var idx = -1;
    while (++idx < len) {
        var ele = list[idx];
        if (ele === pattern || isMatch(ele)) {
            matches.push(utils_1$3.value(ele, unixify, options));
        }
    }
    // if no options were passed, uniquify results and return
    if (typeof options === 'undefined') {
        return utils_1$3.unique(matches);
    }
    if (matches.length === 0) {
        if (options.failglob === true) {
            throw new Error('no matches found for "' + pattern + '"');
        }
        if (options.nonull === true || options.nullglob === true) {
            return [options.unescape ? utils_1$3.unescape(pattern) : pattern];
        }
    }
    // if `opts.ignore` was defined, diff ignored list
    if (options.ignore) {
        matches = micromatch.not(matches, options.ignore, options);
    }
    return options.nodupes !== false ? utils_1$3.unique(matches) : matches;
};
/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.isMatch(string, pattern[, options]);
 *
 * console.log(mm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(mm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */
micromatch.isMatch = function (str, pattern, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
    }
    var equals = utils_1$3.equalsPattern(options);
    if (equals(str)) {
        return true;
    }
    var isMatch = memoize$3('isMatch', pattern, options, micromatch.matcher);
    return isMatch(str);
};
/**
 * Returns true if some of the strings in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
micromatch.some = function (list, patterns, options) {
    if (typeof list === 'string') {
        list = [list];
    }
    for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length === 1) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
micromatch.every = function (list, patterns, options) {
    if (typeof list === 'string') {
        list = [list];
    }
    for (var i = 0; i < list.length; i++) {
        if (micromatch(list[i], patterns, options).length !== 1) {
            return false;
        }
    }
    return true;
};
/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.any(string, patterns[, options]);
 *
 * console.log(mm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(mm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
micromatch.any = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (isEmptyString(str) || isEmptyString(patterns)) {
        return false;
    }
    if (typeof patterns === 'string') {
        patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
        if (micromatch.isMatch(str, patterns[i], options)) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */
micromatch.all = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (typeof patterns === 'string') {
        patterns = [patterns];
    }
    for (var i = 0; i < patterns.length; i++) {
        if (!micromatch.isMatch(str, patterns[i], options)) {
            return false;
        }
    }
    return true;
};
/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */
micromatch.not = function (list, patterns, options) {
    var opts = extendShallow({}, options);
    var ignore = opts.ignore;
    delete opts.ignore;
    var unixify = utils_1$3.unixify(opts);
    list = utils_1$3.arrayify(list).map(unixify);
    var matches = utils_1$3.diff(list, micromatch(list, patterns, opts));
    if (ignore) {
        matches = utils_1$3.diff(matches, micromatch(list, ignore));
    }
    return opts.nodupes !== false ? utils_1$3.unique(matches) : matches;
};
/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */
micromatch.contains = function (str, patterns, options) {
    if (typeof str !== 'string') {
        throw new TypeError('expected a string: "' + util$2.inspect(str) + '"');
    }
    if (typeof patterns === 'string') {
        if (isEmptyString(str) || isEmptyString(patterns)) {
            return false;
        }
        var equals = utils_1$3.equalsPattern(patterns, options);
        if (equals(str)) {
            return true;
        }
        var contains = utils_1$3.containsPattern(patterns, options);
        if (contains(str)) {
            return true;
        }
    }
    var opts = extendShallow({}, options, { contains: true });
    return micromatch.any(str, patterns, opts);
};
/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */
micromatch.matchBase = function (pattern, options) {
    if (pattern && pattern.indexOf('/') !== -1 || !options)
        return false;
    return options.basename === true || options.matchBase === true;
};
/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */
micromatch.matchKeys = function (obj, patterns, options) {
    if (!utils_1$3.isObject(obj)) {
        throw new TypeError('expected the first argument to be an object');
    }
    var keys = micromatch(Object.keys(obj), patterns, options);
    return utils_1$3.pick(obj, keys);
};
/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matcher(pattern[, options]);
 *
 * var isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */
micromatch.matcher = function matcher(pattern, options) {
    if (Array.isArray(pattern)) {
        return compose$1(pattern, options, matcher);
    }
    // if pattern is a regex
    if (pattern instanceof RegExp) {
        return test(pattern);
    }
    // if pattern is invalid
    if (!utils_1$3.isString(pattern)) {
        throw new TypeError('expected pattern to be an array, string or regex');
    }
    // if pattern is a non-glob string
    if (!utils_1$3.hasSpecialChars(pattern)) {
        if (options && options.nocase === true) {
            pattern = pattern.toLowerCase();
        }
        return utils_1$3.matchPath(pattern, options);
    }
    // if pattern is a glob string
    var re = micromatch.makeRe(pattern, options);
    // if `options.matchBase` or `options.basename` is defined
    if (micromatch.matchBase(pattern, options)) {
        return utils_1$3.matchBasename(re, options);
    }
    function test(regex) {
        var equals = utils_1$3.equalsPattern(options);
        var unixify = utils_1$3.unixify(options);
        return function (str) {
            if (equals(str)) {
                return true;
            }
            if (regex.test(unixify(str))) {
                return true;
            }
            return false;
        };
    }
    var fn = test(re);
    Object.defineProperty(fn, 'result', {
        configurable: true,
        enumerable: false,
        value: re.result
    });
    return fn;
};
/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */
micromatch.capture = function (pattern, str, options) {
    var re = micromatch.makeRe(pattern, extendShallow({ capture: true }, options));
    var unixify = utils_1$3.unixify(options);
    function match() {
        return function (string) {
            var match = re.exec(unixify(string));
            if (!match) {
                return null;
            }
            return match.slice(1);
        };
    }
    var capture = memoize$3('capture', pattern, options, match);
    return capture(str);
};
/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */
micromatch.makeRe = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected pattern to be a string');
    }
    if (pattern.length > MAX_LENGTH$4) {
        throw new Error('expected pattern to be less than ' + MAX_LENGTH$4 + ' characters');
    }
    function makeRe() {
        var result = micromatch.create(pattern, options);
        var ast_array = [];
        var output = result.map(function (obj) {
            obj.ast.state = obj.state;
            ast_array.push(obj.ast);
            return obj.output;
        });
        var regex = toRegex$1(output.join('|'), options);
        Object.defineProperty(regex, 'result', {
            configurable: true,
            enumerable: false,
            value: ast_array
        });
        return regex;
    }
    return memoize$3('makeRe', pattern, options, makeRe);
};
/**
 * Expand the given brace `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * console.log(mm.braces('foo/{a,b}/bar'));
 * //=> ['foo/(a|b)/bar']
 *
 * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
 * //=> ['foo/(a|b)/bar']
 * ```
 * @param {String} `pattern` String with brace pattern to expand.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */
micromatch.braces = function (pattern, options) {
    if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
        throw new TypeError('expected pattern to be an array or string');
    }
    function expand() {
        if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
            return utils_1$3.arrayify(pattern);
        }
        return braces_1(pattern, options);
    }
    return memoize$3('braces', pattern, options, expand);
};
/**
 * Proxy to the [micromatch.braces](#method), for parity with
 * minimatch.
 */
micromatch.braceExpand = function (pattern, options) {
    var opts = extendShallow({}, options, { expand: true });
    return micromatch.braces(pattern, opts);
};
/**
 * Parses the given glob `pattern` and returns an array of abstract syntax
 * trees (ASTs), with the compiled `output` and optional source `map` on
 * each AST.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.create(pattern[, options]);
 *
 * console.log(mm.create('abc/*.js'));
 * // [{ options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }]
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */
micromatch.create = function (pattern, options) {
    return memoize$3('create', pattern, options, function () {
        function create(str, opts) {
            return micromatch.compile(micromatch.parse(str, opts), opts);
        }
        pattern = micromatch.braces(pattern, options);
        var len = pattern.length;
        var idx = -1;
        var res = [];
        while (++idx < len) {
            res.push(create(pattern[idx], options));
        }
        return res;
    });
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.parse(pattern[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */
micromatch.parse = function (pattern, options) {
    if (typeof pattern !== 'string') {
        throw new TypeError('expected a string');
    }
    function parse() {
        var snapdragon = utils_1$3.instantiate(null, options);
        parsers$4(snapdragon, options);
        var ast = snapdragon.parse(pattern, options);
        utils_1$3.define(ast, 'snapdragon', snapdragon);
        ast.input = pattern;
        return ast;
    }
    return memoize$3('parse', pattern, options, parse);
};
/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.compile(ast[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(mm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */
micromatch.compile = function (ast, options) {
    if (typeof ast === 'string') {
        ast = micromatch.parse(ast, options);
    }
    return memoize$3('compile', ast.input, options, function () {
        var snapdragon = utils_1$3.instantiate(ast, options);
        compilers$4(snapdragon, options);
        return snapdragon.compile(ast, options);
    });
};
/**
 * Clear the regex cache.
 *
 * ```js
 * mm.clearCache();
 * ```
 * @api public
 */
micromatch.clearCache = function () {
    micromatch.cache.caches = {};
};
/**
 * Returns true if the given value is effectively an empty string
 */
function isEmptyString(val) {
    return String(val) === '' || String(val) === './';
}
/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */
function compose$1(patterns, options, matcher) {
    var matchers;
    return memoize$3('compose', String(patterns), options, function () {
        return function (file) {
            // delay composition until it's invoked the first time,
            // after that it won't be called again
            if (!matchers) {
                matchers = [];
                for (var i = 0; i < patterns.length; i++) {
                    matchers.push(matcher(patterns[i], options));
                }
            }
            var len = matchers.length;
            while (len--) {
                if (matchers[len](file) === true) {
                    return true;
                }
            }
            return false;
        };
    });
}
/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */
function memoize$3(type, pattern, options, fn) {
    var key = utils_1$3.createKey(type + '=' + pattern, options);
    if (options && options.cache === false) {
        return fn(pattern, options);
    }
    if (cache$5.has(type, key)) {
        return cache$5.get(type, key);
    }
    var val = fn(pattern, options);
    cache$5.set(type, key, val);
    return val;
}
/**
 * Expose compiler, parser and cache on `micromatch`
 */
micromatch.compilers = compilers$4;
micromatch.parsers = parsers$4;
micromatch.caches = cache$5.caches;
/**
 * Expose `micromatch`
 * @type {Function}
 */
var micromatch_1 = micromatch;
var micromatch_2 = micromatch_1.matcher;

function ensureArray(thing) {
    if (Array.isArray(thing))
        return thing;
    if (thing == undefined)
        return [];
    return [thing];
}

function getMatcherString(id, resolutionBase) {
    if (resolutionBase === false) {
        return id;
    }
    return resolve$1(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));
}
const createFilter = function createFilter(include, exclude, options) {
    const resolutionBase = options && options.resolve;
    const getMatcher = (id) => {
        return id instanceof RegExp
            ? id
            : {
                test: micromatch_2(getMatcherString(id, resolutionBase)
                    .split(sep)
                    .join('/'))
            };
    };
    const includeMatchers = ensureArray(include).map(getMatcher);
    const excludeMatchers = ensureArray(exclude).map(getMatcher);
    return function (id) {
        if (typeof id !== 'string')
            return false;
        if (/\0/.test(id))
            return false;
        id = id.split(sep).join('/');
        for (let i = 0; i < excludeMatchers.length; ++i) {
            const matcher = excludeMatchers[i];
            if (matcher.test(id))
                return false;
        }
        for (let i = 0; i < includeMatchers.length; ++i) {
            const matcher = includeMatchers[i];
            if (matcher.test(id))
                return true;
        }
        return !includeMatchers.length;
    };
};

var modules = {};
var getModule = function (dir) {
    var rootPath = dir ? path.resolve(dir) : process.cwd();
    var rootName = path.join(rootPath, '@root');
    var root = modules[rootName];
    if (!root) {
        root = new module$1(rootName);
        root.filename = rootName;
        root.paths = module$1._nodeModulePaths(rootPath);
        modules[rootName] = root;
    }
    return root;
};
var requireRelative = function (requested, relativeTo) {
    var root = getModule(relativeTo);
    return root.require(requested);
};
requireRelative.resolve = function (requested, relativeTo) {
    var root = getModule(relativeTo);
    return module$1._resolveFilename(requested, root);
};
var requireRelative_1 = requireRelative;

let chokidar;
try {
    chokidar = requireRelative_1('chokidar', process.cwd());
}
catch (err) {
    chokidar = null;
}
var chokidar$1 = chokidar;

const opts = { encoding: 'utf-8', persistent: true };
const watchers = new Map();
function addTask(id, task, chokidarOptions, chokidarOptionsHash, isTransformDependency) {
    if (!watchers.has(chokidarOptionsHash))
        watchers.set(chokidarOptionsHash, new Map());
    const group = watchers.get(chokidarOptionsHash);
    const watcher = group.get(id) || new FileWatcher(id, chokidarOptions, group);
    if (!watcher.fileExists) {
        if (isTransformDependency)
            throw new Error(`Transform dependency ${id} does not exist.`);
    }
    else {
        watcher.addTask(task, isTransformDependency);
    }
}
function deleteTask(id, target, chokidarOptionsHash) {
    const group = watchers.get(chokidarOptionsHash);
    const watcher = group.get(id);
    if (watcher)
        watcher.deleteTask(target, group);
}
class FileWatcher {
    constructor(id, chokidarOptions, group) {
        this.id = id;
        this.tasks = new Set();
        this.transformDependencyTasks = new Set();
        let modifiedTime;
        try {
            const stats = statSync(id);
            modifiedTime = +stats.mtime;
            this.fileExists = true;
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                // can't watch files that don't exist (e.g. injected
                // by plugins somehow)
                this.fileExists = false;
                return;
            }
            else {
                throw err;
            }
        }
        const handleWatchEvent = (event) => {
            if (event === 'rename' || event === 'unlink') {
                this.close();
                group.delete(id);
                this.trigger(id);
            }
            else {
                let stats;
                try {
                    stats = statSync(id);
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        modifiedTime = -1;
                        this.trigger(id);
                        return;
                    }
                    throw err;
                }
                // debounce
                if (+stats.mtime - modifiedTime > 15)
                    this.trigger(id);
            }
        };
        if (chokidarOptions) {
            this.fsWatcher = chokidar$1.watch(id, chokidarOptions).on('all', handleWatchEvent);
        }
        else {
            this.fsWatcher = watch$1(id, opts, handleWatchEvent);
        }
        group.set(id, this);
    }
    addTask(task, isTransformDependency = false) {
        if (isTransformDependency)
            this.transformDependencyTasks.add(task);
        else
            this.tasks.add(task);
    }
    close() {
        this.fsWatcher.close();
    }
    deleteTask(task, group) {
        let deleted = this.tasks.delete(task);
        deleted = this.transformDependencyTasks.delete(task) || deleted;
        if (deleted && this.tasks.size === 0 && this.transformDependencyTasks.size === 0) {
            group.delete(this.id);
            this.close();
        }
    }
    trigger(id) {
        this.tasks.forEach(task => {
            task.invalidate(id, false);
        });
        this.transformDependencyTasks.forEach(task => {
            task.invalidate(id, true);
        });
    }
}

const DELAY = 200;
class Watcher {
    constructor(configs) {
        this.invalidatedIds = new Set();
        this.rerun = false;
        this.succeeded = false;
        this.emitter = new (class extends EventEmitter {
            constructor(close) {
                super();
                this.close = close;
                // Allows more than 10 bundles to be watched without
                // showing the `MaxListenersExceededWarning` to the user.
                this.setMaxListeners(Infinity);
            }
        })(this.close.bind(this));
        this.tasks = (Array.isArray(configs) ? configs : configs ? [configs] : []).map(config => new Task(this, config));
        this.running = true;
        process.nextTick(() => this.run());
    }
    close() {
        if (this.buildTimeout)
            clearTimeout(this.buildTimeout);
        this.tasks.forEach(task => {
            task.close();
        });
        this.emitter.removeAllListeners();
    }
    emit(event, value) {
        this.emitter.emit(event, value);
    }
    invalidate(id) {
        if (id) {
            this.invalidatedIds.add(id);
        }
        if (this.running) {
            this.rerun = true;
            return;
        }
        if (this.buildTimeout)
            clearTimeout(this.buildTimeout);
        this.buildTimeout = setTimeout(() => {
            this.buildTimeout = undefined;
            this.invalidatedIds.forEach(id => this.emit('change', id));
            this.invalidatedIds.clear();
            this.emit('restart');
            this.run();
        }, DELAY);
    }
    run() {
        this.running = true;
        this.emit('event', {
            code: 'START'
        });
        let taskPromise = Promise.resolve();
        for (const task of this.tasks)
            taskPromise = taskPromise.then(() => task.run());
        return taskPromise
            .then(() => {
            this.succeeded = true;
            this.running = false;
            this.emit('event', {
                code: 'END'
            });
        })
            .catch(error => {
            this.running = false;
            this.emit('event', {
                code: this.succeeded ? 'ERROR' : 'FATAL',
                error
            });
        })
            .then(() => {
            if (this.rerun) {
                this.rerun = false;
                this.invalidate();
            }
        });
    }
}
class Task {
    constructor(watcher, config) {
        this.invalidated = true;
        this.cache = null;
        this.watcher = watcher;
        this.closed = false;
        this.watched = new Set();
        const { inputOptions, outputOptions } = mergeOptions({
            config
        });
        this.inputOptions = inputOptions;
        this.outputs = outputOptions;
        this.outputFiles = this.outputs.map(output => {
            if (output.file || output.dir)
                return path.resolve(output.file || output.dir);
            return undefined;
        });
        const watchOptions = inputOptions.watch || {};
        if ('useChokidar' in watchOptions)
            watchOptions.chokidar = watchOptions.useChokidar;
        let chokidarOptions = 'chokidar' in watchOptions ? watchOptions.chokidar : !!chokidar$1;
        if (chokidarOptions) {
            chokidarOptions = Object.assign({}, (chokidarOptions === true ? {} : chokidarOptions), { disableGlobbing: true, ignoreInitial: true });
        }
        if (chokidarOptions && !chokidar$1) {
            throw new Error(`watch.chokidar was provided, but chokidar could not be found. Have you installed it?`);
        }
        this.chokidarOptions = chokidarOptions;
        this.chokidarOptionsHash = JSON.stringify(chokidarOptions);
        this.filter = createFilter(watchOptions.include, watchOptions.exclude);
    }
    close() {
        this.closed = true;
        this.watched.forEach(id => {
            deleteTask(id, this, this.chokidarOptionsHash);
        });
    }
    invalidate(id, isTransformDependency) {
        this.invalidated = true;
        if (isTransformDependency) {
            this.cache.modules.forEach(module => {
                if (!module.transformDependencies || module.transformDependencies.indexOf(id) === -1)
                    return;
                // effective invalidation
                module.originalCode = null;
            });
        }
        this.watcher.invalidate(id);
    }
    run() {
        if (!this.invalidated)
            return;
        this.invalidated = false;
        const options = Object.assign({}, this.inputOptions, { cache: this.cache });
        const start = Date.now();
        this.watcher.emit('event', {
            code: 'BUNDLE_START',
            input: this.inputOptions.input,
            output: this.outputFiles
        });
        setWatcher(this.watcher.emitter);
        return rollup(options)
            .then(result => {
            if (this.closed)
                return undefined;
            const watched = (this.watched = new Set());
            this.cache = result.cache;
            this.watchFiles = result.watchFiles;
            this.cache.modules.forEach(module => {
                if (module.transformDependencies) {
                    module.transformDependencies.forEach(depId => {
                        watched.add(depId);
                        this.watchFile(depId, true);
                    });
                }
            });
            this.watchFiles.forEach(id => {
                watched.add(id);
                this.watchFile(id);
            });
            this.watched.forEach(id => {
                if (!watched.has(id))
                    deleteTask(id, this, this.chokidarOptionsHash);
            });
            return Promise.all(this.outputs.map(output => result.write(output))).then(() => result);
        })
            .then((result) => {
            this.watcher.emit('event', {
                code: 'BUNDLE_END',
                duration: Date.now() - start,
                input: this.inputOptions.input,
                output: this.outputFiles,
                result
            });
        })
            .catch((error) => {
            if (this.closed)
                return;
            if (this.cache) {
                // this is necessary to ensure that any 'renamed' files
                // continue to be watched following an error
                if (this.cache.modules) {
                    this.cache.modules.forEach(module => {
                        if (module.transformDependencies) {
                            module.transformDependencies.forEach(depId => {
                                this.watchFile(depId, true);
                            });
                        }
                    });
                }
                this.watchFiles.forEach(id => {
                    this.watchFile(id);
                });
            }
            throw error;
        });
    }
    watchFile(id, isTransformDependency = false) {
        if (!this.filter(id))
            return;
        if (this.outputFiles.some(file => file === id)) {
            throw new Error('Cannot import the generated bundle');
        }
        // this is necessary to ensure that any 'renamed' files
        // continue to be watched following an error
        addTask(id, this, this.chokidarOptions, this.chokidarOptionsHash, isTransformDependency);
    }
}
function watch(configs) {
    return new Watcher(configs).emitter;
}

export { version as VERSION, rollup, watch };
