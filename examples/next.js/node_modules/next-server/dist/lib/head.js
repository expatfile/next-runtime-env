"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const side_effect_1 = __importDefault(require("./side-effect"));
const amphtml_context_1 = require("./amphtml-context");
const head_manager_context_1 = require("./head-manager-context");
const amp_1 = require("./amp");
function defaultHead(className = 'next-head', isAmp = false) {
    const head = [
        react_1.default.createElement("meta", { key: "charSet", charSet: "utf-8", className: className }),
    ];
    if (!isAmp) {
        head.push(react_1.default.createElement("meta", { key: "viewport", name: "viewport", content: "width=device-width,minimum-scale=1,initial-scale=1", className: className }));
    }
    return head;
}
exports.defaultHead = defaultHead;
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === "string" || typeof child === "number") {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === react_1.default.Fragment) {
        return list.concat(react_1.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild) => {
            if (typeof fragmentChild === "string" ||
                typeof fragmentChild === "number") {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = ["name", "httpEquiv", "charSet", "viewport", "itemProp"];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/
function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h) => {
        if (h.key && typeof h.key !== 'number' && h.key.indexOf(".$") === 0) {
            if (keys.has(h.key))
                return false;
            keys.add(h.key);
            return true;
        }
        switch (h.type) {
            case "title":
            case "base":
                if (tags.has(h.type))
                    return false;
                tags.add(h.type);
                break;
            case "meta":
                for (let i = 0, len = METATYPES.length; i < len; i++) {
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype))
                        continue;
                    if (metatype === "charSet" || metatype === "viewport") {
                        if (metaTypes.has(metatype))
                            return false;
                        metaTypes.add(metatype);
                    }
                    else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if (categories.has(category))
                            return false;
                        categories.add(category);
                        metaCategories[metatype] = categories;
                    }
                }
                break;
        }
        return true;
    };
}
/**
 *
 * @param headElement List of multiple <Head> instances
 */
function reduceComponents(headElements, props) {
    return headElements
        .reduce((list, headElement) => {
        const headElementChildren = react_1.default.Children.toArray(headElement.props.children);
        return list.concat(headElementChildren);
    }, [])
        .reduce(onlyReactElement, [])
        .reverse()
        .concat(defaultHead('', props.isAmp))
        .filter(unique())
        .reverse()
        .map((c, i) => {
        const className = (c.props && c.props.className ? c.props.className + " " : "") +
            "next-head";
        const key = c.key || i;
        return react_1.default.cloneElement(c, { key, className });
    });
}
const Effect = side_effect_1.default();
function Head({ children }) {
    return (react_1.default.createElement(amphtml_context_1.AmpModeContext.Consumer, null, (ampMode) => (react_1.default.createElement(head_manager_context_1.HeadManagerContext.Consumer, null, (updateHead) => (react_1.default.createElement(Effect, { reduceComponentsToState: reduceComponents, handleStateChange: updateHead, isAmp: amp_1.isAmp(ampMode) }, children))))));
}
Head.rewind = Effect.rewind;
exports.default = Head;
